Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: aic
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: aw
Only in /home/yajat/Desktop/aosp12_r11/hardware/broadcom/libbt: .git
diff -r /home/yajat/Desktop/aosp12_r11/hardware/broadcom/libbt/include/userial_vendor.h /home/yajat/Desktop/H618-Android12-Src/hardware/broadcom/libbt/include/userial_vendor.h
55a56,57
> #define USERIAL_BAUD_2_5M       17
> #define USERIAL_BAUD_3_5M       18
diff -r /home/yajat/Desktop/aosp12_r11/hardware/broadcom/libbt/src/hardware.c /home/yajat/Desktop/H618-Android12-Src/hardware/broadcom/libbt/src/hardware.c
363a364,365
>     else if (line_speed == 3500000)
>         baud = USERIAL_BAUD_3_5M;
365a368,369
>     else if (line_speed == 2500000)
>         baud = USERIAL_BAUD_2_5M;
367a372,373
>     else if (line_speed == 1500000)
>         baud = USERIAL_BAUD_1_5M;
diff -r /home/yajat/Desktop/aosp12_r11/hardware/broadcom/libbt/src/userial_vendor.c /home/yajat/Desktop/H618-Android12-Src/hardware/broadcom/libbt/src/userial_vendor.c
93a94,95
>     else if (cfg_baud == USERIAL_BAUD_3_5M)
>         *baud = B3500000;
95a98,99
>     else if (cfg_baud == USERIAL_BAUD_2_5M)
>         *baud = B2500000;
97a102,103
>     else if (cfg_baud == USERIAL_BAUD_1_5M)
>         *baud = B1500000;
Only in /home/yajat/Desktop/aosp12_r11/hardware/broadcom/wlan: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/apf: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/av: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/camera: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/easel: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/interfaces: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/pixel: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/google/pixel-sepolicy: .git
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/Android.bp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/Android.bp
84a85
>         "Libve_Decoder2.c",
108a110,112
>         "libvencoder",
>         "libvdecoder",
>         "libMemAdapter",
113a118,120
>     include_dirs: [
>         "frameworks/av/media/libcedarc/include",
>     ],
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/ExternalCameraDevice.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/ExternalCameraDevice.cpp
42,43c42,47
< const std::array<uint32_t, /*size*/ 2> kSupportedFourCCs{
<     {V4L2_PIX_FMT_MJPEG, V4L2_PIX_FMT_Z16}};  // double braces required in C++11
---
> const std::array<uint32_t, /*size*/ 4> kSupportedFourCCs{
>     { V4L2_PIX_FMT_MJPEG,
>       V4L2_PIX_FMT_Z16,
>       V4L2_PIX_FMT_YUYV,
>       V4L2_PIX_FMT_H264
>     }};  // double braces required in C++11
277a282,283
>             case V4L2_PIX_FMT_YUYV: hasColor = true; break;
>             case V4L2_PIX_FMT_H264: hasColor = true; break;
429a436
>     ALOGD("orientation:%d", orientation);
703c710
<     // For V4L2_PIX_FMT_MJPEG
---
>     // For V4L2_PIX_FMT_MJPEG, V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_H264
706a714,717
>     bool isMJPEG = false;
>     bool isYUYV  = false;
>     bool isH264  = false;
> 
713a725,733
>                 isMJPEG = true;
>                 break;
>             case V4L2_PIX_FMT_YUYV:
>                 hasColor = true;
>                 isYUYV = true;
>                 break;
>             case V4L2_PIX_FMT_H264:
>                 hasColor = true;
>                 isH264 = true;
730,734c750,769
<         initOutputCharskeysByFormat(metadata, V4L2_PIX_FMT_MJPEG, halFormats,
<                 ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT,
<                 ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS,
<                 ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS,
<                 ANDROID_SCALER_AVAILABLE_STALL_DURATIONS);
---
>         if (isMJPEG) {
>             initOutputCharskeysByFormat(metadata, V4L2_PIX_FMT_MJPEG, halFormats,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS,
>                     ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS,
>                     ANDROID_SCALER_AVAILABLE_STALL_DURATIONS);
>         } else if (isYUYV) {
>             initOutputCharskeysByFormat(metadata, V4L2_PIX_FMT_YUYV, halFormats,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS,
>                     ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS,
>                     ANDROID_SCALER_AVAILABLE_STALL_DURATIONS);
>         } else if (isH264) {
>             initOutputCharskeysByFormat(metadata, V4L2_PIX_FMT_H264, halFormats,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT,
>                     ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS,
>                     ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS,
>                     ANDROID_SCALER_AVAILABLE_STALL_DURATIONS);
>         }
> 
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/ExternalCameraDeviceSession.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
35d34
< 
43a43,169
> 
> #define ALIGN_4K(x) (((x) + (4095)) & ~(4095))
> #define ALIGN_32B(x) (((x) + (31)) & ~(31))
> #define ALIGN_16B(x) (((x) + (15)) & ~(15))
> #define ALIGN_8B(x) (((x) + (7)) & ~(7))
> 
> #define DBG_SAVE_OUTPUT 0
> #if DBG_SAVE_OUTPUT
> static int mjpeg_count  = 0;
> static int yuyv_count  = 0;
> static int dq_yuv_count  = 0;
> const  int output_counts = 10;
> static int awjpeg_count  = 0;
> 
> bool saveBuffers(const char *str, void *p, unsigned int length, bool is_oneframe) {
>     int fd;
>     ALOGD("Debug to save a frame!");
>     if ((access(str, 0) != -1) && (is_oneframe)) {
>         ALOGD("File %s is exists!!!\n", str);
>         if (remove(str) < 0) {
>           ALOGE("File %s remove error\n", str);
>           return false;
>         }
>     }
>     if (is_oneframe) {
>         fd = open(str, O_CREAT|O_RDWR|O_TRUNC, 0777);  // save one frame data
>     } else {
>         fd = open(str, O_CREAT|O_RDWR|O_APPEND, 0777);  // save more frames
>     }
>     if (!fd) {
>         ALOGE("Open file error %s", strerror(errno));
>         return false;
>     }
>     if (write(fd, p, length) == 0) {
>         ALOGD("Write file succeed!");
>         close(fd);
>         return true;
>     } else {
>         ALOGE("Write file fail %s", strerror(errno));
>         close(fd);
>         return false;
>     }
> }
> #endif
> 
> void YUYVToNV21(uint8_t* image_in,
>                 uint8_t* image_out,
>                 int width,
>                 int height) {
> 
>     int pixNUM = width * height;
> 
>     uint8_t *y = image_out;
>     uint8_t *uv = image_out + pixNUM ;
>     uint8_t *start = image_in;
>     int j = 0, k = 0;
> 
>     int index =0;
>     for (j = 0; j < pixNUM * 2; j = j + 2) {
>         *(y + index) = *(start + j);
>         index++;
>     }
> 
>     start = image_in;
>     int uv_index = 0;
>     for (j = 0; j < height; j = j + 2) {
>         for (k = j * width * 2 + 1; k < width * 2 * (j + 1); k = k + 4) {
>             *(uv + uv_index) = *(start + k + 2);
>             *(uv + uv_index + 1) = *(start + k);
>             uv_index += 2;
>         }
>     }
> }
> 
> int NV21Scale(uint8_t *psrc_buf_y,
>               uint8_t *psrc_buf_uv,
>               int      psrc_w,
>               int      psrc_h,
>               uint8_t *pdst_buf,
>               uint8_t *pdst_buf_uv,
>               int      pdst_w,
>               int      pdst_h,
>               libyuv::FilterModeEnum pfmode) {
>   uint8_t *i420_buf1 = (uint8_t *)malloc((psrc_w * psrc_h * 3) >> 1);
>   if (i420_buf1 == nullptr) {
>       ALOGE("malloc i420_buf1 failed!");
>       return -1;
>   }
>   uint8_t *i420_buf2 = (uint8_t *)malloc((pdst_w * pdst_h * 3) >> 1);
>   if (i420_buf2 == nullptr) {
>       ALOGE("malloc i420_buf2 failed!");
>       return -1;
>   }
> 
>   libyuv::NV12ToI420(psrc_buf_y,              psrc_w,
>       psrc_buf_uv,                            psrc_w,
>       &i420_buf1[0],                          psrc_w,
>       &i420_buf1[psrc_w * psrc_h],            psrc_w >> 1,
>       &i420_buf1[(psrc_w * psrc_h * 5) >> 2], psrc_w >> 1,
>       psrc_w, psrc_h);
> 
>   libyuv::I420Scale(&i420_buf1[0],            psrc_w,
>       &i420_buf1[psrc_w * psrc_h],            psrc_w >> 1,
>       &i420_buf1[(psrc_w * psrc_h * 5) >> 2], psrc_w >> 1,
>       psrc_w, psrc_h,
>       &i420_buf2[0],                          pdst_w,
>       &i420_buf2[pdst_w * pdst_h],            pdst_w >> 1,
>       &i420_buf2[(pdst_w * pdst_h * 5) >> 2], pdst_w >> 1,
>       pdst_w, pdst_h,
>       pfmode);
> 
>   libyuv::I420ToNV12(&i420_buf2[0],           pdst_w,
>       &i420_buf2[pdst_w * pdst_h],            pdst_w >> 1,
>       &i420_buf2[(pdst_w * pdst_h * 5) >> 2], pdst_w >> 1,
>       pdst_buf,                               pdst_w,
>       pdst_buf_uv,                            pdst_w,
>       pdst_w,pdst_h);
> 
>   if (i420_buf1 != nullptr) {
>     free(i420_buf1);
>   }
>   if (i420_buf2 != nullptr) {
>     free(i420_buf2);
>   }
>   return 0;
> }
> 
47c173
< const int kBadFramesAfterStreamOn = 1; // drop x frames after streamOn to get rid of some initial
---
> int kBadFramesAfterStreamOn = 0; // drop x frames after streamOn to get rid of some initial
55c181
< static constexpr int kDumpLockRetries = 50;
---
> static constexpr int kDumpLockRetries = 10;
107c233,254
<         mMaxJpegResolution(getMaxJpegResolution()) {}
---
>         mMaxJpegResolution(getMaxJpegResolution()),
>         mDecoder(NULL) {
>           // set default format to mjpeg
>           int fourcc = property_get_int32(
>               "vendor.camera.uvc.fourcc", 0);
>           switch (fourcc) {
>             case 0:
>               mForceFourcc = V4L2_PIX_FMT_MJPEG;
>               break;
>             case 1:
>               mForceFourcc = V4L2_PIX_FMT_YUYV;
>               break;
>             case 2:
>               mForceFourcc = V4L2_PIX_FMT_H264;
>               kBadFramesAfterStreamOn = 0;
>               break;
>             default:
>               mForceFourcc = V4L2_PIX_FMT_MJPEG;
>               break;
>           }
>         }
> 
475,482c622,633
<     Mutex::Autolock _il(mInterfaceLock);
<     bool closed = isClosed();
<     if (!closed) {
<         if (callerIsDtor) {
<             closeOutputThreadImpl();
<         } else {
<             closeOutputThread();
<         }
---
>     bool intfLocked = tryLock(mInterfaceLock);
>     if (!intfLocked) {
>         ALOGW("tryLock failed!! raise SIGABRT to exit.");
>         raise(SIGABRT);
>     } else {
>         bool closed = isClosed();
>         if (!closed) {
>             if (callerIsDtor) {
>                 closeOutputThreadImpl();
>             } else {
>                 closeOutputThread();
>             }
484,489c635,636
<         Mutex::Autolock _l(mLock);
<         // free all buffers
<         {
<             Mutex::Autolock _l(mCbsLock);
<             for(auto pair : mStreamMap) {
<                 cleanupBuffersLocked(/*Stream ID*/pair.first);
---
>             if (mDecoder != NULL) {
>                 Libve_exit2(&mDecoder);
490a638,653
> 
>             if(mVideoConf.memops) {
>                 CdcMemClose(mVideoConf.memops);
>             }
>             Mutex::Autolock _l(mLock);
>             // free all buffers
>             {
>                 Mutex::Autolock _l(mCbsLock);
>                 for(auto pair : mStreamMap) {
>                     cleanupBuffersLocked(/*Stream ID*/pair.first);
>                 }
>             }
>             v4l2StreamOffLocked();
>             ALOGV("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
>             mV4l2Fd.reset();
>             mClosed = true;
492,495c655
<         v4l2StreamOffLocked();
<         ALOGV("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
<         mV4l2Fd.reset();
<         mClosed = true;
---
>         mInterfaceLock.unlock();
716a877,886
>     //std::unique_lock<std::mutex> lk(mBufferLock);
>     // Convert input V4L2 frame to YU12 of the same size
>     // TODO: see if we can save some computation by converting to YV12 here
>     uint8_t* inData;
>     size_t inDataSize;
>     if (frameIn->getData(&inData, &inDataSize) != 0) {
>       //lk.unlock();
>       return Status::INTERNAL_ERROR;
>     }
> 
1300d1469
<     YCbCrLayout yu12Main;
1301a1471,1480
>     int jpegOrientation;
>     if (setting.exists(ANDROID_JPEG_ORIENTATION)) {
>         camera_metadata_ro_entry entry =
>             setting.find(ANDROID_JPEG_ORIENTATION);
>         jpegOrientation = entry.data.u8[0];
>     } else {
>         return lfail("%s: ANDROID_JPEG_ORIENTATION not set",__FUNCTION__);
>     }
> 
> 
1307d1485
<     const ssize_t maxThumbCodeSize = 64 * 1024;
1320,1351c1498
<     size_t thumbCodeSize = 0, jpegCodeSize = 0;
<     /* Temporary thumbnail code buffer */
<     std::vector<uint8_t> thumbCode(outputThumbnail ? maxThumbCodeSize : 0);
< 
<     YCbCrLayout yu12Thumb;
<     if (outputThumbnail) {
<         ret = cropAndScaleThumbLocked(mYu12Frame, thumbSize, &yu12Thumb);
< 
<         if (ret != 0) {
<             return lfail(
<                 "%s: crop and scale thumbnail failed!", __FUNCTION__);
<         }
<     }
< 
<     /* Scale and crop main jpeg */
<     ret = cropAndScaleLocked(mYu12Frame, jpegSize, &yu12Main);
< 
<     if (ret != 0) {
<         return lfail("%s: crop and scale main failed!", __FUNCTION__);
<     }
< 
<     /* Encode the thumbnail image */
<     if (outputThumbnail) {
<         ret = encodeJpegYU12(thumbSize, yu12Thumb,
<                 thumbQuality, 0, 0,
<                 &thumbCode[0], maxThumbCodeSize, thumbCodeSize);
< 
<         if (ret != 0) {
<             return lfail("%s: thumbnail encodeJpegYU12 failed with %d",__FUNCTION__, ret);
<         }
<     }
< 
---
>     size_t jpegCodeSize = 0;
1366,1375d1512
<     ret = utils->generateApp1(outputThumbnail ? &thumbCode[0] : 0, thumbCodeSize);
< 
<     if (!ret) {
<         return lfail("%s: generating APP1 failed", __FUNCTION__);
<     }
< 
<     /* Get internal buffer */
<     size_t exifDataSize = utils->getApp1Length();
<     const uint8_t* exifData = utils->getApp1Buffer();
< 
1384,1387c1521,1642
<     /* Encode the main jpeg image */
<     ret = encodeJpegYU12(jpegSize, yu12Main,
<             jpegQuality, exifData, exifDataSize,
<             bufPtr, maxJpegCodeSize, jpegCodeSize);
---
>     JpegEncInfo sjpegInfo;
>     memset(&sjpegInfo, 0, sizeof(JpegEncInfo));
> 
>     //todo: ignore scale and modify input widht/height
>     sjpegInfo.sBaseInfo.nStride = mYu12Frame->mWidth;
>     sjpegInfo.sBaseInfo.nInputWidth = mYu12Frame->mWidth;
>     sjpegInfo.sBaseInfo.nInputHeight = mYu12Frame->mHeight;
> 
>     sjpegInfo.sBaseInfo.nDstWidth = jpegSize.width;
>     sjpegInfo.sBaseInfo.nDstHeight = jpegSize.height;
>     sjpegInfo.sBaseInfo.eInputFormat = VENC_PIXEL_YVU420SP;
> 
>     ALOGV("%s sjpegInfo input w = %d h = %d output w = %d h = %d stride=%d",
>         __func__,
>         sjpegInfo.sBaseInfo.nInputWidth,
>         sjpegInfo.sBaseInfo.nInputHeight,
>         sjpegInfo.sBaseInfo.nDstWidth,
>         sjpegInfo.sBaseInfo.nDstHeight,
>         sjpegInfo.sBaseInfo.nStride
>         );
> 
>     sjpegInfo.quality = jpegQuality;
>     sjpegInfo.bEnableCorp = 0;
>     sjpegInfo.bNoUseAddrPhy = 1;
> 
>     sjpegInfo.pAddrPhyY = (unsigned char *)mYu12FrameLayout.y;
>     sjpegInfo.pAddrPhyC = (unsigned char *)mYu12FrameLayout.cb;
>     sjpegInfo.pAddrVirY = (unsigned char *)mYu12FrameLayout.y;
>     sjpegInfo.pAddrVirC = (unsigned char *)mYu12FrameLayout.cb;
>     ALOGV("pAddrPhyY = %p pAddrPhyC=%p pAddrVirY=%p pAddrVirC=%p",
>         sjpegInfo.pAddrPhyY,
>         sjpegInfo.pAddrPhyC,
>         sjpegInfo.pAddrVirY,
>         sjpegInfo.pAddrVirC);
> 
>     EXIFInfo   exifInfo;
>     memset(&exifInfo, 0, sizeof(EXIFInfo));
>     exifInfo.Orientation    = 0;
>     exifInfo.ThumbWidth  = thumbSize.width;
>     exifInfo.ThumbHeight = thumbSize.height;
> 
>     time_t t;
>     struct tm *tm_t;
>     time(&t);
>     tm_t = localtime(&t);
>     char mDateTime[21];
>     sprintf(mDateTime, "%4d:%02d:%02d %02d:%02d:%02d",
>             tm_t->tm_year+1900, tm_t->tm_mon+1, tm_t->tm_mday,
>             tm_t->tm_hour, tm_t->tm_min, tm_t->tm_sec);
> 
>     char property[1024];
>     char CameraMake[64];
>     char CameraModel[64];
>     if (property_get("ro.product.manufacturer", property, "") > 0)
>     {
>         strcpy(CameraMake, property);
>     }
>     if (property_get("ro.product.model", property, "") > 0)
>     {
>         strcpy(CameraModel, property);
>     }
> 
>     strcpy((char*)exifInfo.CameraMake, CameraMake);
>     strcpy((char*)exifInfo.CameraModel, CameraModel);
>     strcpy((char*)exifInfo.DateTime, mDateTime);
> 
>     struct timeval tv;
>     gettimeofday(&tv, NULL);
>     char       subSecTime1[8];
>     char       subSecTime2[8];
>     char       subSecTime3[8];
>     sprintf(subSecTime1, "%06ld", tv.tv_usec);
>     sprintf(subSecTime2, "%06ld", tv.tv_usec);
>     sprintf(subSecTime3, "%06ld", tv.tv_usec);
>     strcpy((char*)exifInfo.subSecTime,     subSecTime1);
>     strcpy((char*)exifInfo.subSecTimeOrig, subSecTime2);
>     strcpy((char*)exifInfo.subSecTimeDig,  subSecTime3);
> 
>     exifInfo.ExposureTime.num = 25;
>     exifInfo.ExposureTime.den = 100;
> 
>     exifInfo.FNumber.num = 200; //eg:FNum=2.2, aperture = 220, --> num = 220,den = 100
>     exifInfo.FNumber.den = 100;
>     exifInfo.ISOSpeed = 400;
> 
>     exifInfo.ExposureBiasValue.num= 25;
>     exifInfo.ExposureBiasValue.den= 100;
> 
>     exifInfo.MeteringMode = 0;
>     exifInfo.FlashUsed = 0;
> 
>     exifInfo.FocalLength.num = 304;
>     exifInfo.FocalLength.den = 100;
> 
>     exifInfo.DigitalZoomRatio.num = 0;
>     exifInfo.DigitalZoomRatio.den = 0;
> 
>     exifInfo.WhiteBalance = 0;
>     exifInfo.ExposureMode = 0;
> 
>     int bufSize = 0;
> 
> #if DBG_SAVE_OUTPUT
>     char awjpec_path[100];
>     awjpeg_count = awjpeg_count % output_counts;
>     sprintf(awjpec_path, "/data/camera/jpec_%d_%dx%d.bin",
>         awjpeg_count, mYu12Frame->mWidth, mYu12Frame->mHeight);
>     saveBuffers(awjpec_path,
>                 (void*)mYu12FrameLayout.y,
>                 mYu12Frame->mWidth * mYu12Frame->mHeight * 3 / 2,
>                 true);
> #endif
> 
>     ret = AWJpecEnc(&sjpegInfo, &exifInfo, bufPtr, &bufSize);
> 
> #if DBG_SAVE_OUTPUT
>     char awjpeg_path[100];
>     sprintf(awjpeg_path, "/data/camera/jpec_%d_%dx%d.jpg",
>         awjpeg_count++, mYu12Frame->mWidth, mYu12Frame->mHeight);
>     saveBuffers(awjpeg_path, bufPtr, bufSize, true);
> #endif
> 
1441c1696,1699
<     if (req->frameIn->mFourcc != V4L2_PIX_FMT_MJPEG && req->frameIn->mFourcc != V4L2_PIX_FMT_Z16) {
---
>     if (req->frameIn->mFourcc != V4L2_PIX_FMT_MJPEG &&
>         req->frameIn->mFourcc != V4L2_PIX_FMT_Z16 &&
>         req->frameIn->mFourcc != V4L2_PIX_FMT_YUYV &&
>         req->frameIn->mFourcc != V4L2_PIX_FMT_H264) {
1466,1473c1724,1729
<     if (req->frameIn->mFourcc == V4L2_PIX_FMT_MJPEG) {
<         ATRACE_BEGIN("MJPGtoI420");
<         int res = libyuv::MJPGToI420(
<             inData, inDataSize, static_cast<uint8_t*>(mYu12FrameLayout.y), mYu12FrameLayout.yStride,
<             static_cast<uint8_t*>(mYu12FrameLayout.cb), mYu12FrameLayout.cStride,
<             static_cast<uint8_t*>(mYu12FrameLayout.cr), mYu12FrameLayout.cStride,
<             mYu12Frame->mWidth, mYu12Frame->mHeight, mYu12Frame->mWidth, mYu12Frame->mHeight);
<         ATRACE_END();
---
>     VideoStreamDataInfo dataInfo = parent->getVideoStreamDataInfo();
>     dataInfo.nLength = inDataSize;
>     dataInfo.bValid = 1;
>     VideoDecoder *decoder = parent->getVideoDecoder();
>     VideoStreamInfo streamInfo = parent->getVideoStreamInfo();
>     VConfig vConfig = parent->getVideoConfig();
1475,1484c1731,1790
<         if (res != 0) {
<             // For some webcam, the first few V4L2 frames might be malformed...
<             ALOGE("%s: Convert V4L2 frame to YU12 failed! res %d", __FUNCTION__, res);
<             lk.unlock();
<             Status st = parent->processCaptureRequestError(req);
<             if (st != Status::OK) {
<                 return onDeviceError("%s: failed to process capture request error!", __FUNCTION__);
<             }
<             signalRequestDone();
<             return true;
---
> #if DBG_SAVE_OUTPUT
>     if (req->frameIn->mFourcc == V4L2_PIX_FMT_MJPEG) {
>       char mjpg_path[100];
>       mjpeg_count = mjpeg_count % output_counts;
>       sprintf(mjpg_path, "/data/camera/mjpeg_%d_%dx%d_%c%c%c%c.jpg",
>           mjpeg_count++,
>           req->frameIn->mWidth,
>           req->frameIn->mHeight,
>           req->frameIn->mFourcc & 0xFF,
>           (req->frameIn->mFourcc >> 8) & 0xFF,
>           (req->frameIn->mFourcc >> 16) & 0xFF,
>           (req->frameIn->mFourcc >> 24) & 0xFF);
>       saveBuffers(mjpg_path, (void*)inData, inDataSize, true);
>     } else if (req->frameIn->mFourcc == V4L2_PIX_FMT_YUYV) {
>       char yuyv_path[100];
>       yuyv_count = yuyv_count % output_counts;
>       sprintf(yuyv_path, "/data/camera/yuyv_%d_%dx%d_%c%c%c%c.bin",
>           yuyv_count++,
>           req->frameIn->mWidth,
>           req->frameIn->mHeight,
>           req->frameIn->mFourcc & 0xFF,
>           (req->frameIn->mFourcc >> 8) & 0xFF,
>           (req->frameIn->mFourcc >> 16) & 0xFF,
>           (req->frameIn->mFourcc >> 24) & 0xFF);
>       saveBuffers(yuyv_path, (void*)inData, inDataSize, true);
>     }
>     else if (req->frameIn->mFourcc == V4L2_PIX_FMT_H264) {
>       char h264_path[100];
>       sprintf(h264_path, "/data/camera/h264_%dx%d_%c%c%c%c.bin",
>           req->frameIn->mWidth,
>           req->frameIn->mHeight,
>           req->frameIn->mFourcc & 0xFF,
>           (req->frameIn->mFourcc >> 8) & 0xFF,
>           (req->frameIn->mFourcc >> 16) & 0xFF,
>           (req->frameIn->mFourcc >> 24) & 0xFF);
>       saveBuffers(h264_path, (void*)inData, inDataSize, false);
>     }
> 
> #endif
> 
>     if (req->frameIn->mFourcc == V4L2_PIX_FMT_MJPEG ||
>         req->frameIn->mFourcc == V4L2_PIX_FMT_H264) {
>         ATRACE_BEGIN("MJPGtoNV21 or H264 to NV21");
>         int status = Libve_dec2(&decoder,
>                                 inData,
>                                 (void*)(mYu12FrameLayout.y),
>                                 (void*)(mYu12FrameLayout.cb),
>                                 &streamInfo,
>                                 &dataInfo,
>                                 &vConfig);
>         if (status != 0) {
>           ALOGE("no valid picture!!");
>           mScaledYu12Frames.clear();
>           lk.unlock();
>           Status st = parent->processCaptureResult(req);
>           if (st != Status::OK) {
>             return onDeviceError("%s: failed to process capture result!", __FUNCTION__);
>           }
>           signalRequestDone();
>           return true;
1485a1792,1799
>         ATRACE_END();
>     } else if (req->frameIn->mFourcc == V4L2_PIX_FMT_YUYV) {
>         ATRACE_BEGIN("YUY2toNV21");
>         YUYVToNV21(inData,
>                      static_cast<uint8_t*>(mYu12FrameLayout.y),
>                      mYu12Frame->mWidth,
>                      mYu12Frame->mHeight);
>         ATRACE_END();
1486a1801,1808
> #if DBG_SAVE_OUTPUT
>     char yuv_path[100];
>     dq_yuv_count = dq_yuv_count % output_counts;
>     sprintf(yuv_path, "/data/camera/nv21_%d_%dx%d.bin",
>         dq_yuv_count++, mYu12Frame->mWidth, mYu12Frame->mHeight);
>     int copySize = req->frameIn->mWidth * req->frameIn->mHeight * 3 / 2;
>     saveBuffers(yuv_path, (void*)mYu12FrameLayout.y, copySize, true);
> #endif
1529,1538c1851
<             case PixelFormat::Y16: {
<                 void* outLayout = sHandleImporter.lock(*(halBuf.bufPtr), halBuf.usage, inDataSize);
< 
<                 std::memcpy(outLayout, inData, inDataSize);
< 
<                 int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
<                 if (relFence >= 0) {
<                     halBuf.acquireFence = relFence;
<                 }
<             } break;
---
>             case PixelFormat::Y16:
1540c1853
<             case PixelFormat::YV12: {
---
>             case PixelFormat::YV12:{
1542,1576c1855,1889
<                         static_cast<int32_t>(halBuf.width),
<                         static_cast<int32_t>(halBuf.height)};
<                 YCbCrLayout outLayout = sHandleImporter.lockYCbCr(
<                         *(halBuf.bufPtr), halBuf.usage, outRect);
<                 ALOGV("%s: outLayout y %p cb %p cr %p y_str %d c_str %d c_step %d",
<                         __FUNCTION__, outLayout.y, outLayout.cb, outLayout.cr,
<                         outLayout.yStride, outLayout.cStride, outLayout.chromaStep);
< 
<                 // Convert to output buffer size/format
<                 uint32_t outputFourcc = getFourCcFromLayout(outLayout);
<                 ALOGV("%s: converting to format %c%c%c%c", __FUNCTION__,
<                         outputFourcc & 0xFF,
<                         (outputFourcc >> 8) & 0xFF,
<                         (outputFourcc >> 16) & 0xFF,
<                         (outputFourcc >> 24) & 0xFF);
< 
<                 YCbCrLayout cropAndScaled;
<                 ATRACE_BEGIN("cropAndScaleLocked");
<                 int ret = cropAndScaleLocked(
<                         mYu12Frame,
<                         Size { halBuf.width, halBuf.height },
<                         &cropAndScaled);
<                 ATRACE_END();
<                 if (ret != 0) {
<                     lk.unlock();
<                     return onDeviceError("%s: crop and scale failed!", __FUNCTION__);
<                 }
< 
<                 Size sz {halBuf.width, halBuf.height};
<                 ATRACE_BEGIN("formatConvert");
<                 ret = formatConvert(cropAndScaled, outLayout, sz, outputFourcc);
<                 ATRACE_END();
<                 if (ret != 0) {
<                     lk.unlock();
<                     return onDeviceError("%s: format coversion failed!", __FUNCTION__);
---
>                   static_cast<int32_t>(halBuf.width),
>                   static_cast<int32_t>(halBuf.height)};
>                 YCbCrLayout outLayout = sHandleImporter.lockYCbCr(*(halBuf.bufPtr),
>                     halBuf.usage,
>                     outRect);
>                 ALOGV("%s: outLayout y %p cb %p cr %p y_str %d c_str %d c_step %d"
>                     " w = %d h = %d",
>                     __FUNCTION__,
>                     outLayout.y,
>                     outLayout.cb,
>                     outLayout.cr,
>                     outLayout.yStride,
>                     outLayout.cStride,
>                     outLayout.chromaStep,
>                     halBuf.width,
>                     halBuf.height);
> 
>                 if (mYu12Frame->mWidth != halBuf.width || mYu12Frame->mHeight != halBuf.height) {
>                     int ret = NV21Scale(static_cast<uint8_t*>(mYu12FrameLayout.y),
>                             static_cast<uint8_t*>(mYu12FrameLayout.cb),
>                             mYu12Frame->mWidth,
>                             mYu12Frame->mHeight,
>                             static_cast<uint8_t*>(outLayout.y),
>                             static_cast<uint8_t*>(outLayout.cr),
>                             halBuf.width,
>                             halBuf.height,
>                             libyuv::FilterMode::kFilterNone);
>                     if (ret != 0) {
>                         ALOGE("%s: NV12Scale failed!!", __FUNCTION__);
>                     }
>                 } else {
>                     int y_size = mYu12Frame->mWidth * mYu12Frame->mHeight;
>                     int c_size = mYu12Frame->mWidth * mYu12Frame->mHeight / 2;
>                     std::memcpy(outLayout.y,  mYu12FrameLayout.y, y_size);
>                     std::memcpy(outLayout.cr,  mYu12FrameLayout.cb, c_size - 1);
1947a2261
>     ALOGE("%s %d", __func__, __LINE__);
1968a2283,2290
>     ALOGD("%s fourcc force to w = %d h= %d %c%c%c%c",
>         __func__,
>         v4l2Fmt.width,
>         v4l2Fmt.height,
>         v4l2Fmt.fourcc & 0xFF,
>         (v4l2Fmt.fourcc >> 8) & 0xFF,
>         (v4l2Fmt.fourcc >> 16) & 0xFF,
>         (v4l2Fmt.fourcc >> 24) & 0xFF);
1973a2296
>     fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
2013c2336
<         return -EINVAL;
---
>         //return -EINVAL;
2045a2369
>     ALOGV("v4L2BufferCount = %d", v4lBufferCount);
2152a2477
>     mDataInfo.nPts    =(int64_t)systemTime()/1000;
2168a2494
> 
2181a2508,2524
>     int v4l2Size;
>     switch (mV4l2StreamingFmt.fourcc) {
>         case V4L2_PIX_FMT_MJPEG:
>             v4l2Size = buffer.bytesused;
>             break;
>         case V4L2_PIX_FMT_YUYV:
>             v4l2Size = buffer.bytesused;
>             break;
>         case V4L2_PIX_FMT_H264:
>             v4l2Size = buffer.bytesused;
>             break;
>         default:
>             v4l2Size = buffer.bytesused;
>             break;
>     }
>     ALOGV("v4l2Size = %d buffer.bytesused=%d", v4l2Size, buffer.bytesused);
> 
2184c2527,2529
<             buffer.index, mV4l2Fd.get(), buffer.bytesused, buffer.m.offset);
---
>             buffer.index, mV4l2Fd.get(),
>             v4l2Size,
>             buffer.m.offset);
2332c2677,2685
<             if (isAspectRatioClose(aspectRatio, desiredAr)) {
---
>             if (isAspectRatioClose(aspectRatio, desiredAr) && (fmt.fourcc == mForceFourcc)) {
>                 ALOGD("%d aspectRatio %f desiredAr %f with forceFourcc format:%c%c%c%c w = %d h= %d",
>                         isAspectRatioClose(aspectRatio, desiredAr), aspectRatio, desiredAr,
>                         fmt.fourcc & 0xFF,
>                         (fmt.fourcc >> 8) & 0xFF,
>                         (fmt.fourcc >> 16) & 0xFF,
>                         (fmt.fourcc >> 24) & 0xFF,
>                         fmt.width,fmt.height
>                      );
2340a2694,2716
>         for (const auto& fmt : mSupportedFormats) {
>             uint32_t dim = (mCroppingType == VERTICAL) ? fmt.width : fmt.height;
>             if (dim >= maxDim) {
>                 float aspectRatio = ASPECT_RATIO(fmt);
>                 if (isAspectRatioClose(aspectRatio, desiredAr)) {
>                     ALOGD("%d aspectRatio %f desiredAr %f format:%c%c%c%c w = %d h= %d",
>                             isAspectRatioClose(aspectRatio, desiredAr), aspectRatio, desiredAr,
>                             fmt.fourcc & 0xFF,
>                             (fmt.fourcc >> 8) & 0xFF,
>                             (fmt.fourcc >> 16) & 0xFF,
>                             (fmt.fourcc >> 24) & 0xFF,
>                             fmt.width,fmt.height
>                          );
>                     v4l2Fmt = fmt;
>                     // since mSupportedFormats is sorted by width then height, the first matching fmt
>                     // will be the smallest one with matching aspect ratio
>                     break;
>                 }
>             }
>         }
>     }
> 
>     if (v4l2Fmt.width == 0) {
2348,2349c2724,2727
<                     v4l2Fmt = fmt;
<                     break;
---
>                     if (fmt.fourcc == mForceFourcc) {
>                         v4l2Fmt = fmt;
>                         break;
>                     }
2371a2750,2792
>     if (v4l2Fmt.fourcc == V4L2_PIX_FMT_MJPEG ||
>         v4l2Fmt.fourcc == V4L2_PIX_FMT_H264 ) {
>         memset(&mVideoConf, 0, sizeof(mVideoConf));
>         mVideoConf.memops = MemAdapterGetOpsS();
>         if (mVideoConf.memops == NULL) {
>             ALOGE("MemAdapterGetOpsS failed\n");
>             return Status::INTERNAL_ERROR;
>         }
>         CdcMemOpen(mVideoConf.memops);
>         mVideoConf.eOutputPixelFormat  = PIXEL_FORMAT_NV21;
>         mVideoConf.bDisable3D          = 1;
>         mVideoConf.bScaleDownEn        = 0;
>         mVideoConf.bRotationEn         = 0;
>         mVideoConf.bSecOutputEn        = 0;
>         mVideoConf.bDispErrorFrame     = 1;
>         mVideoConf.nVbvBufferSize      = 0;
>         mVideoConf.nAlignStride        = 16;
> 
> 
>         if (v4l2Fmt.fourcc == V4L2_PIX_FMT_MJPEG) {
>             mVideoInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MJPEG;
>         } else if (v4l2Fmt.fourcc == V4L2_PIX_FMT_H264) {
>             mVideoInfo.eCodecFormat = VIDEO_CODEC_FORMAT_H264;
>         }
>         mVideoInfo.nWidth = v4l2Fmt.width;
>         mVideoInfo.nHeight = v4l2Fmt.height;
>         ALOGD("FUNC:%s, Line:%d width = %d,height = %d,", __FUNCTION__, __LINE__,
>                 mVideoInfo.nWidth,mVideoInfo.nHeight);
>         mVideoInfo.nFrameRate = mFrameRate;
>         mVideoInfo.nFrameDuration = 1000 * 1000 / mFrameRate;
>         mVideoInfo.nAspectRatio = 1000;
>         mVideoInfo.bIs3DStream = 0;
>         mVideoInfo.nCodecSpecificDataLen = 0;
>         mVideoInfo.pCodecSpecificData = NULL;
>         if(mDecoder != NULL){
>             Libve_exit2(&mDecoder);
>         }
>         Libve_init2(&mDecoder, &mVideoInfo, &mVideoConf);
>         if(mDecoder == NULL){
>             ALOGE("FUNC:%s, Line:%d ",__FUNCTION__,__LINE__);
>         }
>     }
> 
2419,2421c2840
<                 out->streams[i].v3_2.overrideFormat =
<                         (config.streams[i].usage & BufferUsage::VIDEO_ENCODER) ?
<                         PixelFormat::YCBCR_420_888 : PixelFormat::YV12;
---
>                 out->streams[i].v3_2.overrideFormat = PixelFormat::YCBCR_420_888;
2527a2947
>     mFrameRate = defaultFramerate;
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/ExternalCameraUtils.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/ExternalCameraUtils.cpp
890,891c890,891
<     fpsLimits.push_back({/*Size*/{1280,  720}, /*FPS upper bound*/7.5});
<     fpsLimits.push_back({/*Size*/{1920, 1080}, /*FPS upper bound*/5.0});
---
>     fpsLimits.push_back({/*Size*/{1280,  720}, /*FPS upper bound*/30.0});
>     fpsLimits.push_back({/*Size*/{1920, 1080}, /*FPS upper bound*/30.0});
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h
244a245,258
> 
>     virtual VideoDecoder* getVideoDecoder() {
>         return mDecoder;
>     }
> 
>     virtual VideoStreamInfo getVideoStreamInfo() {
>         return mVideoInfo;
>     }
>     virtual VConfig getVideoConfig() {
>         return mVideoConf;
>     }
>     virtual VideoStreamDataInfo getVideoStreamDataInfo() {
>         return mDataInfo;
>     }
391a406,413
>     VideoDecoder *                     mDecoder;
>     VConfig                            mVideoConf;
>     VideoStreamInfo                    mVideoInfo;
>     VideoStreamDataInfo                mDataInfo;
>     int                                mFrameRate;
>     int                                mForceFourcc;
> 
> 
452a475
> 
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraUtils.h /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraUtils.h
34c34
< 
---
> #include "../Libve_Decoder2.h"
277a278,282
> 
>     virtual  VideoDecoder* getVideoDecoder() = 0;
>     virtual  VideoStreamInfo getVideoStreamInfo() = 0;
>     virtual  VConfig getVideoConfig() = 0;
>     virtual  VideoStreamDataInfo getVideoStreamDataInfo() = 0;
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default/include: Libve_Decoder2.h
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.4/default: Libve_Decoder2.c
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.5/default/Android.bp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.5/default/Android.bp
111a112,114
>     include_dirs: [
>         "frameworks/av/media/libcedarc/include",
>     ],
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.6/default/Android.bp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.6/default/Android.bp
73a74,76
>     include_dirs: [
>         "frameworks/av/media/libcedarc/include",
>     ],
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/device/3.6/default/include/ext_device_v3_6_impl/ExternalCameraOfflineSession.h /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/device/3.6/default/include/ext_device_v3_6_impl/ExternalCameraOfflineSession.h
112a113,126
>     virtual VideoDecoder* getVideoDecoder() {
>         return mDecoder;
>     }
>     virtual VideoStreamInfo getVideoStreamInfo() {
>         return mVideoInfo;
>     }
>     virtual VConfig getVideoConfig() {
>         return mVideoConf;
>     }
>     virtual VideoStreamDataInfo getVideoStreamDataInfo() {
>         return mDataInfo;
>     }
> 
> 
201a216,219
>     VideoDecoder *                     mDecoder;
>     VConfig                            mVideoConf;
>     VideoStreamInfo                    mVideoInfo;
>     VideoStreamDataInfo                mDataInfo;
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/provider/2.4/default/Android.bp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/provider/2.4/default/Android.bp
90a91,93
>     include_dirs: [
>         "frameworks/av/media/libcedarc/include",
>     ],
138a142,144
>     include_dirs: [
>         "frameworks/av/media/libcedarc/include",
>     ],
diff -r /home/yajat/Desktop/aosp12_r11/hardware/interfaces/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/interfaces/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp
18c18
< //#define LOG_NDEBUG 0
---
> #define LOG_NDEBUG 0
217a218
>     ALOGI("ExtCam: adding %s to External Camera HAL cameraId = %s!", devName, cameraId.c_str());
231a233
>     ALOGD("bill %s %s", __func__, devName);
264a267
>     ALOGD("bill %s %s", __func__, devName);
Only in /home/yajat/Desktop/aosp12_r11/hardware/interfaces: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/invensense: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/knowles/athletico/sound_trigger_hal: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/libhardware: .git
diff -r /home/yajat/Desktop/aosp12_r11/hardware/libhardware/include/hardware/audio.h /home/yajat/Desktop/H618-Android12-Src/hardware/libhardware/include/hardware/audio.h
81a82,111
> /**
>  * audio codec parameters
>  */
> 
> #define AUDIO_OFFLOAD_CODEC_PARAMS "music_offload_codec_param"
> #define AUDIO_OFFLOAD_CODEC_BIT_PER_SAMPLE "music_offload_bit_per_sample"
> #define AUDIO_OFFLOAD_CODEC_BIT_RATE "music_offload_bit_rate"
> #define AUDIO_OFFLOAD_CODEC_AVG_BIT_RATE "music_offload_avg_bit_rate"
> #define AUDIO_OFFLOAD_CODEC_ID "music_offload_codec_id"
> #define AUDIO_OFFLOAD_CODEC_BLOCK_ALIGN "music_offload_block_align"
> #define AUDIO_OFFLOAD_CODEC_SAMPLE_RATE "music_offload_sample_rate"
> #define AUDIO_OFFLOAD_CODEC_ENCODE_OPTION "music_offload_encode_option"
> #define AUDIO_OFFLOAD_CODEC_NUM_CHANNEL  "music_offload_num_channels"
> #define AUDIO_OFFLOAD_CODEC_DOWN_SAMPLING  "music_offload_down_sampling"
> #define AUDIO_OFFLOAD_CODEC_DELAY_SAMPLES  "delay_samples"
> #define AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES  "padding_samples"
> #define AUDIO_PARAMETER_RAW_DATA_OUT "raw_data_output"
> 
> #define AUDIO_PARAMETER_DEVICES_IN "audio_devices_in"                       // read only
> #define AUDIO_PARAMETER_DEVICES_OUT "audio_devices_out"                     // read only
> #define AUDIO_PARAMETER_DEVICES_IN_ACTIVE "audio_devices_in_active"         // read/write
> #define AUDIO_PARAMETER_DEVICES_OUT_ACTIVE "audio_devices_out_active"       // read/write
> #define AUDIO_PARAMETER_KARAOK_AUDIO_CH    "switchChannel"
> #define AUDIO_PARAMETER_KARAOK_AUDIO_MIC   "micstart"
> 
> /* Hearing Aid Compatibility - Telecoil (HAC-T) mode on/off */
> #define AUDIO_PARAMETER_KEY_HAC "HACSetting"
> #define AUDIO_PARAMETER_VALUE_HAC_ON "ON"
> #define AUDIO_PARAMETER_VALUE_HAC_OFF "OFF"
> 
109a140,148
> #define AUDIO_PARAMETER_STREAM_ROUTING "routing"             /* audio_devices_t */
> #define AUDIO_PARAMETER_STREAM_FORMAT "format"               /* audio_format_t */
> #define AUDIO_PARAMETER_STREAM_CHANNELS "channels"           /* audio_channel_mask_t */
> #define AUDIO_PARAMETER_STREAM_FRAME_COUNT "frame_count"     /* size_t */
> #define AUDIO_PARAMETER_STREAM_INPUT_SOURCE "input_source"   /* audio_source_t */
> #define AUDIO_PARAMETER_STREAM_SAMPLING_RATE "sampling_rate" /* uint32_t */
> #define AUDIO_PARAMETER_USB_VOLUME "usbvolume"
> #define AUDIO_PARAMETER_DEVICE_CONNECT "connect"            /* audio_devices_t */
> #define AUDIO_PARAMETER_DEVICE_DISCONNECT "disconnect"      /* audio_devices_t */
Only in /home/yajat/Desktop/aosp12_r11/hardware/libhardware_legacy: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/nxp/nfc: .git
diff -r /home/yajat/Desktop/aosp12_r11/hardware/nxp/nfc/pn8x/halimpl/tml/phTmlNfc.cc /home/yajat/Desktop/H618-Android12-Src/hardware/nxp/nfc/pn8x/halimpl/tml/phTmlNfc.cc
156c156
<     phTmlNfc_CleanUp();
---
>     phTmlNfc_Shutdown_CleanUp();
Only in /home/yajat/Desktop/aosp12_r11/hardware/nxp/secure_element: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/audio: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/bootctrl: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/bt: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/camera: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/data/ipacfg-mgr: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/display: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/keymaster: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/media: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8960: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8994: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8996: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8x09: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8x26: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8x27: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/msm8x84: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/power: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/bt: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/data/ipacfg-mgr: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/display: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/media: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/thermal: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sdm845/vr: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm7150/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm7250/display: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm7250/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm7250/media: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/data/ipacfg-mgr: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/display: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/media: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/thermal: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150/vr: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/sm8150p/gps: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/qcom/wlan: .git
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: realtek
Only in /home/yajat/Desktop/aosp12_r11/hardware/ril: .git
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/include/telephony/ril.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/include/telephony/ril.h
21a22
> #include <stdbool.h>
55,58c56,59
<  * just document RIL version associated with that change below. When OEM updates its
<  * RIL with those changes, they would return that new RIL version during RIL_REGISTER.
<  * We should make use of the returned version by vendor to identify appropriate scheme
<  * or data structure version to use.
---
>  * just document RIL version associated with that change below. When OEM updates
>  * its RIL with those changes, they would return that new RIL version during
>  * RIL_REGISTER. We should make use of the returned version by vendor to
>  * identify appropriate scheme or data structure version to use.
61,62c62,63
<  * RIL_VERSION = 12 : This version corresponds to updated data structures namely
<  *                    RIL_Data_Call_Response_v11, RIL_SIM_IO_v6, RIL_CardStatus_v6,
---
>  * RIL_VERSION = 12 : Updated data structures: RIL_Data_Call_Response_v11,
>  *                    RIL_SIM_IO_v6, RIL_CardStatus_v6,
64,74c65,81
<  *                    RIL_LTE_SignalStrength_v8, RIL_SignalStrength_v10, RIL_CellIdentityGsm_v12
<  *                    RIL_CellIdentityWcdma_v12, RIL_CellIdentityLte_v12,RIL_CellInfoGsm_v12,
<  *                    RIL_CellInfoWcdma_v12, RIL_CellInfoLte_v12, RIL_CellInfo_v12.
<  *
<  * RIL_VERSION = 13 : This version includes new wakelock semantics and as the first
<  *                    strongly versioned version it enforces structure use.
<  *
<  * RIL_VERSION = 14 : New data structures are added, namely RIL_CarrierMatchType,
<  *                    RIL_Carrier, RIL_CarrierRestrictions and RIL_PCO_Data.
<  *                    New commands added: RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
<  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS and RIL_UNSOL_PCO_DATA.
---
>  *                    RIL_LTE_SignalStrength_v8, RIL_SignalStrength_v10,
>  *                    RIL_CellIdentityGsm_v12, RIL_CellIdentityWcdma_v12,
>  *                    RIL_CellIdentityLte_v12, RIL_CellInfoGsm_v12,
>  *                    RIL_CellInfoWcdma_v12, RIL_CellInfoLte_v12,
>  *                    RIL_CellInfo_v12
>  *
>  * RIL_VERSION = 13 : This version includes new wakelock semantics and as the
>  *                    first strongly versioned version it enforces structure
>  *                    use.
>  *
>  * RIL_VERSION = 14 : New commands added:
>  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
>  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
>  *                    RIL_UNSOL_PCO_DATA
>  *                    New data structures are added: RIL_CarrierMatchType,
>  *                    RIL_Carrier, RIL_CarrierRestrictions, RIL_PCO_Data
>  *
83,89d89
<  *                    The new parameters for RIL_REQUEST_SETUP_DATA_CALL,
<  *                    Updated data structures: RIL_DataProfileInfo_v15, RIL_InitialAttachApn_v15
<  *                    New data structure RIL_DataRegistrationStateResponse,
<  *                    RIL_VoiceRegistrationStateResponse same is
<  *                    used in RIL_REQUEST_DATA_REGISTRATION_STATE and
<  *                    RIL_REQUEST_VOICE_REGISTRATION_STATE respectively.
<  *                    New data structure RIL_OpenChannelParams.
92a93,125
>  *                    RIL_REQUEST_GET_MODEM_STACK_STATUS
>  *                    RIL_REQUEST_ENABLE_MODEM
>  *                    RIL_REQUEST_EMERGENCY_DIAL
>  *                    RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS
>  *                    RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA
>  *                    RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA
>  *                    RIL_REQUEST_ENABLE_UICC_APPLICATIONS
>  *                    RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED
>  *                    RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION
>  *                    RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE
>  *                    New parameters for RIL_REQUEST_SETUP_DATA_CALL
>  *                    Updated data structures: RIL_DataProfileInfo_v15,
>  *                    RIL_InitialAttachApn_v15, RIL_Data_Call_Response_v12
>  *                    New data structures: RIL_DataRegistrationStateResponse,
>  *                    RIL_OpenChannelParams,
>  *                    RIL_VoiceRegistrationStateResponse same is used in
>  *                    RIL_REQUEST_DATA_REGISTRATION_STATE and
>  *                    RIL_REQUEST_VOICE_REGISTRATION_STATE respectively.
>  * RIL_VERSION = 16 : New commands added:
>  *                    RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY
>  *                    RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED
>  *                    RIL_REQUEST_ALLOCATE_PDU_SESSION_ID
>  *                    RIL_REQUEST_RELEASE_PDU_SESSION_ID
>  *                    RIL_REQUEST_START_HANDOVER
>  *                    RIL_REQUEST_CANCEL_HANDOVER
>  *                    RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP
>  *                    RIL_REQUEST_SET_DATA_THROTTLING
>  *                    RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS
>  *                    RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP
>  *                    RIL_REQUEST_GET_SLICING_CONFIG
>  *                    New parameters for RIL_REQUEST_SETUP_DATA_CALL
>  *                    Updated data structures: RIL_CarrierInfoForImsiEncryption_v16
>  *                    New data structure: RIL_PublicKeyType
94c127
< #define RIL_VERSION 12
---
> #define RIL_VERSION 16
111a145
> #define RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE 8
265c299,300
<     RADIO_TECH_LTE_CA = 19
---
>     RADIO_TECH_LTE_CA = 19,
>     RADIO_TECH_NR = 20
287c322,323
<     RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA)
---
>     RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA),
>     RAF_NR = (1 << RADIO_TECH_NR)
552a589,628
> typedef struct {
>     int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
>     int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
>                                            back-off timer value RIL wants to override the one
>                                            pre-configured in FW.
>                                            The unit is milliseconds.
>                                            The value < 0 means no value is suggested.
>                                            The value 0 means retry should be done ASAP.
>                                            The value of INT_MAX(0x7fffffff) means no retry. */
>     int             cid;        /* Context ID, uniquely identifies this call */
>     int             active;     /* 0=inactive, 1=active/physical link down,
>                                    2=active/physical link up */
>     char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
>                                    For example, "IP", "IPV6", "IPV4V6", or "PPP". If status is
>                                    PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED this is the type supported
>                                    such as "IP" or "IPV6" */
>     char *          ifname;     /* The network interface name */
>     char *          addresses;  /* A space-delimited list of addresses with optional "/" prefix
>                                    length, e.g., "192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
>                                    May not be empty, typically 1 IPv4 or 1 IPv6 or
>                                    one of each. If the prefix length is absent the addresses
>                                    are assumed to be point to point with IPv4 having a prefix
>                                    length of 32 and IPv6 128. */
>     char *          dnses;      /* A space-delimited list of DNS server addresses,
>                                    e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
>                                    May be empty. */
>     char *          gateways;   /* A space-delimited list of default gateway addresses,
>                                    e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
>                                    May be empty in which case the addresses represent point
>                                    to point connections. */
>     char *          pcscf;      /* the Proxy Call State Control Function address
>                                    via PCO(Protocol Configuration Option) for IMS client. */
>     int             mtuV4;      /* MTU received from network for IPv4.
>                                    Value <= 0 means network has either not sent a value or
>                                    sent an invalid value. */
>     int             mtuV6;      /* MTU received from network for IPv6.
>                                    Value <= 0 means network has either not sent a value or
>                                    sent an invalid value. */
> } RIL_Data_Call_Response_v12;
> 
746,747c822,823
<   RIL_Carrier * allowed_carriers;       /* list of allowed carriers */
<   RIL_Carrier * excluded_carriers;      /* list of explicitly excluded carriers
---
>   RIL_Carrier * allowed_carriers;       /* allowed carriers */
>   RIL_Carrier * excluded_carriers;      /* excluded carriers
754a831,851
> typedef enum {
>     NO_MULTISIM_POLICY = 0,             /* configuration applies to each slot independently. */
>     ONE_VALID_SIM_MUST_BE_PRESENT = 1,  /* Any SIM card can be used as far as one valid card is
>                                          * present in the device.
>                                          */
> } RIL_SimLockMultiSimPolicy;
> 
> typedef struct {
>   int32_t len_allowed_carriers;         /* length of array allowed_carriers */
>   int32_t len_excluded_carriers;        /* length of array excluded_carriers */
>   RIL_Carrier * allowed_carriers;       /* allowed carriers */
>   RIL_Carrier * excluded_carriers;      /* explicitly excluded carriers
>                                          * which match allowed_carriers. Eg. allowed_carriers match
>                                          * mcc/mnc, excluded_carriers has same mcc/mnc and gid1
>                                          * is ABCD. It means except the carrier whose gid1 is ABCD,
>                                          * all carriers with the same mcc/mnc are allowed.
>                                          */
>   int allowedCarriersPrioritized;       /* allowed list prioritized */
>   RIL_SimLockMultiSimPolicy multiSimPolicy; /* multisim policy */
> } RIL_CarrierRestrictionsWithPriority;
> 
769a867,890
> /**
>  * Public key type from carrier certificate.
>  */
> typedef enum {
>     EPDG = 1, /* Key type to be used for ePDG */
>     WLAN = 2, /* Key type to be used for WLAN */
> } RIL_PublicKeyType;
> 
> typedef struct {
>     char* mcc;                 /* MCC of the Carrier. */
>     char* mnc;                 /* MNC of the Carrier. */
>     uint8_t* carrierKey;       /* Public Key from the Carrier used to encrypt the
>                                 * IMSI/IMPI.
>                                 */
>     int32_t carrierKeyLength;  /* Length of the Public Key. */
>     char* keyIdentifier;       /* The keyIdentifier Attribute value pair that helps
>                                 * a server locate the private key to decrypt the
>                                 * permanent identity.
>                                 */
>     int64_t expirationTime;    /* Date-Time (in UTC) when the key will expire. */
>     RIL_PublicKeyType keyType; /* Public key type */
> 
> } RIL_CarrierInfoForImsiEncryption_v16;
> 
892c1013
<     PDP_FAIL_OPERATOR_BARRED = 0x08,               /* no retry */
---
>     PDP_FAIL_OPERATOR_BARRED = 0x08, /* no retry */
896,899c1017,1020
<     PDP_FAIL_MISSING_UKNOWN_APN = 0x1B,            /* no retry */
<     PDP_FAIL_UNKNOWN_PDP_ADDRESS_TYPE = 0x1C,      /* no retry */
<     PDP_FAIL_USER_AUTHENTICATION = 0x1D,           /* no retry */
<     PDP_FAIL_ACTIVATION_REJECT_GGSN = 0x1E,        /* no retry */
---
>     PDP_FAIL_MISSING_UNKNOWN_APN = 0x1B,      /* no retry */
>     PDP_FAIL_UNKNOWN_PDP_ADDRESS_TYPE = 0x1C, /* no retry */
>     PDP_FAIL_USER_AUTHENTICATION = 0x1D,      /* no retry */
>     PDP_FAIL_ACTIVATION_REJECT_GGSN = 0x1E,   /* no retry */
904,906c1025,1027
<     PDP_FAIL_NSAPI_IN_USE = 0x23,                  /* no retry */
<     PDP_FAIL_REGULAR_DEACTIVATION = 0x24,          /* possibly restart radio,
<                                                       based on framework config */
---
>     PDP_FAIL_NSAPI_IN_USE = 0x23,         /* no retry */
>     PDP_FAIL_REGULAR_DEACTIVATION = 0x24, /* possibly restart radio,
>                                              based on framework config */
917,918c1038,1039
<     PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32,             /* no retry */
<     PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33,             /* no retry */
---
>     PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32, /* no retry */
>     PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33, /* no retry */
933c1054
<     PDP_FAIL_PROTOCOL_ERRORS = 0x6F,             /* no retry */
---
>     PDP_FAIL_PROTOCOL_ERRORS = 0x6F, /* no retry */
944a1066,1069
>     // TODO: add new fail causes from IRadio 1.4 types.hal
>     PDP_FAIL_SLICE_REJECTED = 0x8CC,
>     PDP_FAIL_MATCH_ALL_RULE_NOT_ALLOWED = 0x8CD,
>     ALL_MATCHING_RULES_FAILED = 0x8CE,
968c1093
<    /* reasons for data call drop - network/modem disconnect */
---
>     /* reasons for data call drop - network/modem disconnect */
970,976c1095,1101
<     PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4,/* preferred technology has changed, should retry
<                                              with parameters appropriate for new technology */
<     PDP_FAIL_RADIO_POWER_OFF = -5,        /* data call was disconnected because radio was resetting,
<                                              powered off - no retry */
<     PDP_FAIL_TETHERED_CALL_ACTIVE = -6,   /* data call was disconnected by modem because tethered
<                                              mode was up on same APN/data profile - no retry until
<                                              tethered call is off */
---
>     PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4, /* preferred technology has changed, should retry
>                                               with parameters appropriate for new technology */
>     PDP_FAIL_RADIO_POWER_OFF = -5,      /* data call was disconnected because radio was resetting,
>                                            powered off - no retry */
>     PDP_FAIL_TETHERED_CALL_ACTIVE = -6, /* data call was disconnected by modem because tethered
>                                            mode was up on same APN/data profile - no retry until
>                                            tethered call is off */
978,979c1103,1104
<     PDP_FAIL_ERROR_UNSPECIFIED = 0xffff,  /* retry silently. Will be deprecated soon as
<                                              new error codes are added making this unnecessary */
---
>     PDP_FAIL_ERROR_UNSPECIFIED = 0xffff, /* retry silently. Will be deprecated soon as
>                                             new error codes are added making this unnecessary */
1139a1265,1370
> typedef struct {
>     RIL_CardStatus_v6 base;
> 
>     uint32_t physicalSlotId;
>     /**
>      * An Answer To Reset (ATR) is a message output by a Smart Card conforming to ISO/IEC 7816
>      * standards, following electrical reset of the card's chip. The ATR conveys information about
>      * the communication parameters proposed by the card, and the card's nature and state.
>      *
>      * This data is applicable only when cardState is CardState:PRESENT.
>      */
>     char *atr;
>     /**
>      * Integrated Circuit Card IDentifier (ICCID) is Unique Identifier of the SIM CARD. File is
>      * located in the SIM card at EFiccid (0x2FE2) as per ETSI 102.221. The ICCID is defined by
>      * the ITU-T recommendation E.118 ISO/IEC 7816.
>      *
>      * This data is applicable only when cardState is CardState:PRESENT.
>      */
>     char *iccid;
> } RIL_CardStatus_v1_2;
> 
> typedef struct {
>     RIL_CardStatus_v1_2 base;
>     char *              eid;    /* The EID is the eUICC identifier. The EID shall be stored within the ECASD and can be
>                                  * retrieved by the Device at any time using the standard GlobalPlatform GET DATA command.
>                                  *
>                                  * This data is mandatory and applicable only when cardState is CardState:PRESENT and SIM card
>                                  * supports eUICC. */
> } RIL_CardStatus_v1_4;
> 
> typedef enum {
>     RIL_PERSOSUBSTATE_UNKNOWN_1_5                   = 0, /* initial state */
>     RIL_PERSOSUBSTATE_IN_PROGRESS_1_5               = 1, /* in between each lock transition */
>     RIL_PERSOSUBSTATE_READY_1_5                     = 2, /* when either SIM or RUIM Perso is finished
>                                                         since each app can only have 1 active perso
>                                                         involved */
>     RIL_PERSOSUBSTATE_SIM_NETWORK_1_5               = 3,
>     RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET_1_5        = 4,
>     RIL_PERSOSUBSTATE_SIM_CORPORATE_1_5             = 5,
>     RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER_1_5      = 6,
>     RIL_PERSOSUBSTATE_SIM_SIM_1_5                   = 7,
>     RIL_PERSOSUBSTATE_SIM_NETWORK_PUK_1_5           = 8, /* The corresponding perso lock is blocked */
>     RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET_PUK_1_5    = 9,
>     RIL_PERSOSUBSTATE_SIM_CORPORATE_PUK_1_5         = 10,
>     RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER_PUK_1_5  = 11,
>     RIL_PERSOSUBSTATE_SIM_SIM_PUK_1_5               = 12,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK1_1_5             = 13,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK2_1_5             = 14,
>     RIL_PERSOSUBSTATE_RUIM_HRPD_1_5                 = 15,
>     RIL_PERSOSUBSTATE_RUIM_CORPORATE_1_5            = 16,
>     RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_1_5     = 17,
>     RIL_PERSOSUBSTATE_RUIM_RUIM_1_5                 = 18,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK1_PUK_1_5         = 19, /* The corresponding perso lock is blocked */
>     RIL_PERSOSUBSTATE_RUIM_NETWORK2_PUK_1_5         = 20,
>     RIL_PERSOSUBSTATE_RUIM_HRPD_PUK_1_5             = 21,
>     RIL_PERSOSUBSTATE_RUIM_CORPORATE_PUK_1_5        = 22,
>     RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_PUK_1_5 = 23,
>     RIL_PERSOSUBSTATE_RUIM_RUIM_PUK_1_5             = 24,
>     /**
>      * The device is personalized using the content of the Service Provider Name (SPN) in the SIM
>      * card.
>      */
>     RIL_PERSOSUBSTATE_SIM_SPN,
>     RIL_PERSOSUBSTATE_SIM_SPN_PUK,
>     /**
>      * Service Provider and Equivalent Home PLMN
>      * The device is personalized using both the content of the GID1 (equivalent to service provider
>      * personalization) and the content of the Equivalent Home PLMN (EHPLMN) in the SIM card.
>      * If the GID1 in the SIM is absent, then just the content of the Equivalent Home PLMN
>      * is matched.
>      */
>     RIL_PERSOSUBSTATE_SIM_SP_EHPLMN,
>     RIL_PERSOSUBSTATE_SIM_SP_EHPLMN_PUK,
>     /**
>      * Device is personalized using the first digits of the ICCID of the SIM card.
>      */
>     RIL_PERSOSUBSTATE_SIM_ICCID,
>     RIL_PERSOSUBSTATE_SIM_ICCID_PUK,
>     /**
>      * Device is personalized using the content of the IMPI in the ISIM.
>      */
>     RIL_PERSOSUBSTATE_SIM_IMPI,
>     RIL_PERSOSUBSTATE_SIM_IMPI_PUK,
>     /**
>       * Network Subset and Service Provider
>      * Device is personalized using both the content of GID1 (equivalent to service provider
>      * personalization) and the first digits of the IMSI (equivalent to network subset
>      * personalization).
>      */
>     RIL_PERSOSUBSTATE_SIM_NS_SP,
>     RIL_PERSOSUBSTATE_SIM_NS_SP_PUK,
> } RIL_PersoSubstateV1_5;
> 
> typedef struct {
>     RIL_AppStatus base;
>     RIL_PersoSubstateV1_5 persoSubstate;
> } RIL_AppStatusV1_5;
> 
> typedef struct {
>     RIL_CardStatus_v1_4 base;
> 
>     /** size <= RadioConst::CARD_MAX_APPS */
>     RIL_AppStatusV1_5 applications[RIL_CARD_MAX_APPS];
> } RIL_CardStatus_v1_5;  // 1.5
> 
1267d1497
< 
1332a1563,1583
> typedef struct {
>   int32_t ssRsrp;   /* SS reference signal received power, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [44, 140], INT_MAX means invalid/unreported. */
>   int32_t ssRsrq;   /* SS reference signal received quality, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [3, 20], INT_MAX means invalid/unreported. */
>   int32_t ssSinr;   /* SS signal-to-noise and interference ratio.
>                      * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>                      * Range [-23, 40], INT_MAX means invalid/unreported. */
>   int32_t csiRsrp;  /* CSI reference signal received power, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [44, 140], INT_MAX means invalid/unreported. */
>   int32_t csiRsrq;  /* CSI reference signal received quality, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [3, 20], INT_MAX means invalid/unreported. */
>   int32_t csiSinr;  /* CSI signal-to-noise and interference ratio.
>                      * Reference: 3GPP TS 138.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>                      * Range [-23, 40], INT_MAX means invalid/unreported. */
> } RIL_NR_SignalStrength;
> 
1362a1614,1719
>     RIL_GW_SignalStrength       GW_SignalStrength;
>     RIL_CDMA_SignalStrength     CDMA_SignalStrength;
>     RIL_EVDO_SignalStrength     EVDO_SignalStrength;
>     RIL_LTE_SignalStrength_v8   LTE_SignalStrength;
>     RIL_TD_SCDMA_SignalStrength TD_SCDMA_SignalStrength;
>     RIL_SignalStrengthWcdma     WCDMA_SignalStrength;
>     RIL_NR_SignalStrength       NR_SignalStrength;
> } RIL_SignalStrength_v12;
> 
> /**
>  * Defining signal strength type.
>  */
> typedef enum {
>     /**
>      * Received Signal Strength Indication.
>      * Range: -113 dBm and -51 dBm
>      * Used RAN: GERAN, CDMA2000
>      * Reference: 3GPP TS 27.007 section 8.5.
>      */
>     RSSI = 1,
>     /**
>      * Received Signal Code Power.
>      * Range: -120 dBm to -25 dBm;
>      * Used RAN: UTRAN
>      * Reference: 3GPP TS 25.123, section 9.1.1.1
>      */
>     RSCP = 2,
>     /**
>      * Reference Signal Received Power.
>      * Range: -140 dBm to -44 dBm;
>      * Used RAN: EUTRAN
>      * Reference: 3GPP TS 36.133 9.1.4
>      */
>     RSRP = 3,
>     /**
>      * Reference Signal Received Quality
>      * Range: -34 dB to 3 dB;
>      * Used RAN: EUTRAN
>      * Reference: 3GPP TS 36.133 v12.6.0 section 9.1.7
>      */
>     RSRQ = 4,
>     /**
>      * Reference Signal Signal to Noise Ratio
>      * Range: -20 dB to 30 dB;
>      * Used RAN: EUTRAN
>      * Note: this field is optional; how to support it can be decided by the
>      * corresponding vendor. Though the response code is not enforced,
>      * vendor's implementation must ensure this interface not crashing.
>      */
>     RSSNR = 5,
>     /**
>      * 5G SS reference signal received power.
>      * Range: -140 dBm to -44 dBm.
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215.
>      */
>     SSRSRP = 6,
>     /**
>      * 5G SS reference signal received quality.
>      * Range: -20 dB to -3 dB.
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215.
>      */
>     SSRSRQ = 7,
>     /**
>      * 5G SS signal-to-noise and interference ratio.
>      * Range: -23 dB to 40 dB
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>      */
>     SSSINR = 8,
> } SignalMeasurementType;
> 
> typedef enum {
>     RADIO_ACCESS_UNKNOWN = 0, /* Unknown access network */
>     RADIO_ACCESS_NET_GERAN = 1, /* GSM EDGE Radio Access Network */
>     RADIO_ACCESS_NET_UTRAN = 2, /* Universal Terrestrial Radio Access Network */
>     RADIO_ACCESS_NET_EUTRAN = 3, /* Evolved Universal Terrestrial Radio Access Network */
>     RADIO_ACCESS_NET_CDMA2000 = 4, /* CDMA 2000 network */
>     RADIO_ACCESS_NET_IWLAN = 5, /* Interworking Wireless LAN */
>     RADIO_ACCESS_NET_NGRAN = 6, /* Next-Generation Radio Access Network */
> /* the following definitions are extended in radio/1.4 */
> } RIL_RadioAccessNetworks_v1_5;
> 
> typedef struct {
>     int32_t hysteresisMs;
>     int32_t hysteresisDb;
>     int32_t thresholdsDbmNumber;
>     int32_t *thresholdsDbm;
>     bool isEnabled;
>     SignalMeasurementType signalMeasurement;
>     RIL_RadioAccessNetworks_v1_5 accessNetwork;
> } RIL_SignalStrengthReportingCriteria_v1_5;
> 
> typedef struct {
>     int32_t hysteresisMs;
>     int32_t hysteresisDlKbps;
>     int32_t hysteresisUlKbps;
>     int32_t thresholdsDownlinkKbpsLength;
>     int32_t *thresholdsDownlinkKbps;
>     int32_t thresholdsUplinkKbpsLength;
>     int32_t *thresholdsUplinkKbps;
>     RIL_RadioAccessNetworks_v1_5 accessNetwork;
> } RIL_LinkCapacityReportingCriteria;
> 
> typedef struct {
1448a1806,1827
> typedef struct  {
>     char alphaLong[32];   /* Long alpha Operator Name String or Enhanced Operator Name String.*/
>     char alphaShort[32];  /* Short alpha Operator Name String or Enhanced Operator Name String */
> } RIL_CellIdentityOperatorNames;
> 
> typedef struct {
>     int mcc;           /* 3-digit Mobile Country Code, in range[0, 999]; This value must
>                         * be valid for registered or camped cells; INT_MAX means invalid/unreported. */
>     int mnc;           /* 2 or 3-digit Mobile Network Code, in range [0, 999], This value must be valid for
>                         * registered or camped cells; INT_MAX means invalid/unreported. */
>     uint64_t nci;      /* NR Cell Identity in range [0, 68719476735] (36 bits) described in 3GPP TS 38.331, which
>                         * unambiguously identifies a cell within a PLMN. This value must be valid for registered or
>                         * camped cells; LONG_MAX (2^63-1) means invalid/unreported.*/
>     uint32_t pci;      /* Physical cell id in range [0, 1007] described in 3GPP TS 38.331. This value must be valid. */
>     int32_t tac;       /* 16-bit tracking area code, INT_MAX means invalid/unreported. */
>     int32_t nrarfcn;   /* NR Absolute Radio Frequency Channel Number, in range [0, 3279165].
>                         * Reference: 3GPP TS 38.101-1 and 3GPP TS 38.101-2 section 5.4.2.1.
>                         * This value must be valid. */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityNr;
> 
1486c1865
<   RIL_CellIdentityTdscdma cellIdentityTdscdma;
---
>   RIL_CellIdentityTdscdma     cellIdentityTdscdma;
1489a1869,1873
> typedef struct {
>   RIL_CellIdentityNr          cellidentity;
>   RIL_NR_SignalStrength       signalStrength;
> } RIL_CellInfoNr;
> 
1497c1881,1882
<   RIL_CELL_INFO_TYPE_TD_SCDMA  = 5
---
>   RIL_CELL_INFO_TYPE_TD_SCDMA  = 5,
>   RIL_CELL_INFO_TYPE_NR        = 6
1508a1894,1900
> typedef enum {
>     CELL_CONNECTION_NONE = 0,           // Cell is not a serving cell.
>     CELL_CONNECTION_PRIMARY_SERVING,    // UE has connection to cell for signalling and
>                                         // possibly data (3GPP 36.331, 25.331).
>     CELL_CONNECTION_SECONDARY_SERVING,  // UE has connection to cell for data (3GPP 36.331, 25.331).
> } RIL_CellConnectionStatus;
> 
1537a1930,1943
>   RIL_CellInfoType          cellInfoType;   /* cell type for selecting from union CellInfo */
>   int                       registered;     /* !0 if this cell is registered 0 if not registered */
>   RIL_CellConnectionStatus  connectionStatus;  /* Connection status for the cell. */
>   union {
>     RIL_CellInfoGsm_v12     gsm;
>     RIL_CellInfoCdma        cdma;
>     RIL_CellInfoLte_v12     lte;
>     RIL_CellInfoWcdma_v12   wcdma;
>     RIL_CellInfoTdscdma     tdscdma;
>     RIL_CellInfoNr          nr;
>   } CellInfo;
> } RIL_CellInfo_v16;
> 
> typedef struct {
1548a1955,2049
>   RIL_CellInfoType  cellInfoType;   /* cell type for selecting from union CellInfo */
>   union {
>     RIL_CellIdentityGsm_v12 cellIdentityGsm;
>     RIL_CellIdentityWcdma_v12 cellIdentityWcdma;
>     RIL_CellIdentityLte_v12 cellIdentityLte;
>     RIL_CellIdentityTdscdma cellIdentityTdscdma;
>     RIL_CellIdentityCdma cellIdentityCdma;
>     RIL_CellIdentityNr cellIdentityNr;
>   };
> } RIL_CellIdentity_v20;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 16-bit GSM Cell Identity described in TS 27.007, 0..65535, INT_MAX if unknown  */
>     int arfcn;  /* 16-bit GSM Absolute RF channel number, INT_MAX if unknown */
>     uint8_t bsic;/* 6-bit Base Station Identity Code, 0xFF if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityGsm_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
>     int psc;    /* 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511, INT_MAX if unknown */
>     int uarfcn; /* 16-bit UMTS Absolute RF Channel Number, INT_MAX if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityWcdma_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int ci;     /* 28-bit Cell Identity described in TS ???, INT_MAX if unknown */
>     int pci;    /* physical cell id 0..503; this value must be reported */
>     int tac;    /* 16-bit tracking area code, INT_MAX if unknown  */
>     int earfcn; /* 18-bit LTE Absolute RF Channel Number; this value must be reported */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
>     int32_t bandwidth;  /* Cell bandwidth, in kHz. */
> } RIL_CellIdentityLte_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
>     int cpid;    /* 8-bit Cell Parameters ID described in TS 25.331, 0..127, INT_MAX if unknown */
> 
>     int32_t uarfcn;  /* 16-bit UMTS Absolute RF Channel Number defined in TS 25.102 5.4.4; this value must be valid. */
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityTdscdma_v1_2;
> 
> typedef struct {
>     int networkId;      /* Network Id 0..65535, INT_MAX if unknown */
>     int systemId;       /* CDMA System Id 0..32767, INT_MAX if unknown  */
>     int basestationId;  /* Base Station Id 0..65535, INT_MAX if unknown  */
>     int longitude;      /* Longitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
>                          * It is represented in units of 0.25 seconds and ranges from -2592000
>                          * to 2592000, both values inclusive (corresponding to a range of -180
>                          * to +180 degrees). INT_MAX if unknown */
> 
>     int latitude;       /* Latitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
>                          * It is represented in units of 0.25 seconds and ranges from -1296000
>                          * to 1296000, both values inclusive (corresponding to a range of -90
>                          * to +90 degrees). INT_MAX if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityCdma_v1_2;
> 
> typedef struct {
>     /**
>      * Cell type for selecting from union CellInfo.
>      * Only one of the below vectors must be of size 1 based on a
>      * valid CellInfoType and others must be of size 0.
>      * If cell info type is NONE, then all the vectors must be of size 0.
>      */
>     RIL_CellInfoType cellInfoType;
>     union {
>       RIL_CellIdentityGsm_v1_2 cellIdentityGsm;
>       RIL_CellIdentityWcdma_v1_2 cellIdentityWcdma;
>       RIL_CellIdentityLte_v1_2 cellIdentityLte;
>       RIL_CellIdentityTdscdma_v1_2 cellIdentityTdscdma;
>       RIL_CellIdentityCdma_v1_2 cellIdentityCdma;
>     };
> } RIL_CellIdentity_v1_2;
> 
> typedef struct {
1608d2108
< 
2016a2517,2518
>     RIL_APN_TYPE_MCX          = 0x400,        // APN type for Mission Critical Service
>     RIL_APN_TYPE_XCAP         = 0x800,        // APN type for XCAP
2074,2076c2576,2581
<     GERAN = 0x01,   // GSM EDGE Radio Access Network
<     UTRAN = 0x02,   // Universal Terrestrial Radio Access Network
<     EUTRAN = 0x03,  // Evolved Universal Terrestrial Radio Access Network
---
>     UNKNOWN = 0x00,     // Unknown Radio Access Network
>     GERAN = 0x01,       // GSM EDGE Radio Access Network
>     UTRAN = 0x02,       // Universal Terrestrial Radio Access Network
>     EUTRAN = 0x03,      // Evolved Universal Terrestrial Radio Access Network
>     NGRAN = 0x04,       // Next-Generation Radio Access Network
>     CDMA2000 = 0x05,    // CDMA 2000 Radio AccessNetwork
2078a2584,2588
> typedef struct {
>   char *operatorNumeric;
>   RIL_RadioAccessNetworks act;
> } RIL_NetworkOperator;
> 
2169a2680,2718
> typedef enum {
>     NGRAN_BAND_1 = 1,
>     NGRAN_BAND_2 = 2,
>     NGRAN_BAND_3 = 3,
>     NGRAN_BAND_5 = 5,
>     NGRAN_BAND_7 = 7,
>     NGRAN_BAND_8 = 8,
>     NGRAN_BAND_12 = 12,
>     NGRAN_BAND_20 = 20,
>     NGRAN_BAND_25 = 25,
>     NGRAN_BAND_28 = 28,
>     NGRAN_BAND_34 = 34,
>     NGRAN_BAND_38 = 38,
>     NGRAN_BAND_39 = 39,
>     NGRAN_BAND_40 = 40,
>     NGRAN_BAND_41 = 41,
>     NGRAN_BAND_50 = 50,
>     NGRAN_BAND_51 = 51,
>     NGRAN_BAND_66 = 66,
>     NGRAN_BAND_70 = 70,
>     NGRAN_BAND_71 = 71,
>     NGRAN_BAND_74 = 74,
>     NGRAN_BAND_75 = 75,
>     NGRAN_BAND_76 = 76,
>     NGRAN_BAND_77 = 77,
>     NGRAN_BAND_78 = 78,
>     NGRAN_BAND_79 = 79,
>     NGRAN_BAND_80 = 80,
>     NGRAN_BAND_81 = 81,
>     NGRAN_BAND_82 = 82,
>     NGRAN_BAND_83 = 83,
>     NGRAN_BAND_84 = 84,
>     NGRAN_BAND_86 = 86,
>     NGRAN_BAND_257 = 257,
>     NGRAN_BAND_258 = 258,
>     NGRAN_BAND_260 = 260,
>     NGRAN_BAND_261 = 261,
> } RIL_NgranBands;
> 
2176a2726
>         RIL_NgranBands ngran_bands[MAX_BANDS];
2191a2742,2780
> typedef struct {
>     RIL_RadioAccessNetworks_v1_5 radio_access_network; // The type of network to scan.
>     uint32_t bands_length; // Length of bands
>     union {
>         RIL_GeranBands geran_bands[MAX_BANDS];
>         RIL_UtranBands utran_bands[MAX_BANDS];
>         RIL_EutranBands eutran_bands[MAX_BANDS];
>         RIL_NgranBands ngran_bands[MAX_BANDS];
>     } bands;
>     uint32_t channels_length; // Length of channels
>     uint32_t channels[MAX_CHANNELS]; // Frequency channels to scan
> } RIL_RadioAccessSpecifier_v1_5;
> 
> typedef struct {
>     RIL_ScanType type;
> 
>     int32_t interval;
> 
>     uint32_t specifiers_length;  // Length of specifiers
> 
>     RIL_RadioAccessSpecifier_v1_5 specifiers[RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE];
> 
>     int32_t maxSearchTime;
> 
>     int32_t incrementalResults;
> 
>     int32_t incrementalResultsPeriodicity;
> 
>     uint32_t mccMncsNumbers;
> 
>     char **mccMncs;
> } RIL_NetworkScanRequest_v1_5;
> 
> typedef struct {
>     int                              specifyChannels;
>     uint32_t                         specifiers_length;  // Length of specifiers
>     RIL_RadioAccessSpecifier_v1_5    specifiers[RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE];  // Radio access networks with bands/channels.
> } RIL_SystemSelectionChannels_v1_5;
> 
2203a2793,2968
> 
> 
> /*********************Structs and Enums Extended in 1.4************************/
> /**
>  * Defining Emergency Service Category as follows:
>  * - General emergency call, all categories;
>  * - Police;
>  * - Ambulance;
>  * - Fire Brigade;
>  * - Marine Guard;
>  * - Mountain Rescue;
>  * - Manually Initiated eCall (MIeC);
>  * - Automatically Initiated eCall (AIeC);
>  *
>  * Category UNSPECIFIED (General emergency call, all categories) indicates that no specific
>  * services are associated with this emergency number.
>  *
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls
>  */
> typedef enum {
>     CATEGORY_UNSPECIFIED     = 0,        /* General emergency call, all categories */
>     CATEGORY_POLICE          = 1 << 0,
>     CATEGORY_AMBULANCE       = 1 << 1,
>     CATEGORY_FIRE_BRIGADE    = 1 << 2,
>     CATEGORY_MARINE_GUARD    = 1 << 3,
>     CATEGORY_MOUNTAIN_RESCUE = 1 << 4,
>     CATEGORY_MIEC            = 1 << 5,  /* Manually Initiated eCall (MIeC) */
>     CATEGORY_AIEC            = 1 << 6,  /* Automatically Initiated eCall (AIeC) */
> } RIL_EmergencyServiceCategory;
> 
> /**
>  * The source to tell where the corresponding @1.4::EmergencyNumber comes from.
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls
>  */
> typedef enum {
>     SOURCE_NETWORK_SIGNALING   = 1 << 0,   /* Indicates the number is from the network signal. */
>     SOURCE_SIM                 = 1 << 1,   /* Indicates the number is from the sim card. */
>     SOURCE_MODEM_CONFIG        = 1 << 2,   /* Indicates the number is from the modem config. */
>     SOURCE_DEFAULT             = 1 << 3,   /* Indicates the number is available as default.
>                                             * Per the reference, 112, 911 must always be available;
>                                             * additionally, 000, 08, 110, 999, 118 and 119 must be available
>                                             * when sim is not present. */
> } RIL_EmergencyNumberSource;
> 
> /**
>  * Indicates how the implementation should handle the emergency call if it is required by Android.
>  */
> typedef enum {
>     ROUTING_UNKNOWN    = 0,  /* Indicates Android does not require how to handle
>                                    * the corresponding emergency call; it is decided by implementation. */
>     ROUTING_MERGENCY   = 1,  /* Indicates the implementation must handle the call through emergency routing. */
>     ROUTING_NORMAL     = 2,  /* Indicates the implementation must handle the call through normal call routing. */
> } RIL_EmergencyCallRouting;
> 
> /**
>  * Emergency number contains information of number, one or more service category(s), zero or more
>  * emergency uniform resource names, mobile country code (mcc), mobile network country (mnc) and
>  * source(s) that indicate where it comes from.
>  *
>  * If the emergency number is associated with country, field ‘mcc’ must be provided, otherwise
>  * field ‘mcc’ must be an empty string. If the emergency number is associated with network
>  * operator, field ‘mcc’ and 'mnc' must be provided, otherwise field ‘mnc’ must be an empty
>  * string. If the emergency number is specified with emergency service category(s), field
>  * 'categories' must be provided, otherwise field 'categories' must be
>  * @1.4::EmergencyServiceCategories::UNSPECIFIED. If the emergency number is specified with
>  * emergency uniform resource names (URN), field 'urns' must be provided, otherwise field 'urns'
>  * must be an empty list.
>  *
>  * A unique EmergencyNumber has a unique combination of ‘number’, ‘mcc’, 'mnc', 'categories' and
>  * 'urns' fields. Multiple @1.4::EmergencyNumberSource should be merged into one 'sources' field
>  * via bitwise-OR combination for the same EmergencyNumber.
>  *
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls;
>  *            3gpp 23.167, Section 6 - Functional description;
>  *            3gpp 24.503, Section 5.1.6.8.1 - General;
>  *            RFC 5031
>  */
> typedef struct {
>     RIL_Dial                     dialInfo;
>     RIL_EmergencyServiceCategory categories; /* The bitfield of @1.4::EmergencyServiceCategory(s).
>                                               * See RIL_EmergencyServiceCategory for the value of each bit. */
>     uint32_t                     urnsNumber;
>     char **                      urns;       /* The list of emergency Uniform Resource Names (URN). */
>     RIL_EmergencyNumberSource    sources;    /* The bitfield of @1.4::EmergencyNumberSource(s).
>                                               * See RIL_EmergencyNumberSource for the value of each bit. */
>     RIL_EmergencyCallRouting     routing;
>     bool                         fromEmergencyDialer;
> } RIL_EmergencyDial;
> 
> /******************************************************************************/
> /* Radio Config structure @{ */
> typedef enum {
>     /* Physical slot is inactive*/
>     SLOT_STATE_INACTIVE  = 0x00,
>     /* Physical slot is active */
>     SLOT_STATE_ACTIVE    = 0x01,
> } RIL_SlotState;
> 
> typedef struct {
>     /* Card state in the physical slot*/
>     RIL_CardState cardState;
>     /* Slot state Active/Inactive */
>     RIL_SlotState slotState;
>     /**
>       * An Answer To Reset (ATR) is a message output by a Smart Card conforming to ISO/IEC 7816
>       * standards, following electrical reset of the card's chip. The ATR conveys information about
>       * the communication parameters proposed by the card, and the card's nature and state.
>       * This data is applicable only when cardState is CardState:PRESENT.
>       */
>     char* atr;
>     int logicalSlotId;
>     /**
>       * Integrated Circuit Card IDentifier (ICCID) is Unique Identifier of the SIM CARD. File is
>       * located in the SIM card at EFiccid (0x2FE2) as per ETSI 102.221. The ICCID is defined by
>       * the ITU-T recommendation E.118 ISO/IEC 7816.
>       * This data is applicable only when cardState is CardState:PRESENT.
>       */
>     char* iccid;
> } RIL_SimSlotStatus;
> 
> typedef struct {
>     RIL_SimSlotStatus base;
>     /**
>       * The EID is the eUICC identifier. The EID shall be stored within the ECASD and can be
>       * retrieved by the Device at any time using the standard GlobalPlatform GET DATA command.
>       *
>       * This data is mandatory and applicable only when cardState is CardState:PRESENT and SIM card
>       * supports eUICC.
>       */
>     char* eid;
> } RIL_SimSlotStatus_V1_2;
> 
> #define MAX_LOGICAL_MODEM_NUM 4
> 
> typedef struct {
>     /* Logical modem ID. */
>     int modemId;
> } RIL_ModemInfo;
> 
> typedef struct {
>     /**
>      * maxActiveData defines how many logical modems can have
>      * PS attached simultaneously. For example, for L+L modem it
>      * should be 2.
>      */
>     int maxActiveData;
>     /**
>      * maxActiveData defines how many logical modems can have
>      * internet PDN connections simultaneously. For example, for L+L
>      * DSDS modem it’s 1, and for DSDA modem it’s 2.
>      */
>     int maxActiveInternetData;
>     /**
>      * Whether modem supports both internet PDN up so
>      * that we can do ping test before tearing down the
>      * other one.
>      */
>     int isInternetLingeringSupported;
>     /**
>      * List of logical modem information.
>      */
>     RIL_ModemInfo logicalModemList[MAX_LOGICAL_MODEM_NUM];
> } RIL_PhoneCapability;
> 
> typedef struct {
>     int numOfLiveModems;
> } RIL_ModemConfig;
> /* }@ */
> 
> typedef enum {
>     DATA_REQ_REASOPN_NORMAL    = 0x01,  // The reason of the data request is normal
>     DATA_REQ_REASOPN_SHUTDOWN  = 0x02,  // The reason of the data request is device shutdown
>     DATA_REQ_REASOPN_HANDOVER  = 0x03,  // The reason of the data request is IWLAN data handover
>                                         // to another transport (e.g. from cellular to wifi or vise versa)
> } RIL_DataRequestReason;
> 
6341a7107,7657
> /**
>  * RIL_REQUEST_GET_MODEM_STACK_STATUS
>  *
>  * Request status of a logical modem
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  MODEM_ERR
>  *
>  */
> #define RIL_REQUEST_GET_MODEM_STACK_STATUS 146
> 
> /**
>  * @param info Response info struct containing response type, serial no. and error
>  * @param networkTypeBitmap a 32-bit bitmap of RadioAccessFamily.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:INTERNAL_ERR
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:MODEM_ERR
>  *   RadioError:REQUEST_NOT_SUPPORTED
>  *   RadioError:NO_RESOURCES
>  */
> #define RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP 147
> 
> /**
>  * Callback of IRadio.setPreferredNetworkTypeBitmap(int, bitfield<RadioAccessFamily>)
>  *
>  * @param info Response info struct containing response type, serial no. and error
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:OPERATION_NOT_ALLOWED
>  *   RadioError:MODE_NOT_SUPPORTED
>  *   RadioError:INTERNAL_ERR
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:MODEM_ERR
>  *   RadioError:REQUEST_NOT_SUPPORTED
>  *   RadioError:NO_RESOURCES
>  */
> #define RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP 148
> 
> /**
>  * RIL_REQUEST_EMERGENCY_DIAL
>  *
>  * Initiate emergency voice call, with zero or more emergency service category(s), zero or
>  * more emergency Uniform Resource Names (URN), and routing information for handling the call.
>  * Android uses this request to make its emergency call instead of using @1.0::IRadio.dial
>  * if the 'address' in the 'dialInfo' field is identified as an emergency number by Android.
>  *
>  * In multi-sim scenario, if the emergency number is from a specific subscription, this radio
>  * request is sent through the IRadio service that serves the subscription, no matter of the
>  * PUK/PIN state of the subscription and the service state of the radio.
>  *
>  * Some countries or carriers require some emergency numbers that must be handled with normal
>  * call routing or emergency routing. If the 'routing' field is specified as
>  * @1.4::EmergencyNumberRouting#NORMAL, the implementation must use normal call routing to
>  * handle the call; if it is specified as @1.4::EmergencyNumberRouting#EMERGENCY, the
>  * implementation must use emergency routing to handle the call; if it is
>  * @1.4::EmergencyNumberRouting#UNKNOWN, Android does not know how to handle the call.
>  *
>  * If the dialed emergency number does not have a specified emergency service category, the
>  * 'categories' field is set to @1.4::EmergencyServiceCategory#UNSPECIFIED; if the dialed
>  * emergency number does not have specified emergency Uniform Resource Names, the 'urns' field
>  * is set to an empty list. If the underlying technology used to request emergency services
>  * does not support the emergency service category or emergency uniform resource names, the
>  * field 'categories' or 'urns' may be ignored.
>  *
>  * 'fromEmergencyDialer' indicates if this request originated from emergency dialer/shortcut,
>  * which means an explicit intent from the user to dial an emergency number. The modem must
>  * treat this as an actual emergency dial and not try to disambiguate.
>  *
>  * If 'isTesting' is true, this request is for testing purpose, and must not be sent to a real
>  * emergency service; otherwise it's for a real emergency call request.
>  * Valid errors:
>  *  NONE
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  DIAL_MODIFIED_TO_USSD
>  *  DIAL_MODIFIED_TO_SS
>  *  DIAL_MODIFIED_TO_DIAL
>  *  INVALID_ARGUMENTS
>  *  NO_RESOURCES
>  *  INTERNAL_ERR
>  *  FDN_CHECK_FAILURE
>  *  MODEM_ERR
>  *  NO_SUBSCRIPTION
>  *  NO_NETWORK_FOUND
>  *  INVALID_CALL_ID
>  *  DEVICE_IN_USE
>  *  ABORTED
>  *  INVALID_MODEM_STATE
>  */
> #define RIL_REQUEST_EMERGENCY_DIAL 149
> 
> /**
>  * Specify which bands modem's background scan must act on.
>  * If specifyChannels is true, it only scans bands specified in specifiers.
>  * If specifyChannels is false, it scans all bands.
>  *
>  * For example, CBRS is only on LTE band 48. By specifying this band,
>  * modem saves more power.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  INTERNAL_ERR
>  *
>  */
> #define RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS 150
> 
> /**
>  * RIL_REQUEST_ENABLE_MODEM
>  *
>  * Enable a logical modem
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  MODEM_ERR
>  *
>  */
> #define RIL_REQUEST_ENABLE_MODEM 151
> 
> /**
>  * RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA
>  *
>  * Sets the signal strength reporting criteria.
>  *
>  * The resulting reporting rules are the AND of all the supplied criteria. For each RAN
>  * The hysteresisDb apply to only the following measured quantities:
>  * -GERAN    - RSSI
>  * -CDMA2000 - RSSI
>  * -UTRAN    - RSCP
>  * -EUTRAN   - RSRP/RSRQ/RSSNR
>  *
>  * The thresholds apply to only the following measured quantities:
>  * -GERAN    - RSSI
>  * -CDMA2000 - RSSI
>  * -UTRAN    - RSCP
>  * -EUTRAN   - RSRP/RSRQ/RSSNR
>  * -NGRAN    - SSRSRP/SSRSRQ/SSSINR
>  *
>  * Note: Reporting criteria must be individually set for each RAN. For any unset reporting
>  * criteria, the value is implementation-defined.
>  *
>  * Note: @1.5::SignalThresholdInfo includes fields 'hysteresisDb', 'hysteresisMs',
>  * and 'thresholds'. As this mechanism generally only constrains reports based on one
>  * measured quantity per RAN, if multiple measured quantities must be used to trigger a report
>  * for a given RAN, the only valid field may be hysteresisMs: hysteresisDb and thresholds must
>  * be set to zero and length zero respectively. If either hysteresisDb or thresholds is set,
>  * then reports shall only be triggered by the respective measured quantity, subject to the
>  * applied constraints.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:RADIO_NOT_AVAILABLE
>  */
> #define RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA 152
> 
> /**
>  * RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA
>  *
>  * Sets the link capacity reporting criteria. The resulting reporting criteria are the AND of
>  * all the supplied criteria.
>  *
>  * Note: Reporting criteria ust be individually set for each RAN. If unset, reporting criteria
>  * for that RAN are implementation-defined.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:INTERNAL_ERR
>  */
> #define RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA 153
> 
> /**
>  * RIL_REQUEST_ENABLE_UICC_APPLICATIONS
>  *
>  * Enable or disable uicc applications.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  *  REQUEST_NOT_SUPPORTED
>  */
> #define RIL_REQUEST_ENABLE_UICC_APPLICATIONS 154
> 
> /**
>  * RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED
>  *
>  * Whether uicc applications are enabled.
>  *
>  * Response: a boolean of enable or not.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  *  REQUEST_NOT_SUPPORTED
>  */
> #define RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED 155
> 
> /**
>  * RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION
>  *
>  * Requests that sim personlization be deactivated
>  *
>  * "data" is const char **
>  * ((const char **)(data))[0]] is  sim depersonlization code
>  *
>  * "response" is int *
>  * ((int *)response)[0] is the number of retries remaining,
>  * or -1 if number of retries are infinite.
>  *
>  * Valid errors:
>  *
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  PASSWORD_INCORRECT
>  *  SIM_ABSENT (code is invalid)
>  *  INTERNAL_ERR
>  *  NO_MEMORY
>  *  NO_RESOURCES
>  *  CANCELLED
>  *  REQUEST_NOT_SUPPORTED
>  */
> 
> #define RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION 156
> 
> /**
>  * RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE
>  *
>  * Send a CDMA SMS message
>  *
>  * "data" is const RIL_CDMA_SMS_Message *
>  *
>  * "response" is a const RIL_SMS_Response *
>  *
>  * Based on the return error, caller decides to resend if sending sms
>  * fails. The CDMA error class is derived as follows,
>  * SUCCESS is error class 0 (no error)
>  * SMS_SEND_FAIL_RETRY is error class 2 (temporary failure)
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SMS_SEND_FAIL_RETRY
>  *  NETWORK_REJECT
>  *  INVALID_STATE
>  *  INVALID_ARGUMENTS
>  *  NO_MEMORY
>  *  REQUEST_RATE_LIMITED
>  *  INVALID_SMS_FORMAT
>  *  SYSTEM_ERR
>  *  FDN_CHECK_FAILURE
>  *  MODEM_ERR
>  *  NETWORK_ERR
>  *  ENCODING_ERR
>  *  INVALID_SMSC_ADDRESS
>  *  OPERATION_NOT_ALLOWED
>  *  NO_RESOURCES
>  *  CANCELLED
>  *  REQUEST_NOT_SUPPORTED
>  *  MODE_NOT_SUPPORTED
>  *  SIM_ABSENT
>  */
> #define RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE 157
> 
> /**
>  * Get all the barring info for the current camped cell applicable to the current user.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getBarringInfoResponse()
>  */
> #define RIL_REQUEST_GET_BARRING_INFO 158
> 
> /**
>  * RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY
>  *
>  * Enable or disable E-UTRA-NR dual connectivity.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  */
> #define RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY 159
> 
> /**
>  * RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED
>  *
>  * Whether E-UTRA-NR dual connectivity is enabled.
>  *
>  * Response: a boolean of enable or not.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  */
> #define RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED 160
> 
> /**
>  * Allocates a pdu session id
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.allocatePduSessionIdResponse()
>  */
> #define RIL_REQUEST_ALLOCATE_PDU_SESSION_ID 161
> 
> /**
>  * Releases a pdu session id
>  *
>  * @param serial Serial number of request.
>  * @param id Pdu session id to release
>  *
>  * Response callback is IRadioResponse.releasePduSessionIdResponse()
>  */
> #define RIL_REQUEST_RELEASE_PDU_SESSION_ID 162
> 
> /**
>  * Indicates that handover has begun
>  *
>  * @param serial Serial number of request.
>  * @param callId The unique identifier of the corresponding data call
>  *
>  * Response callback is IRadioResponse.startHandoverResponse()
>  */
> #define RIL_REQUEST_START_HANDOVER 163
> 
> /**
>  * Indicates that a handover has been cancelled
>  *
>  * @param serial Serial number of request.
>  * @param callId The unique identifier of the corresponding data call
>  *
>  * Response callback is IRadioResponse.cancelHandoverResponse()
>  */
> #define RIL_REQUEST_CANCEL_HANDOVER 164
> 
> /**
>  * RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP
>  *
>  * Instruct the radio to *only* accept the types of network provided. This
>  * is stronger than setPreferredNetworkType which is a suggestion.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  OPERATION_NOT_ALLOWED
>  *  MODE_NOT_SUPPORTED
>  *  NO_MEMORY
>  *  INTERNAL_ERR
>  *  SYSTEM_ERR
>  *  INVALID_ARGUMENTS
>  *  MODEM_ERR
>  *  REQUEST_NOT_SUPPORTED
>  *  NO_RESOURCES
>  *  CANCELLED
>  */
> #define RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP 165
> 
> /**
> * RIL_REQUEST_SET_DATA_THROTTLING
> *
> * Set the data throttling on device.
> *
> * Response: an int enum of type ThermalMitigationResult as defined in
> * android.telephony.Annotation.
> *
> * Valid errors:
> *  SUCCESS
> *  RADIO_NOT_AVAILABLE
> *  MODEM_ERR
> *  INVALID_ARGUMENTS
> */
> #define RIL_REQUEST_SET_DATA_THROTTLING 166
> 
> /**
>  * Get which bands the modem's background scan is acting on.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  INTERNAL_ERR
>  *
>  */
> #define RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS 167
> 
> /**
>  * RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP
>  *
>  * Request previously set allowed network types from the radio.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  OPERATION_NOT_ALLOWED
>  *  MODE_NOT_SUPPORTED
>  *  NO_MEMORY
>  *  INTERNAL_ERR
>  *  SYSTEM_ERR
>  *  INVALID_ARGUMENTS
>  *  MODEM_ERR
>  *  REQUEST_NOT_SUPPORTED
>  *  NO_RESOURCES
>  *  CANCELLED
>  */
> #define RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP 168
> 
> /**
>  * RIL_REQUEST_GET_SLICING_CONFIG
>  *
>  * Request to get the current slicing configuration including URSP rules and
>  * NSSAIs (configured, allowed and rejected).
>  *
>  * Response callback is IRadioResponse.getSlicingConfigResponse()
>  */
> #define RIL_REQUEST_GET_SLICING_CONFIG 169
> 
> #define RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS 170
> 
> #define RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY 171
> 
> #define RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS 172
> 
> 
> #define RIL_REQUEST_LAST RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS
> 
> /***********************************************************************/
> 
> /* Radio Config @{ */
> #define RIL_REQUEST_RADIO_CONFIG_BASE 600
> 
> /**
>  * Get SIM Slot status.
>  *
>  * Request provides the slot status of all active and inactive SIM slots and whether card is
>  * present in the slots or not.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioConfigResponse.getSimSlotsStatusResponse()
>  */
> #define RIL_REQUEST_CONFIG_GET_SLOT_STATUS 601
> 
> /**
>  * Set SIM Slot mapping.
> 
>  * Maps the logical slots to the physical slots. Logical slot is the slot that is seen by modem.
>  * Physical slot is the actual physical slot. Request maps the physical slot to logical slot.
>  * Logical slots that are already mapped to the requested physical slot are not impacted.
>  *
>  * Example no. of logical slots 1 and physical slots 2:
>  * The only logical slot (index 0) can be mapped to first physical slot (value 0) or second
>  * physical slot(value 1), while the other physical slot remains unmapped and inactive.
>  * slotMap[0] = 1 or slotMap[0] = 0
>  *
>  * Example no. of logical slots 2 and physical slots 2:
>  * First logical slot (index 0) can be mapped to physical slot 1 or 2 and other logical slot
>  * can be mapped to other physical slot. Each logical slot must be mapped to a physical slot.
>  * slotMap[0] = 0 and slotMap[1] = 1 or slotMap[0] = 1 and slotMap[1] = 0
>  *
>  * @param serial Serial number of request
>  * @param slotMap Logical to physical slot mapping, size == no. of radio instances. Index is
>  *        mapping to logical slot and value to physical slot, need to provide all the slots
>  *        mapping when sending request in case of multi slot device.
>  *        EX: uint32_t slotMap[logical slot] = physical slot
>  *        index 0 is the first logical_slot number of logical slots is equal to number of Radio
>  *        instances and number of physical slots is equal to size of slotStatus in
>  *        getSimSlotsStatusResponse
>  *
>  * Response callback is IRadioConfigResponse.setSimSlotsMappingResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_SLOT_MAPPING 602
> 
> /**
>  * Request current phone capability.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getPhoneCapabilityResponse() which
>  * will return <@1.1::PhoneCapability>.
>  */
> #define RIL_REQUEST_CONFIG_GET_PHONE_CAPABILITY 603
> 
> /**
>  * Set preferred data modem Id.
>  * In a multi-SIM device, notify modem layer which logical modem will be used primarily
>  * for data. It helps modem with resource optimization and decisions of what data connections
>  * should be satisfied.
>  *
>  * @param serial Serial number of request.
>  * @param modem Id the logical modem ID, which should match one of modem IDs returned
>  * from getPhoneCapability().
>  *
>  * Response callback is IRadioConfigResponse.setPreferredDataModemResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_PREFER_DATA_MODEM 604
> 
> /**
>  * Set modems configurations by specifying the number of live modems (i.e modems that are
>  * enabled and actively working as part of a working telephony stack).
>  *
>  * Example: this interface can be used to switch to single/multi sim mode by specifying
>  * the number of live modems as 1, 2, etc
>  *
>  * Note: by setting the number of live modems in this API, that number of modems will
>  * subsequently get enabled/disabled
>  *
>  * @param serial serial number of request.
>  * @param modemsConfig ModemsConfig object including the number of live modems
>  *
>  * Response callback is IRadioResponse.setModemsConfigResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_MODEM_CONFIG 605
> 
> /**
>  * Get modems configurations. This interface is used to get modem configurations
>  * which includes the number of live modems (i.e modems that are
>  * enabled and actively working as part of a working telephony stack)
>  *
>  * Note: in order to get the overall number of modems available on the phone,
>  * refer to getPhoneCapability API
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getModemsConfigResponse() which
>  * will return <@1.1::ModemsConfig>.
>  */
> #define RIL_REQUEST_CONFIG_GET_MODEM_CONFIG 606
> 
> #define RIL_REQUEST_CONFIG_GET_HAL_DEVICE_CAPABILITIES 607
> 
> /* Make sure to update ril_config_commands.h when changing this constant. */
> #define RIL_REQUEST_RADIO_CONFIG_LAST    RIL_REQUEST_CONFIG_GET_HAL_DEVICE_CAPABILITIES
> /* }@ */
> 
7024a8341,8356
> 
> #define RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS 1051
> 
> #define RIL_UNSOL_RESPONSE_LAST RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS
> 
> /***********************************************************************/
> 
> #define RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE 1100
> /**
>  * RIL_UNSOL_CONFIG_ICC_SLOT_STATUS
>  *
>  * "data" is the RIL_SimSlotStatus_V1_2 structure
>  */
> #define RIL_UNSOL_CONFIG_ICC_SLOT_STATUS 1052
> 
> #define RIL_UNSOL_RESPONSE_RADIO_CONFIG_LAST RIL_UNSOL_CONFIG_ICC_SLOT_STATUS
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/Android.mk /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/Android.mk
11a12
>     ril_config.cpp \
22a24,33
>     android.hardware.radio@1.2 \
>     android.hardware.radio@1.3 \
>     android.hardware.radio@1.4 \
>     android.hardware.radio@1.5 \
>     android.hardware.radio@1.6 \
>     android.hardware.radio.config@1.0 \
>     android.hardware.radio.config@1.1 \
>     android.hardware.radio.config@1.2 \
>     android.hardware.radio.config@1.3 \
>     android.hardware.radio.deprecated@1.0 \
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/ril_commands.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/ril_commands.h
18,54c18,54
<     {RIL_REQUEST_GET_SIM_STATUS, radio::getIccCardStatusResponse},
<     {RIL_REQUEST_ENTER_SIM_PIN, radio::supplyIccPinForAppResponse},
<     {RIL_REQUEST_ENTER_SIM_PUK, radio::supplyIccPukForAppResponse},
<     {RIL_REQUEST_ENTER_SIM_PIN2, radio::supplyIccPin2ForAppResponse},
<     {RIL_REQUEST_ENTER_SIM_PUK2, radio::supplyIccPuk2ForAppResponse},
<     {RIL_REQUEST_CHANGE_SIM_PIN, radio::changeIccPinForAppResponse},
<     {RIL_REQUEST_CHANGE_SIM_PIN2, radio::changeIccPin2ForAppResponse},
<     {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, radio::supplyNetworkDepersonalizationResponse},
<     {RIL_REQUEST_GET_CURRENT_CALLS, radio::getCurrentCallsResponse},
<     {RIL_REQUEST_DIAL, radio::dialResponse},
<     {RIL_REQUEST_GET_IMSI, radio::getIMSIForAppResponse},
<     {RIL_REQUEST_HANGUP, radio::hangupConnectionResponse},
<     {RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, radio::hangupWaitingOrBackgroundResponse},
<     {RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, radio::hangupForegroundResumeBackgroundResponse},
<     {RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, radio::switchWaitingOrHoldingAndActiveResponse},
<     {RIL_REQUEST_CONFERENCE, radio::conferenceResponse},
<     {RIL_REQUEST_UDUB, radio::rejectCallResponse},
<     {RIL_REQUEST_LAST_CALL_FAIL_CAUSE, radio::getLastCallFailCauseResponse},
<     {RIL_REQUEST_SIGNAL_STRENGTH, radio::getSignalStrengthResponse},
<     {RIL_REQUEST_VOICE_REGISTRATION_STATE, radio::getVoiceRegistrationStateResponse},
<     {RIL_REQUEST_DATA_REGISTRATION_STATE, radio::getDataRegistrationStateResponse},
<     {RIL_REQUEST_OPERATOR, radio::getOperatorResponse},
<     {RIL_REQUEST_RADIO_POWER, radio::setRadioPowerResponse},
<     {RIL_REQUEST_DTMF, radio::sendDtmfResponse},
<     {RIL_REQUEST_SEND_SMS, radio::sendSmsResponse},
<     {RIL_REQUEST_SEND_SMS_EXPECT_MORE, radio::sendSMSExpectMoreResponse},
<     {RIL_REQUEST_SETUP_DATA_CALL, radio::setupDataCallResponse},
<     {RIL_REQUEST_SIM_IO, radio::iccIOForAppResponse},
<     {RIL_REQUEST_SEND_USSD, radio::sendUssdResponse},
<     {RIL_REQUEST_CANCEL_USSD, radio::cancelPendingUssdResponse},
<     {RIL_REQUEST_GET_CLIR, radio::getClirResponse},
<     {RIL_REQUEST_SET_CLIR, radio::setClirResponse},
<     {RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, radio::getCallForwardStatusResponse},
<     {RIL_REQUEST_SET_CALL_FORWARD, radio::setCallForwardResponse},
<     {RIL_REQUEST_QUERY_CALL_WAITING, radio::getCallWaitingResponse},
<     {RIL_REQUEST_SET_CALL_WAITING, radio::setCallWaitingResponse},
<     {RIL_REQUEST_SMS_ACKNOWLEDGE, radio::acknowledgeLastIncomingGsmSmsResponse},
---
>     {RIL_REQUEST_GET_SIM_STATUS, radio_1_6::getIccCardStatusResponse},
>     {RIL_REQUEST_ENTER_SIM_PIN, radio_1_6::supplyIccPinForAppResponse},
>     {RIL_REQUEST_ENTER_SIM_PUK, radio_1_6::supplyIccPukForAppResponse},
>     {RIL_REQUEST_ENTER_SIM_PIN2, radio_1_6::supplyIccPin2ForAppResponse},
>     {RIL_REQUEST_ENTER_SIM_PUK2, radio_1_6::supplyIccPuk2ForAppResponse},
>     {RIL_REQUEST_CHANGE_SIM_PIN, radio_1_6::changeIccPinForAppResponse},
>     {RIL_REQUEST_CHANGE_SIM_PIN2, radio_1_6::changeIccPin2ForAppResponse},
>     {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, radio_1_6::supplyNetworkDepersonalizationResponse},
>     {RIL_REQUEST_GET_CURRENT_CALLS, radio_1_6::getCurrentCallsResponse},
>     {RIL_REQUEST_DIAL, radio_1_6::dialResponse},
>     {RIL_REQUEST_GET_IMSI, radio_1_6::getIMSIForAppResponse},
>     {RIL_REQUEST_HANGUP, radio_1_6::hangupConnectionResponse},
>     {RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, radio_1_6::hangupWaitingOrBackgroundResponse},
>     {RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, radio_1_6::hangupForegroundResumeBackgroundResponse},
>     {RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, radio_1_6::switchWaitingOrHoldingAndActiveResponse},
>     {RIL_REQUEST_CONFERENCE, radio_1_6::conferenceResponse},
>     {RIL_REQUEST_UDUB, radio_1_6::rejectCallResponse},
>     {RIL_REQUEST_LAST_CALL_FAIL_CAUSE, radio_1_6::getLastCallFailCauseResponse},
>     {RIL_REQUEST_SIGNAL_STRENGTH, radio_1_6::getSignalStrengthResponse},
>     {RIL_REQUEST_VOICE_REGISTRATION_STATE, radio_1_6::getVoiceRegistrationStateResponse},
>     {RIL_REQUEST_DATA_REGISTRATION_STATE, radio_1_6::getDataRegistrationStateResponse},
>     {RIL_REQUEST_OPERATOR, radio_1_6::getOperatorResponse},
>     {RIL_REQUEST_RADIO_POWER, radio_1_6::setRadioPowerResponse},
>     {RIL_REQUEST_DTMF, radio_1_6::sendDtmfResponse},
>     {RIL_REQUEST_SEND_SMS, radio_1_6::sendSmsResponse},
>     {RIL_REQUEST_SEND_SMS_EXPECT_MORE, radio_1_6::sendSmsExpectMoreResponse},
>     {RIL_REQUEST_SETUP_DATA_CALL, radio_1_6::setupDataCallResponse},
>     {RIL_REQUEST_SIM_IO, radio_1_6::iccIOForAppResponse},
>     {RIL_REQUEST_SEND_USSD, radio_1_6::sendUssdResponse},
>     {RIL_REQUEST_CANCEL_USSD, radio_1_6::cancelPendingUssdResponse},
>     {RIL_REQUEST_GET_CLIR, radio_1_6::getClirResponse},
>     {RIL_REQUEST_SET_CLIR, radio_1_6::setClirResponse},
>     {RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, radio_1_6::getCallForwardStatusResponse},
>     {RIL_REQUEST_SET_CALL_FORWARD, radio_1_6::setCallForwardResponse},
>     {RIL_REQUEST_QUERY_CALL_WAITING, radio_1_6::getCallWaitingResponse},
>     {RIL_REQUEST_SET_CALL_WAITING, radio_1_6::setCallWaitingResponse},
>     {RIL_REQUEST_SMS_ACKNOWLEDGE, radio_1_6::acknowledgeLastIncomingGsmSmsResponse},
57,72c57,72
<     {RIL_REQUEST_ANSWER, radio::acceptCallResponse},
<     {RIL_REQUEST_DEACTIVATE_DATA_CALL, radio::deactivateDataCallResponse},
<     {RIL_REQUEST_QUERY_FACILITY_LOCK, radio::getFacilityLockForAppResponse},
<     {RIL_REQUEST_SET_FACILITY_LOCK, radio::setFacilityLockForAppResponse},
<     {RIL_REQUEST_CHANGE_BARRING_PASSWORD, radio::setBarringPasswordResponse},
<     {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, radio::getNetworkSelectionModeResponse},
<     {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, radio::setNetworkSelectionModeAutomaticResponse},
<     {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, radio::setNetworkSelectionModeManualResponse},
<     {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , radio::getAvailableNetworksResponse},
<     {RIL_REQUEST_DTMF_START, radio::startDtmfResponse},
<     {RIL_REQUEST_DTMF_STOP, radio::stopDtmfResponse},
<     {RIL_REQUEST_BASEBAND_VERSION, radio::getBasebandVersionResponse},
<     {RIL_REQUEST_SEPARATE_CONNECTION, radio::separateConnectionResponse},
<     {RIL_REQUEST_SET_MUTE, radio::setMuteResponse},
<     {RIL_REQUEST_GET_MUTE, radio::getMuteResponse},
<     {RIL_REQUEST_QUERY_CLIP, radio::getClipResponse},
---
>     {RIL_REQUEST_ANSWER, radio_1_6::acceptCallResponse},
>     {RIL_REQUEST_DEACTIVATE_DATA_CALL, radio_1_6::deactivateDataCallResponse},
>     {RIL_REQUEST_QUERY_FACILITY_LOCK, radio_1_6::getFacilityLockForAppResponse},
>     {RIL_REQUEST_SET_FACILITY_LOCK, radio_1_6::setFacilityLockForAppResponse},
>     {RIL_REQUEST_CHANGE_BARRING_PASSWORD, radio_1_6::setBarringPasswordResponse},
>     {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, radio_1_6::getNetworkSelectionModeResponse},
>     {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, radio_1_6::setNetworkSelectionModeAutomaticResponse},
>     {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, radio_1_6::setNetworkSelectionModeManualResponse},
>     {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , radio_1_6::getAvailableNetworksResponse},
>     {RIL_REQUEST_DTMF_START, radio_1_6::startDtmfResponse},
>     {RIL_REQUEST_DTMF_STOP, radio_1_6::stopDtmfResponse},
>     {RIL_REQUEST_BASEBAND_VERSION, radio_1_6::getBasebandVersionResponse},
>     {RIL_REQUEST_SEPARATE_CONNECTION, radio_1_6::separateConnectionResponse},
>     {RIL_REQUEST_SET_MUTE, radio_1_6::setMuteResponse},
>     {RIL_REQUEST_GET_MUTE, radio_1_6::getMuteResponse},
>     {RIL_REQUEST_QUERY_CLIP, radio_1_6::getClipResponse},
74c74
<     {RIL_REQUEST_DATA_CALL_LIST, radio::getDataCallListResponse},
---
>     {RIL_REQUEST_DATA_CALL_LIST, radio_1_6::getDataCallListResponse},
76,83c76,83
<     {RIL_REQUEST_OEM_HOOK_RAW, NULL},
<     {RIL_REQUEST_OEM_HOOK_STRINGS, NULL},
<     {RIL_REQUEST_SCREEN_STATE, radio::sendDeviceStateResponse},   // Note the response function is different.
<     {RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, radio::setSuppServiceNotificationsResponse},
<     {RIL_REQUEST_WRITE_SMS_TO_SIM, radio::writeSmsToSimResponse},
<     {RIL_REQUEST_DELETE_SMS_ON_SIM, radio::deleteSmsOnSimResponse},
<     {RIL_REQUEST_SET_BAND_MODE, radio::setBandModeResponse},
<     {RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, radio::getAvailableBandModesResponse},
---
>     {RIL_REQUEST_OEM_HOOK_RAW, radio_1_6::sendRequestRawResponse},
>     {RIL_REQUEST_OEM_HOOK_STRINGS, radio_1_6::sendRequestStringsResponse},
>     {RIL_REQUEST_SCREEN_STATE, radio_1_6::sendDeviceStateResponse},   // Note the response function is different.
>     {RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, radio_1_6::setSuppServiceNotificationsResponse},
>     {RIL_REQUEST_WRITE_SMS_TO_SIM, radio_1_6::writeSmsToSimResponse},
>     {RIL_REQUEST_DELETE_SMS_ON_SIM, radio_1_6::deleteSmsOnSimResponse},
>     {RIL_REQUEST_SET_BAND_MODE, radio_1_6::setBandModeResponse},
>     {RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, radio_1_6::getAvailableBandModesResponse},
86,102c86,102
<     {RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, radio::sendEnvelopeResponse},
<     {RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, radio::sendTerminalResponseToSimResponse},
<     {RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, radio::handleStkCallSetupRequestFromSimResponse},
<     {RIL_REQUEST_EXPLICIT_CALL_TRANSFER, radio::explicitCallTransferResponse},
<     {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, radio::setPreferredNetworkTypeResponse},
<     {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, radio::getPreferredNetworkTypeResponse},
<     {RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, radio::getNeighboringCidsResponse},
<     {RIL_REQUEST_SET_LOCATION_UPDATES, radio::setLocationUpdatesResponse},
<     {RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, radio::setCdmaSubscriptionSourceResponse},
<     {RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, radio::setCdmaRoamingPreferenceResponse},
<     {RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, radio::getCdmaRoamingPreferenceResponse},
<     {RIL_REQUEST_SET_TTY_MODE, radio::setTTYModeResponse},
<     {RIL_REQUEST_QUERY_TTY_MODE, radio::getTTYModeResponse},
<     {RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, radio::setPreferredVoicePrivacyResponse},
<     {RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, radio::getPreferredVoicePrivacyResponse},
<     {RIL_REQUEST_CDMA_FLASH, radio::sendCDMAFeatureCodeResponse},
<     {RIL_REQUEST_CDMA_BURST_DTMF, radio::sendBurstDtmfResponse},
---
>     {RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, radio_1_6::sendEnvelopeResponse},
>     {RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, radio_1_6::sendTerminalResponseToSimResponse},
>     {RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, radio_1_6::handleStkCallSetupRequestFromSimResponse},
>     {RIL_REQUEST_EXPLICIT_CALL_TRANSFER, radio_1_6::explicitCallTransferResponse},
>     {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, radio_1_6::setPreferredNetworkTypeResponse},
>     {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, radio_1_6::getPreferredNetworkTypeResponse},
>     {RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, radio_1_6::getNeighboringCidsResponse},
>     {RIL_REQUEST_SET_LOCATION_UPDATES, radio_1_6::setLocationUpdatesResponse},
>     {RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, radio_1_6::setCdmaSubscriptionSourceResponse},
>     {RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, radio_1_6::setCdmaRoamingPreferenceResponse},
>     {RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, radio_1_6::getCdmaRoamingPreferenceResponse},
>     {RIL_REQUEST_SET_TTY_MODE, radio_1_6::setTTYModeResponse},
>     {RIL_REQUEST_QUERY_TTY_MODE, radio_1_6::getTTYModeResponse},
>     {RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, radio_1_6::setPreferredVoicePrivacyResponse},
>     {RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, radio_1_6::getPreferredVoicePrivacyResponse},
>     {RIL_REQUEST_CDMA_FLASH, radio_1_6::sendCDMAFeatureCodeResponse},
>     {RIL_REQUEST_CDMA_BURST_DTMF, radio_1_6::sendBurstDtmfResponse},
104,142c104,142
<     {RIL_REQUEST_CDMA_SEND_SMS, radio::sendCdmaSmsResponse},
<     {RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, radio::acknowledgeLastIncomingCdmaSmsResponse},
<     {RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG, radio::getGsmBroadcastConfigResponse},
<     {RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG, radio::setGsmBroadcastConfigResponse},
<     {RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION, radio::setGsmBroadcastActivationResponse},
<     {RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG, radio::getCdmaBroadcastConfigResponse},
<     {RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG, radio::setCdmaBroadcastConfigResponse},
<     {RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION, radio::setCdmaBroadcastActivationResponse},
<     {RIL_REQUEST_CDMA_SUBSCRIPTION, radio::getCDMASubscriptionResponse},
<     {RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, radio::writeSmsToRuimResponse},
<     {RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, radio::deleteSmsOnRuimResponse},
<     {RIL_REQUEST_DEVICE_IDENTITY, radio::getDeviceIdentityResponse},
<     {RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, radio::exitEmergencyCallbackModeResponse},
<     {RIL_REQUEST_GET_SMSC_ADDRESS, radio::getSmscAddressResponse},
<     {RIL_REQUEST_SET_SMSC_ADDRESS, radio::setSmscAddressResponse},
<     {RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, radio::reportSmsMemoryStatusResponse},
<     {RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, radio::reportStkServiceIsRunningResponse},
<     {RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, radio::getCdmaSubscriptionSourceResponse},
<     {RIL_REQUEST_ISIM_AUTHENTICATION, radio::requestIsimAuthenticationResponse},
<     {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, radio::acknowledgeIncomingGsmSmsWithPduResponse},
<     {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, radio::sendEnvelopeWithStatusResponse},
<     {RIL_REQUEST_VOICE_RADIO_TECH, radio::getVoiceRadioTechnologyResponse},
<     {RIL_REQUEST_GET_CELL_INFO_LIST, radio::getCellInfoListResponse},
<     {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, radio::setCellInfoListRateResponse},
<     {RIL_REQUEST_SET_INITIAL_ATTACH_APN, radio::setInitialAttachApnResponse},
<     {RIL_REQUEST_IMS_REGISTRATION_STATE, radio::getImsRegistrationStateResponse},
<     {RIL_REQUEST_IMS_SEND_SMS, radio::sendImsSmsResponse},
<     {RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, radio::iccTransmitApduBasicChannelResponse},
<     {RIL_REQUEST_SIM_OPEN_CHANNEL, radio::iccOpenLogicalChannelResponse},
<     {RIL_REQUEST_SIM_CLOSE_CHANNEL, radio::iccCloseLogicalChannelResponse},
<     {RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, radio::iccTransmitApduLogicalChannelResponse},
<     {RIL_REQUEST_NV_READ_ITEM, radio::nvReadItemResponse},
<     {RIL_REQUEST_NV_WRITE_ITEM, radio::nvWriteItemResponse},
<     {RIL_REQUEST_NV_WRITE_CDMA_PRL, radio::nvWriteCdmaPrlResponse},
<     {RIL_REQUEST_NV_RESET_CONFIG, radio::nvResetConfigResponse},
<     {RIL_REQUEST_SET_UICC_SUBSCRIPTION, radio::setUiccSubscriptionResponse},
<     {RIL_REQUEST_ALLOW_DATA, radio::setDataAllowedResponse},
<     {RIL_REQUEST_GET_HARDWARE_CONFIG, radio::getHardwareConfigResponse},
<     {RIL_REQUEST_SIM_AUTHENTICATION, radio::requestIccSimAuthenticationResponse},
---
>     {RIL_REQUEST_CDMA_SEND_SMS, radio_1_6::sendCdmaSmsResponse},
>     {RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, radio_1_6::acknowledgeLastIncomingCdmaSmsResponse},
>     {RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG, radio_1_6::getGsmBroadcastConfigResponse},
>     {RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG, radio_1_6::setGsmBroadcastConfigResponse},
>     {RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION, radio_1_6::setGsmBroadcastActivationResponse},
>     {RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG, radio_1_6::getCdmaBroadcastConfigResponse},
>     {RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG, radio_1_6::setCdmaBroadcastConfigResponse},
>     {RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION, radio_1_6::setCdmaBroadcastActivationResponse},
>     {RIL_REQUEST_CDMA_SUBSCRIPTION, radio_1_6::getCDMASubscriptionResponse},
>     {RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, radio_1_6::writeSmsToRuimResponse},
>     {RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, radio_1_6::deleteSmsOnRuimResponse},
>     {RIL_REQUEST_DEVICE_IDENTITY, radio_1_6::getDeviceIdentityResponse},
>     {RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, radio_1_6::exitEmergencyCallbackModeResponse},
>     {RIL_REQUEST_GET_SMSC_ADDRESS, radio_1_6::getSmscAddressResponse},
>     {RIL_REQUEST_SET_SMSC_ADDRESS, radio_1_6::setSmscAddressResponse},
>     {RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, radio_1_6::reportSmsMemoryStatusResponse},
>     {RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, radio_1_6::reportStkServiceIsRunningResponse},
>     {RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, radio_1_6::getCdmaSubscriptionSourceResponse},
>     {RIL_REQUEST_ISIM_AUTHENTICATION, radio_1_6::requestIsimAuthenticationResponse},
>     {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, radio_1_6::acknowledgeIncomingGsmSmsWithPduResponse},
>     {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, radio_1_6::sendEnvelopeWithStatusResponse},
>     {RIL_REQUEST_VOICE_RADIO_TECH, radio_1_6::getVoiceRadioTechnologyResponse},
>     {RIL_REQUEST_GET_CELL_INFO_LIST, radio_1_6::getCellInfoListResponse},
>     {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, radio_1_6::setCellInfoListRateResponse},
>     {RIL_REQUEST_SET_INITIAL_ATTACH_APN, radio_1_6::setInitialAttachApnResponse},
>     {RIL_REQUEST_IMS_REGISTRATION_STATE, radio_1_6::getImsRegistrationStateResponse},
>     {RIL_REQUEST_IMS_SEND_SMS, radio_1_6::sendImsSmsResponse},
>     {RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, radio_1_6::iccTransmitApduBasicChannelResponse},
>     {RIL_REQUEST_SIM_OPEN_CHANNEL, radio_1_6::iccOpenLogicalChannelResponse},
>     {RIL_REQUEST_SIM_CLOSE_CHANNEL, radio_1_6::iccCloseLogicalChannelResponse},
>     {RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, radio_1_6::iccTransmitApduLogicalChannelResponse},
>     {RIL_REQUEST_NV_READ_ITEM, radio_1_6::nvReadItemResponse},
>     {RIL_REQUEST_NV_WRITE_ITEM, radio_1_6::nvWriteItemResponse},
>     {RIL_REQUEST_NV_WRITE_CDMA_PRL, radio_1_6::nvWriteCdmaPrlResponse},
>     {RIL_REQUEST_NV_RESET_CONFIG, radio_1_6::nvResetConfigResponse},
>     {RIL_REQUEST_SET_UICC_SUBSCRIPTION, radio_1_6::setUiccSubscriptionResponse},
>     {RIL_REQUEST_ALLOW_DATA, radio_1_6::setDataAllowedResponse},
>     {RIL_REQUEST_GET_HARDWARE_CONFIG, radio_1_6::getHardwareConfigResponse},
>     {RIL_REQUEST_SIM_AUTHENTICATION, radio_1_6::requestIccSimAuthenticationResponse},
145,162c145,189
<     {RIL_REQUEST_SET_DATA_PROFILE, radio::setDataProfileResponse},
<     {RIL_REQUEST_SHUTDOWN, radio::requestShutdownResponse},
<     {RIL_REQUEST_GET_RADIO_CAPABILITY, radio::getRadioCapabilityResponse},
<     {RIL_REQUEST_SET_RADIO_CAPABILITY, radio::setRadioCapabilityResponse},
<     {RIL_REQUEST_START_LCE, radio::startLceServiceResponse},
<     {RIL_REQUEST_STOP_LCE, radio::stopLceServiceResponse},
<     {RIL_REQUEST_PULL_LCEDATA, radio::pullLceDataResponse},
<     {RIL_REQUEST_GET_ACTIVITY_INFO, radio::getModemActivityInfoResponse},
<     {RIL_REQUEST_SET_CARRIER_RESTRICTIONS, radio::setAllowedCarriersResponse},
<     {RIL_REQUEST_GET_CARRIER_RESTRICTIONS, radio::getAllowedCarriersResponse},
<     {RIL_REQUEST_SEND_DEVICE_STATE, radio::sendDeviceStateResponse},
<     {RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER, radio::setIndicationFilterResponse},
<     {RIL_REQUEST_SET_SIM_CARD_POWER, radio::setSimCardPowerResponse},
<     {RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, radio::setCarrierInfoForImsiEncryptionResponse},
<     {RIL_REQUEST_START_NETWORK_SCAN, radio::startNetworkScanResponse},
<     {RIL_REQUEST_STOP_NETWORK_SCAN, radio::stopNetworkScanResponse},
<     {RIL_REQUEST_START_KEEPALIVE, radio::startKeepaliveResponse},
<     {RIL_REQUEST_STOP_KEEPALIVE, radio::stopKeepaliveResponse},
---
>     {RIL_REQUEST_SET_DATA_PROFILE, radio_1_6::setDataProfileResponse},
>     {RIL_REQUEST_SHUTDOWN, radio_1_6::requestShutdownResponse},
>     {RIL_REQUEST_GET_RADIO_CAPABILITY, radio_1_6::getRadioCapabilityResponse},
>     {RIL_REQUEST_SET_RADIO_CAPABILITY, radio_1_6::setRadioCapabilityResponse},
>     {RIL_REQUEST_START_LCE, radio_1_6::startLceServiceResponse},
>     {RIL_REQUEST_STOP_LCE, radio_1_6::stopLceServiceResponse},
>     {RIL_REQUEST_PULL_LCEDATA, radio_1_6::pullLceDataResponse},
>     {RIL_REQUEST_GET_ACTIVITY_INFO, radio_1_6::getModemActivityInfoResponse},
>     {RIL_REQUEST_SET_CARRIER_RESTRICTIONS, radio_1_6::setAllowedCarriersResponse},
>     {RIL_REQUEST_GET_CARRIER_RESTRICTIONS, radio_1_6::getAllowedCarriersResponse},
>     {RIL_REQUEST_SEND_DEVICE_STATE, radio_1_6::sendDeviceStateResponse},
>     {RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER, radio_1_6::setIndicationFilterResponse},
>     {RIL_REQUEST_SET_SIM_CARD_POWER, radio_1_6::setSimCardPowerResponse},
>     {RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, radio_1_6::setCarrierInfoForImsiEncryptionResponse},
>     {RIL_REQUEST_START_NETWORK_SCAN, radio_1_6::startNetworkScanResponse},
>     {RIL_REQUEST_STOP_NETWORK_SCAN, radio_1_6::stopNetworkScanResponse},
>     {RIL_REQUEST_START_KEEPALIVE, radio_1_6::startKeepaliveResponse},
>     {RIL_REQUEST_STOP_KEEPALIVE, radio_1_6::stopKeepaliveResponse},
>     {RIL_REQUEST_GET_MODEM_STACK_STATUS, radio_1_6::getModemStackStatusResponse},
>     {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP, radio_1_6::getPreferredNetworkTypeBitmapResponse},
>     {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP, radio_1_6::setPreferredNetworkTypeBitmapResponse},
>     {RIL_REQUEST_EMERGENCY_DIAL, radio_1_6::emergencyDialResponse},
>     {RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS, radio_1_6::setSystemSelectionChannelsResponse},
>     {RIL_REQUEST_ENABLE_MODEM, radio_1_6::enableModemResponse},
>     {RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA, radio_1_6::setSignalStrengthReportingCriteriaResponse},
>     {RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA, radio_1_6::setLinkCapacityReportingCriteriaResponse},
>     {RIL_REQUEST_ENABLE_UICC_APPLICATIONS, radio_1_6::enableUiccApplicationsResponse},
>     {RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED, radio_1_6::areUiccApplicationsEnabledResponse},
>     {RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION, radio_1_6::supplySimDepersonalizationResponse},
>     {RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE, radio_1_6::sendCdmaSmsExpectMoreResponse},
>     {RIL_REQUEST_GET_BARRING_INFO, radio_1_6::getBarringInfoResponse},
>     {RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY, radio_1_6::setNrDualConnectivityStateResponse},
>     {RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED, radio_1_6::isNrDualConnectivityEnabledResponse},
>     {RIL_REQUEST_ALLOCATE_PDU_SESSION_ID, radio_1_6::allocatePduSessionIdResponse},
>     {RIL_REQUEST_RELEASE_PDU_SESSION_ID, radio_1_6::releasePduSessionIdResponse},
>     {RIL_REQUEST_START_HANDOVER, radio_1_6::startHandoverResponse},
>     {RIL_REQUEST_CANCEL_HANDOVER, radio_1_6::cancelHandoverResponse},
>     {RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP, radio_1_6::setAllowedNetworkTypesBitmapResponse},
>     {RIL_REQUEST_SET_DATA_THROTTLING, radio_1_6::setDataThrottlingResponse},
>     {RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS, radio_1_6::getSystemSelectionChannelsResponse},
>     {RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP, radio_1_6::getAllowedNetworkTypesBitmapResponse},
>     {RIL_REQUEST_GET_SLICING_CONFIG, radio_1_6::getSlicingConfigResponse},
>     {RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS, radio_1_6::getSimPhonebookRecordsResponse},
>     {RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY, radio_1_6::getSimPhonebookCapacityResponse},
>     {RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS, radio_1_6::updateSimPhonebookRecordsResponse}
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril: ril_config_commands.h
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril: ril_config.cpp
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril: ril_config_unsol_commands.h
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/ril.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/ril.cpp
191a192,201
> /* Radio Config Request @{ */
> static CommandInfo s_configCommands[] = {
> #include "ril_config_commands.h"
> };
> 
> static UnsolResponseInfo s_configUnsolResponses[] = {
> #include "ril_config_unsol_commands.h"
> };
> /* }@ */
> 
198c208
<     RequestInfo *pRI;
---
>     RequestInfo *pRI = nullptr;
233a244,250
> 
>     if (request >= RIL_REQUEST_RADIO_CONFIG_BASE &&
>         request <= RIL_REQUEST_RADIO_CONFIG_LAST) {
>         request = request - RIL_REQUEST_RADIO_CONFIG_BASE;
>         pRI->pCI = &(s_configCommands[request]);
>     }
> 
288c305
<         pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(
---
>         pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock(
293c310
<         int ret = radio::nitzTimeReceivedInd(
---
>         int ret = radio_1_6::nitzTimeReceivedInd(
435c452
<     RLOGE("RIL_register: RIL version %d", callbacks->version);
---
>     RLOGD("RIL_register: RIL version %d", callbacks->version);
459c476
<     radio::registerService(&s_callbacks, s_commands);
---
>     radio_1_6::registerService(&s_callbacks, s_commands);
461a479,492
>     /* Radio Config Request @{ */
>     for (int i = 1; i < (int)NUM_ELEMS(s_configCommands); i++) {
>         assert(i == s_configCommands[i].requestNumber -
>             RIL_REQUEST_RADIO_CONFIG_BASE);
>     }
> 
>     for (int i = 0; i < (int)NUM_ELEMS(s_configUnsolResponses); i++) {
>         assert(i == s_configUnsolResponses[i].requestNumber -
>             RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE);
>     }
>     radio_1_6::registerConfigService(&s_callbacks, s_configCommands);
>     /* }@ */
> 
> 
577c608
<         pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(
---
>         pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock(
582c613
<         radio::acknowledgeRequest((int) socket_id, pRI->token);
---
>         radio_1_6::acknowledgeRequest((int) socket_id, pRI->token);
601a633
> 
634c666
<         pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) socket_id);
---
>         pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock((int) socket_id);
733a766
>     UnsolResponseInfo *pURI = NULL;
748,749c781,784
<     if ((unsolResponseIndex < 0)
<         || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
---
>     if ((unsolResponse < RIL_UNSOL_RESPONSE_BASE)
>         || (unsolResponse > RIL_UNSOL_RESPONSE_LAST
>                 && unsolResponse < RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE)
>         || (unsolResponse > RIL_UNSOL_RESPONSE_RADIO_CONFIG_LAST)) {
753a789,798
>     if (unsolResponse >= RIL_UNSOL_RESPONSE_BASE
>             && unsolResponse <= RIL_UNSOL_RESPONSE_LAST) {
>         unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
>         pURI = &(s_unsolResponses[unsolResponseIndex]);
>     } else if (unsolResponse >= RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE
>             && unsolResponse <= RIL_UNSOL_RESPONSE_RADIO_CONFIG_LAST) {
>         unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE;
>         pURI = &(s_configUnsolResponses[unsolResponseIndex]);
>     }
> 
780c825
<     pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) soc_id);
---
>     pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock((int) soc_id);
787c832
<         radio::setNitzTimeReceived((int) soc_id, android::elapsedRealtime());
---
>         radio_1_6::setNitzTimeReceived((int) soc_id, android::elapsedRealtime());
793,796c838,842
<     if (s_unsolResponses[unsolResponseIndex].responseFunction) {
<         ret = s_unsolResponses[unsolResponseIndex].responseFunction(
<                 (int) soc_id, responseType, 0, RIL_E_SUCCESS, const_cast<void*>(data),
<                 datalen);
---
>     if (pURI != NULL && pURI->responseFunction != NULL) {
>         ret = pURI->responseFunction((int) soc_id, responseType, 0, RIL_E_SUCCESS,
>                 const_cast<void*>(data), datalen);
>     } else {
>         RLOGW("No call responseFunction defined for UNSOLICITED");
1070a1117,1119
>         case RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS: return "RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS";
>         case RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS: return "RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS";
>         case RIL_REQUEST_START_NETWORK_SCAN: return "RIL_REQUEST_START_NETWORK_SCAN";
1083a1133,1134
>         case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
>         case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
1161a1213,1224
>         case RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA: return "SET_SIGNAL_STRENGTH_REPORTING_CRITERIA";
>         case RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA: return "SET_LINK_CAPACITY_REPORTING_CRITERIA";
>         case RIL_REQUEST_ENABLE_UICC_APPLICATIONS: return "ENABLE_UICC_APPLICATIONS";
>         case RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED: return "ARE_UICC_APPLICATIONS_ENABLED";
>         case RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION: return "ENTER_SIM_DEPERSONALIZATION";
>         case RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE: return "CDMA_SEND_SMS_EXPECT_MORE";
>         case RIL_REQUEST_GET_BARRING_INFO: return "GET_BARRING_INFO";
>         case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP: return "SET_PREFERRED_NETWORK_TYPE_BITMAP";
>         case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP: return "GET_PREFERRED_NETWORK_TYPE_BITMAP";
>         case RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP: return "SET_ALLOWED_NETWORK_TYPES_BITMAP";
>         case RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP: return "GET_ALLOWED_NETWORK_TYPES_BITMAP";
>         case RIL_REQUEST_GET_SLICING_CONFIG: return "GET_SLICING_CONFIG";
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/ril_service.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/ril_service.cpp
19,22c19,24
< #include <android/hardware/radio/1.1/IRadio.h>
< #include <android/hardware/radio/1.1/IRadioResponse.h>
< #include <android/hardware/radio/1.1/IRadioIndication.h>
< #include <android/hardware/radio/1.1/types.h>
---
> #include <android/hardware/radio/1.6/IRadio.h>
> #include <android/hardware/radio/1.6/IRadioIndication.h>
> #include <android/hardware/radio/1.6/IRadioResponse.h>
> #include <android/hardware/radio/1.6/types.h>
> 
> #include <android/hardware/radio/deprecated/1.0/IOemHook.h>
28d29
< #include <telephony/ril_mcc.h>
37a39
> using namespace android::hardware::radio::deprecated::V1_0;
40a43
> using ::android::hardware::hidl_bitfield;
49a53,58
> using RegStateResultV1_6 = android::hardware::radio::V1_6::RegStateResult;
> using RegStateResultV1_5 = android::hardware::radio::V1_5::RegStateResult;
> using PhysicalChannelConfigV1_4 =
>     android::hardware::radio::V1_4::PhysicalChannelConfig;
> using RadioTechnologyV1_4 = android::hardware::radio::V1_4::RadioTechnology;
> 
62a72,77
> #ifdef OEM_HOOK_DISABLED
> constexpr bool kOemHookEnabled = false;
> #else
> constexpr bool kOemHookEnabled = true;
> #endif
> 
66c81,82
< struct RadioImpl;
---
> struct RadioImpl_1_6;
> struct OemHookImpl;
69c85,86
< sp<RadioImpl> radioService[SIM_COUNT];
---
> sp<RadioImpl_1_6> radioService[SIM_COUNT];
> sp<OemHookImpl> oemHookService[SIM_COUNT];
72a90
> volatile int32_t mCounterOemHook[SIM_COUNT];
74c92,93
< sp<RadioImpl> radioService[1];
---
> sp<RadioImpl_1_6> radioService[1];
> sp<OemHookImpl> oemHookService[1];
77a97
> volatile int32_t mCounterOemHook[1];
104a125,136
> void convertRilSignalStrengthToHal_1_4(void *response, size_t responseLen,
>         V1_4::SignalStrength& signalStrength);
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v11 *dcResponse,
>         ::android::hardware::radio::V1_4::SetupDataCallResult& dcResult);
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v12 *dcResponse,
>         ::android::hardware::radio::V1_5::SetupDataCallResult& dcResult);
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v12 *dcResponse,
>         ::android::hardware::radio::V1_6::SetupDataCallResult& dcResult);
> 
108a141
> void convertRilCellInfoListToHal_1_2(void *response, size_t responseLen, hidl_vec<V1_2::CellInfo>& records);
110c143,150
< struct RadioImpl : public V1_1::IRadio {
---
> void populateResponseInfo(RadioResponseInfo& responseInfo, int serial, int responseType,
>                          RIL_Errno e);
> 
> void populateResponseInfo_1_6(
>     ::android::hardware::radio::V1_6::RadioResponseInfo &responseInfo,
>     int serial, int responseType, RIL_Errno e);
> 
> struct RadioImpl_1_6 : public V1_6::IRadio {
111a152
>     V1_1::CardPowerState mSimCardPowerState;
115a157,166
>     sp<V1_2::IRadioResponse> mRadioResponseV1_2;
>     sp<V1_2::IRadioIndication> mRadioIndicationV1_2;
>     sp<V1_3::IRadioResponse> mRadioResponseV1_3;
>     sp<V1_3::IRadioIndication> mRadioIndicationV1_3;
>     sp<V1_4::IRadioResponse> mRadioResponseV1_4;
>     sp<V1_4::IRadioIndication> mRadioIndicationV1_4;
>     sp<V1_5::IRadioResponse> mRadioResponseV1_5;
>     sp<V1_5::IRadioIndication> mRadioIndicationV1_5;
>     sp<V1_6::IRadioResponse> mRadioResponseV1_6;
>     sp<V1_6::IRadioIndication> mRadioIndicationV1_6;
145a197,198
>     Return<void> getCurrentCalls_1_6(int32_t serial);
> 
166a220,221
>     Return<void> getSignalStrength_1_6(int32_t serial);
> 
372a428,429
>     Return<void> getCellInfoList_1_6(int32_t serial);
> 
444a502,503
>     Return<void> setSimCardPower_1_6(int32_t serial,
>             const V1_1::CardPowerState state);
451a511,669
> 
>     // Methods from ::android::hardware::radio::V1_2::IRadio follow.
>     Return<void> startNetworkScan_1_2(int32_t serial,
>             const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
>     Return<void> setIndicationFilter_1_2(int32_t serial,
>             hidl_bitfield<::android::hardware::radio::V1_2::IndicationFilter> indicationFilter);
>     Return<void> setSignalStrengthReportingCriteria(int32_t serial, int32_t hysteresisMs,
>             int32_t hysteresisDb, const hidl_vec<int32_t>& thresholdsDbm,
>             ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
>     Return<void> setLinkCapacityReportingCriteria(int32_t serial, int32_t hysteresisMs,
>             int32_t hysteresisDlKbps, int32_t hysteresisUlKbps,
>             const hidl_vec<int32_t>& thresholdsDownlinkKbps,
>             const hidl_vec<int32_t>& thresholdsUplinkKbps,
>             ::android::hardware::radio::V1_2::AccessNetwork accessNetwork);
>     Return<void> setupDataCall_1_2(int32_t serial,
>             ::android::hardware::radio::V1_2::AccessNetwork accessNetwork,
>             const ::android::hardware::radio::V1_0::DataProfileInfo& dataProfileInfo,
>             bool modemCognitive, bool roamingAllowed, bool isRoaming,
>             ::android::hardware::radio::V1_2::DataRequestReason reason,
>             const hidl_vec<hidl_string>& addresses, const hidl_vec<hidl_string>& dnses);
>     Return<void> deactivateDataCall_1_2(int32_t serial, int32_t cid,
>             ::android::hardware::radio::V1_2::DataRequestReason reason);
> 
>     // Methods from ::android::hardware::radio::V1_3::IRadio follow.
>     Return<void> setSystemSelectionChannels(int32_t serial, bool specifyChannels,
>             const hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& specifiers);
>     Return<void> enableModem(int32_t serial, bool on);
>     Return<void> getModemStackStatus(int32_t serial);
> 
>     // Methods from ::android::hardware::radio::V1_4::IRadio follow.
>     Return<void> setupDataCall_1_4(int32_t serial,
>             ::android::hardware::radio::V1_4::AccessNetwork accessNetwork,
>             const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo,
>             bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason,
>             const hidl_vec<hidl_string>& addresses, const hidl_vec<hidl_string>& dnses);
>     Return<void> setInitialAttachApn_1_4(int32_t serial,
>             const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo);
>     Return<void> setDataProfile_1_4(int32_t serial,
>             const hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& profiles);
>     Return<void> emergencyDial(int32_t serial,
>             const ::android::hardware::radio::V1_0::Dial& dialInfo,
>             hidl_bitfield<android::hardware::radio::V1_4::EmergencyServiceCategory> categories,
>             const hidl_vec<hidl_string>& urns,
>             ::android::hardware::radio::V1_4::EmergencyCallRouting routing,
>             bool fromEmergencyDialer, bool isTesting);
>     Return<void> emergencyDial_1_6(int32_t serial,
>             const ::android::hardware::radio::V1_0::Dial& dialInfo,
>             hidl_bitfield<android::hardware::radio::V1_4::EmergencyServiceCategory> categories,
>             const hidl_vec<hidl_string>& urns,
>             ::android::hardware::radio::V1_4::EmergencyCallRouting routing,
>             bool fromEmergencyDialer, bool isTesting);
>     Return<void> startNetworkScan_1_4(int32_t serial,
>             const ::android::hardware::radio::V1_2::NetworkScanRequest& request);
>     Return<void> getPreferredNetworkTypeBitmap(int32_t serial);
>     Return<void> setPreferredNetworkTypeBitmap(
>             int32_t serial, hidl_bitfield<RadioAccessFamily> networkTypeBitmap);
>     Return<void> setAllowedCarriers_1_4(int32_t serial,
>             const ::android::hardware::radio::V1_4::CarrierRestrictionsWithPriority& carriers,
>             ::android::hardware::radio::V1_4::SimLockMultiSimPolicy multiSimPolicy);
>     Return<void> getAllowedCarriers_1_4(int32_t serial);
>     Return<void> getSignalStrength_1_4(int32_t serial);
> 
>     // Methods from ::android::hardware::radio::V1_5::IRadio follow.
>     Return<void> setSignalStrengthReportingCriteria_1_5(int32_t serial,
>             const ::android::hardware::radio::V1_5::SignalThresholdInfo& signalThresholdInfo,
>             const ::android::hardware::radio::V1_5::AccessNetwork accessNetwork);
>     Return<void> setLinkCapacityReportingCriteria_1_5(int32_t serial, int32_t hysteresisMs,
>             int32_t hysteresisDlKbps, int32_t hysteresisUlKbps,
>             const hidl_vec<int32_t>& thresholdsDownlinkKbps,
>             const hidl_vec<int32_t>& thresholdsUplinkKbps,
>             V1_5::AccessNetwork accessNetwork);
>     Return<void> enableUiccApplications(int32_t serial, bool detach);
>     Return<void> areUiccApplicationsEnabled(int32_t serial);
>     Return<void> setSystemSelectionChannels_1_5(int32_t serial, bool specifyChannels,
>             const hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier>& specifiers);
>     Return<void> startNetworkScan_1_5(int32_t serial,
>             const ::android::hardware::radio::V1_5::NetworkScanRequest& request);
>     Return<void> setupDataCall_1_5(int32_t serial,
>             ::android::hardware::radio::V1_5::AccessNetwork accessNetwork,
>             const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo,
>             bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason,
>             const hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses,
>             const hidl_vec<hidl_string>& dnses);
>     Return<void> setInitialAttachApn_1_5(int32_t serial,
>             const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo);
>     Return<void> setDataProfile_1_5(int32_t serial,
>             const hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& profiles);
>     Return<void> setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall,
>             bool preferredForEmergencyCall);
>     Return<void> setIndicationFilter_1_5(int32_t serial,
>             hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter);
>     Return<void> getBarringInfo(int32_t serial);
>     Return<void> getVoiceRegistrationState_1_5(int32_t serial);
>     Return<void> getDataRegistrationState_1_5(int32_t serial);
>     Return<void> setNetworkSelectionModeManual_1_5(int32_t serial,
>             const hidl_string& operatorNumeric, V1_5::RadioAccessNetworks ran);
>     Return<void> sendCdmaSmsExpectMore(int32_t serial, const CdmaSmsMessage& sms);
>     Return<void> supplySimDepersonalization(int32_t serial, V1_5::PersoSubstate persoType,
>                                             const hidl_string& controlKey);
>     Return<void> setNrDualConnectivityState(int32_t serial,
>             V1_6::NrDualConnectivityState nrDualConnectivityState);
>     Return<void> isNrDualConnectivityEnabled(int32_t serial);
> 
>     // Methods from ::android::hardware::radio::V1_6::IRadio follow.
>     Return<void> getDataCallList_1_6(int32_t serial);
>     Return<void> setupDataCall_1_6(int32_t serial,
>             ::android::hardware::radio::V1_5::AccessNetwork accessNetwork,
>             const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo,
>             bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason reason,
>             const hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& addresses,
>             const hidl_vec<hidl_string>& dnses,
>             int32_t pduSessionId,
>             const ::android::hardware::radio::V1_6::OptionalSliceInfo& sliceInfo,
>             const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& trafficDescriptor,
>             bool matchAllRuleAllowed);
>     Return<void> sendSms_1_6(int32_t serial, const GsmSmsMessage& message);
>     Return<void> sendSmsExpectMore_1_6(int32_t serial, const GsmSmsMessage& message);
>     Return<void> sendCdmaSms_1_6(int32_t serial, const CdmaSmsMessage& sms);
>     Return<void> sendCdmaSmsExpectMore_1_6(int32_t serial, const CdmaSmsMessage& sms);
>     Return<void> setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall,
>             bool preferredForEmergencyCall);
>     Return<void> allocatePduSessionId(int32_t serial);
>     Return<void> releasePduSessionId(int32_t serial, int32_t id);
>     Return<void> startHandover(int32_t serial, int32_t callId);
>     Return<void> cancelHandover(int32_t serial, int32_t callId);
>     Return<void> setAllowedNetworkTypesBitmap(uint32_t serial,
>             hidl_bitfield<::android::hardware::radio::V1_4::RadioAccessFamily> networkTypeBitmap);
>     Return<void> setDataThrottling(int32_t serial,
>             V1_6::DataThrottlingAction dataThrottlingAction,
>             int64_t completionDurationMillis);
>     Return<void> getSystemSelectionChannels(int32_t serial);
>     Return<void> getVoiceRegistrationState_1_6(int32_t serial);
>     Return<void> getDataRegistrationState_1_6(int32_t serial);
>     Return<void> getAllowedNetworkTypesBitmap(int32_t serial);
>     Return<void> getSlicingConfig(int32_t serial);
>     Return<void> setCarrierInfoForImsiEncryption_1_6(
>             int32_t serial,
>             const ::android::hardware::radio::V1_6::ImsiEncryptionInfo& imsiEncryptionInfo);
>     Return<void> getSimPhonebookRecords(int32_t serial);
>     Return<void> getSimPhonebookCapacity(int32_t serial);
>     Return<void> updateSimPhonebookRecords(
>             int32_t serial,
>             const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo);
> };
> 
> struct OemHookImpl : public IOemHook {
>     int32_t mSlotId;
>     sp<IOemHookResponse> mOemHookResponse;
>     sp<IOemHookIndication> mOemHookIndication;
> 
>     Return<void> setResponseFunctions(
>             const ::android::sp<IOemHookResponse>& oemHookResponse,
>             const ::android::sp<IOemHookIndication>& oemHookIndication);
> 
>     Return<void> sendRequestRaw(int32_t serial,
>             const ::android::hardware::hidl_vec<uint8_t>& data);
> 
>     Return<void> sendRequestStrings(int32_t serial,
>             const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& data);
735,736c953,954
<         int counter = mCounterRadio[slotId];
<         pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(slotId);
---
>         int counter = isRadioService ? mCounterRadio[slotId] : mCounterOemHook[slotId];
>         pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock(slotId);
745,750c963,981
<         if (counter == mCounterRadio[slotId]) {
<             radioService[slotId]->mRadioResponse = NULL;
<             radioService[slotId]->mRadioIndication = NULL;
<             radioService[slotId]->mRadioResponseV1_1 = NULL;
<             radioService[slotId]->mRadioIndicationV1_1 = NULL;
<             mCounterRadio[slotId]++;
---
>         if (counter == (isRadioService ? mCounterRadio[slotId] : mCounterOemHook[slotId])) {
>             if (isRadioService) {
>                 radioService[slotId]->mRadioResponse = NULL;
>                 radioService[slotId]->mRadioIndication = NULL;
>                 radioService[slotId]->mRadioResponseV1_2 = NULL;
>                 radioService[slotId]->mRadioIndicationV1_2 = NULL;
>                 radioService[slotId]->mRadioResponseV1_3 = NULL;
>                 radioService[slotId]->mRadioIndicationV1_3 = NULL;
>                 radioService[slotId]->mRadioResponseV1_4 = NULL;
>                 radioService[slotId]->mRadioIndicationV1_4 = NULL;
>                 radioService[slotId]->mRadioResponseV1_5 = NULL;
>                 radioService[slotId]->mRadioIndicationV1_5 = NULL;
>                 radioService[slotId]->mRadioResponseV1_6 = NULL;
>                 radioService[slotId]->mRadioIndicationV1_6 = NULL;
>             } else {
>                 oemHookService[slotId]->mOemHookResponse = NULL;
>                 oemHookService[slotId]->mOemHookIndication = NULL;
>             }
>             isRadioService ? mCounterRadio[slotId]++ : mCounterOemHook[slotId]++;
766c997
< void RadioImpl::checkReturnStatus(Return<void>& ret) {
---
> void RadioImpl_1_6::checkReturnStatus(Return<void>& ret) {
770c1001
< Return<void> RadioImpl::setResponseFunctions(
---
> Return<void> RadioImpl_1_6::setResponseFunctions(
775c1006
<     pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(mSlotId);
---
>     pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock(mSlotId);
780a1012,1047
> 
>    mRadioResponseV1_6 = V1_6::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
>    mRadioIndicationV1_6 = V1_6::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
>    if (mRadioResponseV1_6 == nullptr || mRadioIndicationV1_6 == nullptr) {
>        mRadioResponseV1_6 = nullptr;
>        mRadioIndicationV1_6 = nullptr;
>    }
> 
>    mRadioResponseV1_5 = V1_5::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
>    mRadioIndicationV1_5 = V1_5::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
>    if (mRadioResponseV1_5 == nullptr || mRadioIndicationV1_5 == nullptr) {
>        mRadioResponseV1_5 = nullptr;
>        mRadioIndicationV1_5 = nullptr;
>    }
> 
>     mRadioResponseV1_4 = V1_4::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
>     mRadioIndicationV1_4 = V1_4::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
>     if (mRadioResponseV1_4 == nullptr || mRadioIndicationV1_4 == nullptr) {
>         mRadioResponseV1_4 = nullptr;
>         mRadioIndicationV1_4 = nullptr;
>     }
> 
>     mRadioResponseV1_3 = V1_3::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
>     mRadioIndicationV1_3 = V1_3::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
>     if (mRadioResponseV1_3 == nullptr || mRadioIndicationV1_3 == nullptr) {
>         mRadioResponseV1_3 = nullptr;
>         mRadioIndicationV1_3 = nullptr;
>     }
> 
>     mRadioResponseV1_2 = V1_2::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
>     mRadioIndicationV1_2 = V1_2::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
>     if (mRadioResponseV1_2 == nullptr || mRadioIndicationV1_2 == nullptr) {
>         mRadioResponseV1_2 = nullptr;
>         mRadioIndicationV1_2 = nullptr;
>     }
> 
799c1066
< Return<void> RadioImpl::getIccCardStatus(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getIccCardStatus(int32_t serial) {
807c1074
< Return<void> RadioImpl::supplyIccPinForApp(int32_t serial, const hidl_string& pin,
---
> Return<void> RadioImpl_1_6::supplyIccPinForApp(int32_t serial, const hidl_string& pin,
817c1084
< Return<void> RadioImpl::supplyIccPukForApp(int32_t serial, const hidl_string& puk,
---
> Return<void> RadioImpl_1_6::supplyIccPukForApp(int32_t serial, const hidl_string& puk,
827c1094
< Return<void> RadioImpl::supplyIccPin2ForApp(int32_t serial, const hidl_string& pin2,
---
> Return<void> RadioImpl_1_6::supplyIccPin2ForApp(int32_t serial, const hidl_string& pin2,
837c1104
< Return<void> RadioImpl::supplyIccPuk2ForApp(int32_t serial, const hidl_string& puk2,
---
> Return<void> RadioImpl_1_6::supplyIccPuk2ForApp(int32_t serial, const hidl_string& puk2,
847c1114
< Return<void> RadioImpl::changeIccPinForApp(int32_t serial, const hidl_string& oldPin,
---
> Return<void> RadioImpl_1_6::changeIccPinForApp(int32_t serial, const hidl_string& oldPin,
857c1124
< Return<void> RadioImpl::changeIccPin2ForApp(int32_t serial, const hidl_string& oldPin2,
---
> Return<void> RadioImpl_1_6::changeIccPin2ForApp(int32_t serial, const hidl_string& oldPin2,
867c1134
< Return<void> RadioImpl::supplyNetworkDepersonalization(int32_t serial,
---
> Return<void> RadioImpl_1_6::supplyNetworkDepersonalization(int32_t serial,
877c1144
< Return<void> RadioImpl::getCurrentCalls(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCurrentCalls(int32_t serial) {
885c1152,1160
< Return<void> RadioImpl::dial(int32_t serial, const Dial& dialInfo) {
---
> Return<void> RadioImpl_1_6::getCurrentCalls_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getCurrentCalls_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CURRENT_CALLS);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::dial(int32_t serial, const Dial& dialInfo) {
927c1202
< Return<void> RadioImpl::getImsiForApp(int32_t serial, const hidl_string& aid) {
---
> Return<void> RadioImpl_1_6::getImsiForApp(int32_t serial, const hidl_string& aid) {
936c1211
< Return<void> RadioImpl::hangup(int32_t serial, int32_t gsmIndex) {
---
> Return<void> RadioImpl_1_6::hangup(int32_t serial, int32_t gsmIndex) {
944c1219
< Return<void> RadioImpl::hangupWaitingOrBackground(int32_t serial) {
---
> Return<void> RadioImpl_1_6::hangupWaitingOrBackground(int32_t serial) {
952c1227
< Return<void> RadioImpl::hangupForegroundResumeBackground(int32_t serial) {
---
> Return<void> RadioImpl_1_6::hangupForegroundResumeBackground(int32_t serial) {
960c1235
< Return<void> RadioImpl::switchWaitingOrHoldingAndActive(int32_t serial) {
---
> Return<void> RadioImpl_1_6::switchWaitingOrHoldingAndActive(int32_t serial) {
968c1243
< Return<void> RadioImpl::conference(int32_t serial) {
---
> Return<void> RadioImpl_1_6::conference(int32_t serial) {
976c1251
< Return<void> RadioImpl::rejectCall(int32_t serial) {
---
> Return<void> RadioImpl_1_6::rejectCall(int32_t serial) {
984c1259
< Return<void> RadioImpl::getLastCallFailCause(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getLastCallFailCause(int32_t serial) {
992c1267
< Return<void> RadioImpl::getSignalStrength(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getSignalStrength(int32_t serial) {
1000c1275
< Return<void> RadioImpl::getVoiceRegistrationState(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getVoiceRegistrationState(int32_t serial) {
1008c1283
< Return<void> RadioImpl::getDataRegistrationState(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getDataRegistrationState(int32_t serial) {
1016c1291
< Return<void> RadioImpl::getOperator(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getOperator(int32_t serial) {
1024c1299,1300
< Return<void> RadioImpl::setRadioPower(int32_t serial, bool on) {
---
> Return<void> RadioImpl_1_6::setRadioPower(int32_t serial, bool on) {
> #if VDBG
1025a1302
> #endif
1030c1307
< Return<void> RadioImpl::sendDtmf(int32_t serial, const hidl_string& s) {
---
> Return<void> RadioImpl_1_6::sendDtmf(int32_t serial, const hidl_string& s) {
1038c1315,1324
< Return<void> RadioImpl::sendSms(int32_t serial, const GsmSmsMessage& message) {
---
> Return<void> RadioImpl_1_6::sendSms(int32_t serial, const GsmSmsMessage& message) {
> #if VDBG
>     RLOGD("sendSms: serial %d", serial);
> #endif
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS, false,
>             2, message.smscPdu.c_str(), message.pdu.c_str());
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::sendSms_1_6(int32_t serial, const GsmSmsMessage& message) {
1047c1333
< Return<void> RadioImpl::sendSMSExpectMore(int32_t serial, const GsmSmsMessage& message) {
---
> Return<void> RadioImpl_1_6::sendSMSExpectMore(int32_t serial, const GsmSmsMessage& message) {
1049c1335,1344
<     RLOGD("sendSMSExpectMore: serial %d", serial);
---
>     RLOGD("sendSmsExpectMore: serial %d", serial);
> #endif
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS_EXPECT_MORE, false,
>             2, message.smscPdu.c_str(), message.pdu.c_str());
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::sendSmsExpectMore_1_6(int32_t serial, const GsmSmsMessage& message) {
> #if VDBG
>     RLOGD("sendSmsExpectMore: serial %d", serial);
1074c1369
< Return<void> RadioImpl::setupDataCall(int32_t serial, RadioTechnology radioTechnology,
---
> Return<void> RadioImpl_1_6::setupDataCall(int32_t serial, RadioTechnology radioTechnology,
1093c1388
<     } else if (s_vendorFunctions->version >= 15) {
---
>     } else if (s_vendorFunctions->version == 15) {
1118a1414,1441
>     } else if (s_vendorFunctions->version >= 16) {
>         char *mvnoTypeStr = NULL;
>         if (!convertMvnoTypeToString(dataProfileInfo.mvnoType, mvnoTypeStr)) {
>             RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                     RIL_REQUEST_SETUP_DATA_CALL);
>             if (pRI != NULL) {
>                 sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>             }
>             return Void();
>         }
>         dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 16,
>             std::to_string((int) radioTechnology + 2).c_str(),
>             std::to_string((int) dataProfileInfo.profileId).c_str(),
>             dataProfileInfo.apn.c_str(),
>             dataProfileInfo.user.c_str(),
>             dataProfileInfo.password.c_str(),
>             std::to_string((int) dataProfileInfo.authType).c_str(),
>             dataProfileInfo.protocol.c_str(),
>             dataProfileInfo.roamingProtocol.c_str(),
>             std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
>             std::to_string(dataProfileInfo.bearerBitmap).c_str(),
>             modemCognitive ? "1" : "0",
>             std::to_string(dataProfileInfo.mtu).c_str(),
>             mvnoTypeStr,
>             dataProfileInfo.mvnoMatchData.c_str(),
>             roamingAllowed ? "1" : "0",
>             "-1",
>             "");
1130c1453
< Return<void> RadioImpl::iccIOForApp(int32_t serial, const IccIo& iccIo) {
---
> Return<void> RadioImpl_1_6::iccIOForApp(int32_t serial, const IccIo& iccIo) {
1172c1495
< Return<void> RadioImpl::sendUssd(int32_t serial, const hidl_string& ussd) {
---
> Return<void> RadioImpl_1_6::sendUssd(int32_t serial, const hidl_string& ussd) {
1180c1503
< Return<void> RadioImpl::cancelPendingUssd(int32_t serial) {
---
> Return<void> RadioImpl_1_6::cancelPendingUssd(int32_t serial) {
1188c1511
< Return<void> RadioImpl::getClir(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getClir(int32_t serial) {
1196c1519
< Return<void> RadioImpl::setClir(int32_t serial, int32_t status) {
---
> Return<void> RadioImpl_1_6::setClir(int32_t serial, int32_t status) {
1204c1527
< Return<void> RadioImpl::getCallForwardStatus(int32_t serial, const CallForwardInfo& callInfo) {
---
> Return<void> RadioImpl_1_6::getCallForwardStatus(int32_t serial, const CallForwardInfo& callInfo) {
1213c1536
< Return<void> RadioImpl::setCallForward(int32_t serial, const CallForwardInfo& callInfo) {
---
> Return<void> RadioImpl_1_6::setCallForward(int32_t serial, const CallForwardInfo& callInfo) {
1222c1545
< Return<void> RadioImpl::getCallWaiting(int32_t serial, int32_t serviceClass) {
---
> Return<void> RadioImpl_1_6::getCallWaiting(int32_t serial, int32_t serviceClass) {
1230c1553
< Return<void> RadioImpl::setCallWaiting(int32_t serial, bool enable, int32_t serviceClass) {
---
> Return<void> RadioImpl_1_6::setCallWaiting(int32_t serial, bool enable, int32_t serviceClass) {
1239c1562
< Return<void> RadioImpl::acknowledgeLastIncomingGsmSms(int32_t serial,
---
> Return<void> RadioImpl_1_6::acknowledgeLastIncomingGsmSms(int32_t serial,
1249c1572
< Return<void> RadioImpl::acceptCall(int32_t serial) {
---
> Return<void> RadioImpl_1_6::acceptCall(int32_t serial) {
1257c1580
< Return<void> RadioImpl::deactivateDataCall(int32_t serial,
---
> Return<void> RadioImpl_1_6::deactivateDataCall(int32_t serial,
1267c1590
< Return<void> RadioImpl::getFacilityLockForApp(int32_t serial, const hidl_string& facility,
---
> Return<void> RadioImpl_1_6::getFacilityLockForApp(int32_t serial, const hidl_string& facility,
1279c1602
< Return<void> RadioImpl::setFacilityLockForApp(int32_t serial, const hidl_string& facility,
---
> Return<void> RadioImpl_1_6::setFacilityLockForApp(int32_t serial, const hidl_string& facility,
1291c1614
< Return<void> RadioImpl::setBarringPassword(int32_t serial, const hidl_string& facility,
---
> Return<void> RadioImpl_1_6::setBarringPassword(int32_t serial, const hidl_string& facility,
1302c1625
< Return<void> RadioImpl::getNetworkSelectionMode(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getNetworkSelectionMode(int32_t serial) {
1310c1633
< Return<void> RadioImpl::setNetworkSelectionModeAutomatic(int32_t serial) {
---
> Return<void> RadioImpl_1_6::setNetworkSelectionModeAutomatic(int32_t serial) {
1318c1641
< Return<void> RadioImpl::setNetworkSelectionModeManual(int32_t serial,
---
> Return<void> RadioImpl_1_6::setNetworkSelectionModeManual(int32_t serial,
1323,1324c1646,1660
<     dispatchString(serial, mSlotId, RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
<             operatorNumeric.c_str());
---
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>         RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_NetworkOperator networkOperator = {};
> 
>     networkOperator.act = UNKNOWN;
>     if (!copyHidlStringToRil(&networkOperator.operatorNumeric, operatorNumeric, pRI)) {
>         return Void();
>     }
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &networkOperator,
>         sizeof(networkOperator), pRI, mSlotId);
> 
1328c1664
< Return<void> RadioImpl::getAvailableNetworks(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getAvailableNetworks(int32_t serial) {
1336c1672
< Return<void> RadioImpl::startNetworkScan(int32_t serial, const V1_1::NetworkScanRequest& request) {
---
> Return<void> RadioImpl_1_6::startNetworkScan(int32_t serial, const V1_1::NetworkScanRequest& request) {
1402c1738
< Return<void> RadioImpl::stopNetworkScan(int32_t serial) {
---
> Return<void> RadioImpl_1_6::stopNetworkScan(int32_t serial) {
1410c1746
< Return<void> RadioImpl::startDtmf(int32_t serial, const hidl_string& s) {
---
> Return<void> RadioImpl_1_6::startDtmf(int32_t serial, const hidl_string& s) {
1419c1755
< Return<void> RadioImpl::stopDtmf(int32_t serial) {
---
> Return<void> RadioImpl_1_6::stopDtmf(int32_t serial) {
1427c1763
< Return<void> RadioImpl::getBasebandVersion(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getBasebandVersion(int32_t serial) {
1435c1771
< Return<void> RadioImpl::separateConnection(int32_t serial, int32_t gsmIndex) {
---
> Return<void> RadioImpl_1_6::separateConnection(int32_t serial, int32_t gsmIndex) {
1443c1779
< Return<void> RadioImpl::setMute(int32_t serial, bool enable) {
---
> Return<void> RadioImpl_1_6::setMute(int32_t serial, bool enable) {
1451c1787
< Return<void> RadioImpl::getMute(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getMute(int32_t serial) {
1459c1795
< Return<void> RadioImpl::getClip(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getClip(int32_t serial) {
1467c1803
< Return<void> RadioImpl::getDataCallList(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getDataCallList(int32_t serial) {
1475c1811,1900
< Return<void> RadioImpl::setSuppServiceNotifications(int32_t serial, bool enable) {
---
> Return<void> RadioImpl_1_6::getDataCallList_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getDataCallList_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_DATA_CALL_LIST);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::emergencyDial_1_6(int32_t serial,
>         const ::android::hardware::radio::V1_0::Dial& dialInfo,
>         hidl_bitfield<android::hardware::radio::V1_4::EmergencyServiceCategory> categories,
>         const hidl_vec<hidl_string>&  urns ,
>         ::android::hardware::radio::V1_4::EmergencyCallRouting routing,
>         bool fromEmergencyDialer, bool /* isTesting */) {
> #if VDBG
>     RLOGD("emergencyDial: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_EMERGENCY_DIAL);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_EmergencyDial eccDial = {};
>     RIL_Dial& dial = eccDial.dialInfo;
>     RIL_UUS_Info uusInfo = {};
> 
>     if (!copyHidlStringToRil(&dial.address, dialInfo.address, pRI)) {
>         return Void();
>     }
>     dial.clir = (int) dialInfo.clir;
> 
>     if (dialInfo.uusInfo.size() != 0) {
>         uusInfo.uusType = (RIL_UUS_Type) dialInfo.uusInfo[0].uusType;
>         uusInfo.uusDcs = (RIL_UUS_DCS) dialInfo.uusInfo[0].uusDcs;
> 
>         if (dialInfo.uusInfo[0].uusData.size() == 0) {
>             uusInfo.uusData = NULL;
>             uusInfo.uusLength = 0;
>         } else {
>             if (!copyHidlStringToRil(&uusInfo.uusData, dialInfo.uusInfo[0].uusData, pRI)) {
>                 memsetAndFreeStrings(1, dial.address);
>                 return Void();
>             }
>             uusInfo.uusLength = dialInfo.uusInfo[0].uusData.size();
>         }
> 
>         dial.uusInfo = &uusInfo;
>     }
> 
>     eccDial.urnsNumber = urns.size();
>     if (eccDial.urnsNumber != 0) {
>         char **ppUrns = (char **)calloc(eccDial.urnsNumber, sizeof(char *));
>         if (ppUrns == NULL) {
>             RLOGE("Memory allocation failed for request %s",
>                     requestToString(pRI->pCI->requestNumber));
>             sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>             memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>             return Void();
>         }
>         for (uint32_t i = 0; i < eccDial.urnsNumber; i++) {
>             if (!copyHidlStringToRil(&ppUrns[i], hidl_string(urns[i]), pRI)) {
>                 for (uint32_t j = 0; j < i; j++) {
>                     memsetAndFreeStrings(1, ppUrns[j]);
>                 }
>                 memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>                 free(ppUrns);
>                 return Void();
>             }
>         }
>         eccDial.urns = ppUrns;
>     }
> 
>     eccDial.categories = (RIL_EmergencyServiceCategory)categories;
>     eccDial.routing = (RIL_EmergencyCallRouting)routing;
>     eccDial.fromEmergencyDialer = fromEmergencyDialer;
> 
>     CALL_ONREQUEST(RIL_REQUEST_EMERGENCY_DIAL, &eccDial, sizeof(RIL_EmergencyDial), pRI, mSlotId);
> 
>     memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>     if (eccDial.urns != NULL) {
>         for (size_t i = 0; i < eccDial.urnsNumber; i++) {
>             memsetAndFreeStrings(1, eccDial.urns[i]);
>         }
>         free(eccDial.urns);
>     }
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setSuppServiceNotifications(int32_t serial, bool enable) {
1484c1909
< Return<void> RadioImpl::writeSmsToSim(int32_t serial, const SmsWriteArgs& smsWriteArgs) {
---
> Return<void> RadioImpl_1_6::writeSmsToSim(int32_t serial, const SmsWriteArgs& smsWriteArgs) {
1512c1937
< Return<void> RadioImpl::deleteSmsOnSim(int32_t serial, int32_t index) {
---
> Return<void> RadioImpl_1_6::deleteSmsOnSim(int32_t serial, int32_t index) {
1520c1945
< Return<void> RadioImpl::setBandMode(int32_t serial, RadioBandMode mode) {
---
> Return<void> RadioImpl_1_6::setBandMode(int32_t serial, RadioBandMode mode) {
1528c1953
< Return<void> RadioImpl::getAvailableBandModes(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getAvailableBandModes(int32_t serial) {
1536c1961
< Return<void> RadioImpl::sendEnvelope(int32_t serial, const hidl_string& command) {
---
> Return<void> RadioImpl_1_6::sendEnvelope(int32_t serial, const hidl_string& command) {
1545c1970
< Return<void> RadioImpl::sendTerminalResponseToSim(int32_t serial,
---
> Return<void> RadioImpl_1_6::sendTerminalResponseToSim(int32_t serial,
1555c1980
< Return<void> RadioImpl::handleStkCallSetupRequestFromSim(int32_t serial, bool accept) {
---
> Return<void> RadioImpl_1_6::handleStkCallSetupRequestFromSim(int32_t serial, bool accept) {
1564c1989
< Return<void> RadioImpl::explicitCallTransfer(int32_t serial) {
---
> Return<void> RadioImpl_1_6::explicitCallTransfer(int32_t serial) {
1572c1997
< Return<void> RadioImpl::setPreferredNetworkType(int32_t serial, PreferredNetworkType nwType) {
---
> Return<void> RadioImpl_1_6::setPreferredNetworkType(int32_t serial, PreferredNetworkType nwType) {
1580c2005
< Return<void> RadioImpl::getPreferredNetworkType(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getPreferredNetworkType(int32_t serial) {
1588c2013
< Return<void> RadioImpl::getNeighboringCids(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getNeighboringCids(int32_t serial) {
1596c2021
< Return<void> RadioImpl::setLocationUpdates(int32_t serial, bool enable) {
---
> Return<void> RadioImpl_1_6::setLocationUpdates(int32_t serial, bool enable) {
1604c2029
< Return<void> RadioImpl::setCdmaSubscriptionSource(int32_t serial, CdmaSubscriptionSource cdmaSub) {
---
> Return<void> RadioImpl_1_6::setCdmaSubscriptionSource(int32_t serial, CdmaSubscriptionSource cdmaSub) {
1612c2037
< Return<void> RadioImpl::setCdmaRoamingPreference(int32_t serial, CdmaRoamingType type) {
---
> Return<void> RadioImpl_1_6::setCdmaRoamingPreference(int32_t serial, CdmaRoamingType type) {
1620c2045
< Return<void> RadioImpl::getCdmaRoamingPreference(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCdmaRoamingPreference(int32_t serial) {
1628c2053
< Return<void> RadioImpl::setTTYMode(int32_t serial, TtyMode mode) {
---
> Return<void> RadioImpl_1_6::setTTYMode(int32_t serial, TtyMode mode) {
1636c2061
< Return<void> RadioImpl::getTTYMode(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getTTYMode(int32_t serial) {
1644c2069
< Return<void> RadioImpl::setPreferredVoicePrivacy(int32_t serial, bool enable) {
---
> Return<void> RadioImpl_1_6::setPreferredVoicePrivacy(int32_t serial, bool enable) {
1653c2078
< Return<void> RadioImpl::getPreferredVoicePrivacy(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getPreferredVoicePrivacy(int32_t serial) {
1661c2086
< Return<void> RadioImpl::sendCDMAFeatureCode(int32_t serial, const hidl_string& featureCode) {
---
> Return<void> RadioImpl_1_6::sendCDMAFeatureCode(int32_t serial, const hidl_string& featureCode) {
1670c2095
< Return<void> RadioImpl::sendBurstDtmf(int32_t serial, const hidl_string& dtmf, int32_t on,
---
> Return<void> RadioImpl_1_6::sendBurstDtmf(int32_t serial, const hidl_string& dtmf, int32_t on,
1712c2137
< Return<void> RadioImpl::sendCdmaSms(int32_t serial, const CdmaSmsMessage& sms) {
---
> Return<void> RadioImpl_1_6::sendCdmaSms(int32_t serial, const CdmaSmsMessage& sms) {
1728c2153,2169
< Return<void> RadioImpl::acknowledgeLastIncomingCdmaSms(int32_t serial, const CdmaSmsAck& smsAck) {
---
> Return<void> RadioImpl_1_6::sendCdmaSms_1_6(int32_t serial, const CdmaSmsMessage& sms) {
> #if VDBG
>     RLOGD("sendCdmaSms: serial %d", serial);
> #endif
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_CDMA_SEND_SMS);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_CDMA_SMS_Message rcsm = {};
>     constructCdmaSms(rcsm, sms);
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm), pRI, mSlotId);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::acknowledgeLastIncomingCdmaSms(int32_t serial, const CdmaSmsAck& smsAck) {
1746c2187
< Return<void> RadioImpl::getGsmBroadcastConfig(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getGsmBroadcastConfig(int32_t serial) {
1754c2195
< Return<void> RadioImpl::setGsmBroadcastConfig(int32_t serial,
---
> Return<void> RadioImpl_1_6::setGsmBroadcastConfig(int32_t serial,
1766c2207
<     uint32_t num = configInfo.size();
---
>     int num = configInfo.size();
1773,1778c2214,2215
<     auto gsmBci = new RIL_GSM_BroadcastSmsConfigInfo[num];
<     if (gsmBci == nullptr) {
<         sendErrorResponse(pRI, RIL_E_NO_MEMORY);
<         return Void();
<     }
<     std::vector<RIL_GSM_BroadcastSmsConfigInfo*> gsmBciPtrs(num);
---
>     RIL_GSM_BroadcastSmsConfigInfo gsmBci[num];
>     RIL_GSM_BroadcastSmsConfigInfo *gsmBciPtrs[num];
1780c2217
<     for (uint32_t i = 0 ; i < num ; i++ ) {
---
>     for (int i = 0 ; i < num ; i++ ) {
1789c2226
<     CALL_ONREQUEST(pRI->pCI->requestNumber, gsmBciPtrs.data(),
---
>     CALL_ONREQUEST(pRI->pCI->requestNumber, gsmBciPtrs,
1791,1792d2227
< 
<     delete []gsmBci;
1796c2231
< Return<void> RadioImpl::setGsmBroadcastActivation(int32_t serial, bool activate) {
---
> Return<void> RadioImpl_1_6::setGsmBroadcastActivation(int32_t serial, bool activate) {
1805c2240
< Return<void> RadioImpl::getCdmaBroadcastConfig(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCdmaBroadcastConfig(int32_t serial) {
1813c2248
< Return<void> RadioImpl::setCdmaBroadcastConfig(int32_t serial,
---
> Return<void> RadioImpl_1_6::setCdmaBroadcastConfig(int32_t serial,
1825c2260
<     uint32_t num = configInfo.size();
---
>     int num = configInfo.size();
1832,1838c2267,2270
<     auto cdmaBci = new RIL_CDMA_BroadcastSmsConfigInfo[num];
<     if (cdmaBci == nullptr) {
<         sendErrorResponse(pRI, RIL_E_NO_MEMORY);
<         return Void();
<     }
<     std::vector<RIL_CDMA_BroadcastSmsConfigInfo*> cdmaBciPtrs(num);
<     for (uint32_t i = 0 ; i < num ; i++ ) {
---
>     RIL_CDMA_BroadcastSmsConfigInfo cdmaBci[num];
>     RIL_CDMA_BroadcastSmsConfigInfo *cdmaBciPtrs[num];
> 
>     for (int i = 0 ; i < num ; i++ ) {
1845c2277
<     CALL_ONREQUEST(pRI->pCI->requestNumber, cdmaBciPtrs.data(),
---
>     CALL_ONREQUEST(pRI->pCI->requestNumber, cdmaBciPtrs,
1847,1848d2278
< 
<     delete []cdmaBci;
1852c2282
< Return<void> RadioImpl::setCdmaBroadcastActivation(int32_t serial, bool activate) {
---
> Return<void> RadioImpl_1_6::setCdmaBroadcastActivation(int32_t serial, bool activate) {
1861c2291
< Return<void> RadioImpl::getCDMASubscription(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCDMASubscription(int32_t serial) {
1869c2299
< Return<void> RadioImpl::writeSmsToRuim(int32_t serial, const CdmaSmsWriteArgs& cdmaSms) {
---
> Return<void> RadioImpl_1_6::writeSmsToRuim(int32_t serial, const CdmaSmsWriteArgs& cdmaSms) {
1887c2317
< Return<void> RadioImpl::deleteSmsOnRuim(int32_t serial, int32_t index) {
---
> Return<void> RadioImpl_1_6::deleteSmsOnRuim(int32_t serial, int32_t index) {
1895c2325
< Return<void> RadioImpl::getDeviceIdentity(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getDeviceIdentity(int32_t serial) {
1903c2333
< Return<void> RadioImpl::exitEmergencyCallbackMode(int32_t serial) {
---
> Return<void> RadioImpl_1_6::exitEmergencyCallbackMode(int32_t serial) {
1911c2341
< Return<void> RadioImpl::getSmscAddress(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getSmscAddress(int32_t serial) {
1919c2349
< Return<void> RadioImpl::setSmscAddress(int32_t serial, const hidl_string& smsc) {
---
> Return<void> RadioImpl_1_6::setSmscAddress(int32_t serial, const hidl_string& smsc) {
1928c2358
< Return<void> RadioImpl::reportSmsMemoryStatus(int32_t serial, bool available) {
---
> Return<void> RadioImpl_1_6::reportSmsMemoryStatus(int32_t serial, bool available) {
1937c2367
< Return<void> RadioImpl::reportStkServiceIsRunning(int32_t serial) {
---
> Return<void> RadioImpl_1_6::reportStkServiceIsRunning(int32_t serial) {
1945c2375
< Return<void> RadioImpl::getCdmaSubscriptionSource(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCdmaSubscriptionSource(int32_t serial) {
1953c2383
< Return<void> RadioImpl::requestIsimAuthentication(int32_t serial, const hidl_string& challenge) {
---
> Return<void> RadioImpl_1_6::requestIsimAuthentication(int32_t serial, const hidl_string& challenge) {
1962c2392
< Return<void> RadioImpl::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success,
---
> Return<void> RadioImpl_1_6::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success,
1972c2402
< Return<void> RadioImpl::sendEnvelopeWithStatus(int32_t serial, const hidl_string& contents) {
---
> Return<void> RadioImpl_1_6::sendEnvelopeWithStatus(int32_t serial, const hidl_string& contents) {
1981c2411
< Return<void> RadioImpl::getVoiceRadioTechnology(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getVoiceRadioTechnology(int32_t serial) {
1989c2419
< Return<void> RadioImpl::getCellInfoList(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getCellInfoList(int32_t serial) {
1997c2427,2435
< Return<void> RadioImpl::setCellInfoListRate(int32_t serial, int32_t rate) {
---
> Return<void> RadioImpl_1_6::getCellInfoList_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getCellInfoList_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CELL_INFO_LIST);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setCellInfoListRate(int32_t serial, int32_t rate) {
2005c2443
< Return<void> RadioImpl::setInitialAttachApn(int32_t serial, const DataProfileInfo& dataProfileInfo,
---
> Return<void> RadioImpl_1_6::setInitialAttachApn(int32_t serial, const DataProfileInfo& dataProfileInfo,
2094c2532
< Return<void> RadioImpl::getImsRegistrationState(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getImsRegistrationState(int32_t serial) {
2191c2629
< Return<void> RadioImpl::sendImsSms(int32_t serial, const ImsSmsMessage& message) {
---
> Return<void> RadioImpl_1_6::sendImsSms(int32_t serial, const ImsSmsMessage& message) {
2200c2638,2640
<     if (RadioTechnologyFamily::THREE_GPP == message.tech) {
---
>     RIL_RadioTechnologyFamily format = (RIL_RadioTechnologyFamily) message.tech;
> 
>     if (RADIO_TECH_3GPP == format) {
2202c2642
<     } else if (RadioTechnologyFamily::THREE_GPP2 == message.tech) {
---
>     } else if (RADIO_TECH_3GPP2 == format) {
2212c2652
< Return<void> RadioImpl::iccTransmitApduBasicChannel(int32_t serial, const SimApdu& message) {
---
> Return<void> RadioImpl_1_6::iccTransmitApduBasicChannel(int32_t serial, const SimApdu& message) {
2220c2660
< Return<void> RadioImpl::iccOpenLogicalChannel(int32_t serial, const hidl_string& aid, int32_t p2) {
---
> Return<void> RadioImpl_1_6::iccOpenLogicalChannel(int32_t serial, const hidl_string& aid, int32_t p2) {
2224,2230c2664,2667
<     if (s_vendorFunctions->version < 15) {
<         dispatchString(serial, mSlotId, RIL_REQUEST_SIM_OPEN_CHANNEL, aid.c_str());
<     } else {
<         RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SIM_OPEN_CHANNEL);
<         if (pRI == NULL) {
<             return Void();
<         }
---
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SIM_OPEN_CHANNEL);
>     if (pRI == NULL) {
>         return Void();
>     }
2232c2669
<         RIL_OpenChannelParams params = {};
---
>     RIL_OpenChannelParams params = {};
2234c2671
<         params.p2 = p2;
---
>     params.p2 = p2;
2236,2238c2673,2675
<         if (!copyHidlStringToRil(&params.aidPtr, aid, pRI)) {
<             return Void();
<         }
---
>     if (!copyHidlStringToRil(&params.aidPtr, aid, pRI)) {
>         return Void();
>     }
2240c2677
<         CALL_ONREQUEST(pRI->pCI->requestNumber, &params, sizeof(params), pRI, mSlotId);
---
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &params, sizeof(params), pRI, mSlotId);
2242,2243c2679
<         memsetAndFreeStrings(1, params.aidPtr);
<     }
---
>     memsetAndFreeStrings(1, params.aidPtr);
2247c2683
< Return<void> RadioImpl::iccCloseLogicalChannel(int32_t serial, int32_t channelId) {
---
> Return<void> RadioImpl_1_6::iccCloseLogicalChannel(int32_t serial, int32_t channelId) {
2255c2691
< Return<void> RadioImpl::iccTransmitApduLogicalChannel(int32_t serial, const SimApdu& message) {
---
> Return<void> RadioImpl_1_6::iccTransmitApduLogicalChannel(int32_t serial, const SimApdu& message) {
2263c2699
< Return<void> RadioImpl::nvReadItem(int32_t serial, NvItem itemId) {
---
> Return<void> RadioImpl_1_6::nvReadItem(int32_t serial, NvItem itemId) {
2279c2715
< Return<void> RadioImpl::nvWriteItem(int32_t serial, const NvWriteItem& item) {
---
> Return<void> RadioImpl_1_6::nvWriteItem(int32_t serial, const NvWriteItem& item) {
2302c2738
< Return<void> RadioImpl::nvWriteCdmaPrl(int32_t serial, const hidl_vec<uint8_t>& prl) {
---
> Return<void> RadioImpl_1_6::nvWriteCdmaPrl(int32_t serial, const hidl_vec<uint8_t>& prl) {
2310c2746
< Return<void> RadioImpl::nvResetConfig(int32_t serial, ResetNvType resetType) {
---
> Return<void> RadioImpl_1_6::nvResetConfig(int32_t serial, ResetNvType resetType) {
2336c2772
< Return<void> RadioImpl::setUiccSubscription(int32_t serial, const SelectUiccSub& uiccSub) {
---
> Return<void> RadioImpl_1_6::setUiccSubscription(int32_t serial, const SelectUiccSub& uiccSub) {
2357c2793
< Return<void> RadioImpl::setDataAllowed(int32_t serial, bool allow) {
---
> Return<void> RadioImpl_1_6::setDataAllowed(int32_t serial, bool allow) {
2365c2801
< Return<void> RadioImpl::getHardwareConfig(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getHardwareConfig(int32_t serial) {
2368a2805
>     RLOGD("getHardwareConfig: serial %d, mSlotId = %d", serial, mSlotId);
2373c2810
< Return<void> RadioImpl::requestIccSimAuthentication(int32_t serial, int32_t authContext,
---
> Return<void> RadioImpl_1_6::requestIccSimAuthentication(int32_t serial, int32_t authContext,
2436c2873
< Return<void> RadioImpl::setDataProfile(int32_t serial, const hidl_vec<DataProfileInfo>& profiles,
---
> Return<void> RadioImpl_1_6::setDataProfile(int32_t serial, const hidl_vec<DataProfileInfo>& profiles,
2598c3035
< Return<void> RadioImpl::requestShutdown(int32_t serial) {
---
> Return<void> RadioImpl_1_6::requestShutdown(int32_t serial) {
2606c3043
< Return<void> RadioImpl::getRadioCapability(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getRadioCapability(int32_t serial) {
2614c3051
< Return<void> RadioImpl::setRadioCapability(int32_t serial, const RadioCapability& rc) {
---
> Return<void> RadioImpl_1_6::setRadioCapability(int32_t serial, const RadioCapability& rc) {
2637c3074
< Return<void> RadioImpl::startLceService(int32_t serial, int32_t reportInterval, bool pullMode) {
---
> Return<void> RadioImpl_1_6::startLceService(int32_t serial, int32_t reportInterval, bool pullMode) {
2646c3083
< Return<void> RadioImpl::stopLceService(int32_t serial) {
---
> Return<void> RadioImpl_1_6::stopLceService(int32_t serial) {
2654c3091
< Return<void> RadioImpl::pullLceData(int32_t serial) {
---
> Return<void> RadioImpl_1_6::pullLceData(int32_t serial) {
2662c3099
< Return<void> RadioImpl::getModemActivityInfo(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getModemActivityInfo(int32_t serial) {
2670,2681c3107,3110
< Return<void> RadioImpl::setAllowedCarriers(int32_t serial, bool allAllowed,
<                                            const CarrierRestrictions& carriers) {
< #if VDBG
<     RLOGD("setAllowedCarriers: serial %d", serial);
< #endif
<     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
<             RIL_REQUEST_SET_CARRIER_RESTRICTIONS);
<     if (pRI == NULL) {
<         return Void();
<     }
< 
<     RIL_CarrierRestrictions cr = {};
---
> int prepareCarrierRestrictions(RIL_CarrierRestrictions &request, bool allAllowed,
>                                const hidl_vec<Carrier>& allowedList,
>                                const hidl_vec<Carrier>& excludedList,
>                                RequestInfo *pRI) {
2685,2686c3114,3115
<     cr.len_allowed_carriers = carriers.allowedCarriers.size();
<     allowedCarriers = (RIL_Carrier *)calloc(cr.len_allowed_carriers, sizeof(RIL_Carrier));
---
>     request.len_allowed_carriers = allowedList.size();
>     allowedCarriers = (RIL_Carrier *)calloc(request.len_allowed_carriers, sizeof(RIL_Carrier));
2688c3117
<         RLOGE("setAllowedCarriers: Memory allocation failed for request %s",
---
>         RLOGE("prepareCarrierRestrictions: Memory allocation failed for request %s",
2691c3120
<         return Void();
---
>         return -1;
2693c3122
<     cr.allowed_carriers = allowedCarriers;
---
>     request.allowed_carriers = allowedCarriers;
2695,2696c3124,3125
<     cr.len_excluded_carriers = carriers.excludedCarriers.size();
<     excludedCarriers = (RIL_Carrier *)calloc(cr.len_excluded_carriers, sizeof(RIL_Carrier));
---
>     request.len_excluded_carriers = excludedList.size();
>     excludedCarriers = (RIL_Carrier *)calloc(request.len_excluded_carriers, sizeof(RIL_Carrier));
2698c3127
<         RLOGE("setAllowedCarriers: Memory allocation failed for request %s",
---
>         RLOGE("prepareCarrierRestrictions: Memory allocation failed for request %s",
2702c3131
<         memset(allowedCarriers, 0, cr.len_allowed_carriers * sizeof(RIL_Carrier));
---
>         memset(allowedCarriers, 0, request.len_allowed_carriers * sizeof(RIL_Carrier));
2705c3134
<         return Void();
---
>         return -1;
2707c3136
<     cr.excluded_carriers = excludedCarriers;
---
>     request.excluded_carriers = excludedCarriers;
2709,2713c3138,3142
<     for (int i = 0; i < cr.len_allowed_carriers; i++) {
<         allowedCarriers[i].mcc = carriers.allowedCarriers[i].mcc.c_str();
<         allowedCarriers[i].mnc = carriers.allowedCarriers[i].mnc.c_str();
<         allowedCarriers[i].match_type = (RIL_CarrierMatchType) carriers.allowedCarriers[i].matchType;
<         allowedCarriers[i].match_data = carriers.allowedCarriers[i].matchData.c_str();
---
>     for (int i = 0; i < request.len_allowed_carriers; i++) {
>         allowedCarriers[i].mcc = allowedList[i].mcc.c_str();
>         allowedCarriers[i].mnc = allowedList[i].mnc.c_str();
>         allowedCarriers[i].match_type = (RIL_CarrierMatchType) allowedList[i].matchType;
>         allowedCarriers[i].match_data = allowedList[i].matchData.c_str();
2716,2718c3145,3147
<     for (int i = 0; i < cr.len_excluded_carriers; i++) {
<         excludedCarriers[i].mcc = carriers.excludedCarriers[i].mcc.c_str();
<         excludedCarriers[i].mnc = carriers.excludedCarriers[i].mnc.c_str();
---
>     for (int i = 0; i < request.len_excluded_carriers; i++) {
>         excludedCarriers[i].mcc = excludedList[i].mcc.c_str();
>         excludedCarriers[i].mnc = excludedList[i].mnc.c_str();
2720,2721c3149,3150
<                 (RIL_CarrierMatchType) carriers.excludedCarriers[i].matchType;
<         excludedCarriers[i].match_data = carriers.excludedCarriers[i].matchData.c_str();
---
>                 (RIL_CarrierMatchType) excludedList[i].matchType;
>         excludedCarriers[i].match_data = excludedList[i].matchData.c_str();
2724c3153,3154
<     CALL_ONREQUEST(pRI->pCI->requestNumber, &cr, sizeof(RIL_CarrierRestrictions), pRI, mSlotId);
---
>     return 0;
> }
2725a3156,3157
> void freeCarrierRestrictions(RIL_CarrierRestrictions &request) {
>     if (request.allowed_carriers != NULL) {
2727,2728c3159,3174
<     memset(allowedCarriers, 0, cr.len_allowed_carriers * sizeof(RIL_Carrier));
<     memset(excludedCarriers, 0, cr.len_excluded_carriers * sizeof(RIL_Carrier));
---
>         memset(request.allowed_carriers, 0, request.len_allowed_carriers * sizeof(RIL_Carrier));
> #endif
>         free(request.allowed_carriers);
>     }
>     if (request.excluded_carriers != NULL) {
> #ifdef MEMSET_FREED
>         memset(request.excluded_carriers, 0, request.len_excluded_carriers * sizeof(RIL_Carrier));
> #endif
>         free(request.excluded_carriers);
>     }
> }
> 
> Return<void> RadioImpl_1_6::setAllowedCarriers(int32_t serial, bool allAllowed,
>                                            const CarrierRestrictions& carriers) {
> #if VDBG
>     RLOGD("setAllowedCarriers: serial %d", serial);
2730,2731c3176,3191
<     free(allowedCarriers);
<     free(excludedCarriers);
---
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_CARRIER_RESTRICTIONS);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_CarrierRestrictions cr = {};
>     if (prepareCarrierRestrictions(cr, allAllowed, carriers.allowedCarriers,
>             carriers.excludedCarriers, pRI) < 0) {
>         return Void();
>     }
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &cr, sizeof(RIL_CarrierRestrictions), pRI, mSlotId);
> 
>     freeCarrierRestrictions(cr);
> 
2735c3195
< Return<void> RadioImpl::getAllowedCarriers(int32_t serial) {
---
> Return<void> RadioImpl_1_6::getAllowedCarriers(int32_t serial) {
2743c3203
< Return<void> RadioImpl::sendDeviceState(int32_t serial, DeviceStateType deviceStateType,
---
> Return<void> RadioImpl_1_6::sendDeviceState(int32_t serial, DeviceStateType deviceStateType,
2764c3224
< Return<void> RadioImpl::setIndicationFilter(int32_t serial, int32_t indicationFilter) {
---
> Return<void> RadioImpl_1_6::setIndicationFilter(int32_t serial, int32_t indicationFilter) {
2778c3238
< Return<void> RadioImpl::setSimCardPower(int32_t serial, bool powerUp) {
---
> Return<void> RadioImpl_1_6::setSimCardPower(int32_t serial, bool powerUp) {
2786c3246
< Return<void> RadioImpl::setSimCardPower_1_1(int32_t serial, const V1_1::CardPowerState state) {
---
> Return<void> RadioImpl_1_6::setSimCardPower_1_1(int32_t serial, const V1_1::CardPowerState state) {
2794c3254,3263
< Return<void> RadioImpl::setCarrierInfoForImsiEncryption(int32_t serial,
---
> Return<void> RadioImpl_1_6::setSimCardPower_1_6(int32_t serial, const V1_1::CardPowerState state) {
> #if VDBG
>     RLOGD("setSimCardPower_1_6: serial %d state %d", serial, state);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_SET_SIM_CARD_POWER, 1, state);
>     mSimCardPowerState = state;
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setCarrierInfoForImsiEncryption(int32_t serial,
2828c3297
< Return<void> RadioImpl::startKeepalive(int32_t serial, const V1_1::KeepaliveRequest& keepalive) {
---
> Return<void> RadioImpl_1_6::startKeepalive(int32_t serial, const V1_1::KeepaliveRequest& keepalive) {
2877c3346
< Return<void> RadioImpl::stopKeepalive(int32_t serial, int32_t sessionHandle) {
---
> Return<void> RadioImpl_1_6::stopKeepalive(int32_t serial, int32_t sessionHandle) {
2890c3359
< Return<void> RadioImpl::responseAcknowledgement() {
---
> Return<void> RadioImpl_1_6::responseAcknowledgement() {
2894a3364,4770
> // Methods from ::android::hardware::radio::V1_2::IRadio follow.
> int prepareNetworkScanRequest_1_2(RIL_NetworkScanRequest &scan_request,
>     const ::android::hardware::radio::V1_2::NetworkScanRequest& request,
>     RequestInfo *pRI) {
> 
>     scan_request.type = (RIL_ScanType) request.type;
>     scan_request.interval = request.interval;
>     scan_request.specifiers_length = request.specifiers.size();
> 
>     int intervalLow = static_cast<int>(::android::hardware::radio::V1_2::ScanIntervalRange::MIN);
>     int intervalHigh = static_cast<int>(::android::hardware::radio::V1_2::ScanIntervalRange::MAX);
>     int maxSearchTimeLow =
>         static_cast<int>(::android::hardware::radio::V1_2::MaxSearchTimeRange::MIN);
>     int maxSearchTimeHigh =
>         static_cast<int>(::android::hardware::radio::V1_2::MaxSearchTimeRange::MAX);
>     int incrementalResultsPeriodicityRangeLow =
>         static_cast<int>(::android::hardware::radio::V1_2::IncrementalResultsPeriodicityRange::MIN);
>     int incrementalResultsPeriodicityRangeHigh =
>         static_cast<int>(::android::hardware::radio::V1_2::IncrementalResultsPeriodicityRange::MAX);
>     uint maxSpecifierSize =
>         static_cast<uint>(::android::hardware::radio::V1_2::RadioConst
>             ::RADIO_ACCESS_SPECIFIER_MAX_SIZE);
> 
>     if (request.interval < intervalLow || request.interval > intervalHigh) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     // If defined, must fall in correct range.
>     if (request.maxSearchTime != 0
>         && (request.maxSearchTime < maxSearchTimeLow
>             || request.maxSearchTime > maxSearchTimeHigh)) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     if (request.maxSearchTime != 0
>         && (request.incrementalResultsPeriodicity < incrementalResultsPeriodicityRangeLow
>             || request.incrementalResultsPeriodicity > incrementalResultsPeriodicityRangeHigh
>             || request.incrementalResultsPeriodicity > request.maxSearchTime)) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     if (request.specifiers.size() == 0 || request.specifiers.size() > maxSpecifierSize) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
> 
>     for (size_t i = 0; i < request.specifiers.size(); ++i) {
>         if (request.specifiers[i].geranBands.size() > MAX_BANDS ||
>             request.specifiers[i].utranBands.size() > MAX_BANDS ||
>             request.specifiers[i].eutranBands.size() > MAX_BANDS ||
>             request.specifiers[i].channels.size() > MAX_CHANNELS) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>             return -1;
>         }
>         const V1_1::RadioAccessSpecifier& ras_from =
>                 request.specifiers[i];
>         RIL_RadioAccessSpecifier& ras_to = scan_request.specifiers[i];
> 
>         ras_to.radio_access_network = (RIL_RadioAccessNetworks) ras_from.radioAccessNetwork;
>         ras_to.channels_length = ras_from.channels.size();
> 
>         std::copy(ras_from.channels.begin(), ras_from.channels.end(), ras_to.channels);
>         const std::vector<uint32_t> * bands = nullptr;
>         switch (request.specifiers[i].radioAccessNetwork) {
>             case V1_1::RadioAccessNetworks::GERAN:
>                 ras_to.bands_length = ras_from.geranBands.size();
>                 bands = (std::vector<uint32_t> *) &ras_from.geranBands;
>                 break;
>             case V1_1::RadioAccessNetworks::UTRAN:
>                 ras_to.bands_length = ras_from.utranBands.size();
>                 bands = (std::vector<uint32_t> *) &ras_from.utranBands;
>                 break;
>             case V1_1::RadioAccessNetworks::EUTRAN:
>                 ras_to.bands_length = ras_from.eutranBands.size();
>                 bands = (std::vector<uint32_t> *) &ras_from.eutranBands;
>                 break;
>             default:
>                 sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                 return -1;
>         }
>         // safe to copy to geran_bands because it's a union member
>         for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>             ras_to.bands.geran_bands[idx] = (RIL_GeranBands) (*bands)[idx];
>         }
>     }
> 
>     return 0;
> }
> 
> Return<void> RadioImpl_1_6::startNetworkScan_1_2(int32_t serial,
>         const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
> #if VDBG
>     RLOGD("startNetworkScan_1_2: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_START_NETWORK_SCAN);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_NetworkScanRequest scan_request = {};
> 
>     if (prepareNetworkScanRequest_1_2(scan_request, request, pRI) < 0) {
>         return Void();
>     }
> 
>     CALL_ONREQUEST(RIL_REQUEST_START_NETWORK_SCAN, &scan_request, sizeof(scan_request), pRI,
>             mSlotId);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setIndicationFilter_1_2(int32_t serial,
>         ::android::hardware::hidl_bitfield<V1_2::IndicationFilter> indicationFilter) {
> #if VDBG
>     RLOGD("setIndicationFilter_1_2: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER);
>     sendErrorResponse(pRI, RIL_E_SUCCESS);  // TODO: for vts
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setSignalStrengthReportingCriteria(int32_t serial,
>         int32_t hysteresisMs, int32_t hysteresisDb,
>         const hidl_vec<int32_t>& thresholdsDbm,
>         ::android::hardware::radio::V1_2::AccessNetwork  accessNetwork) {
> #if VDBG
>     RLOGD("setSignalStrengthReportingCriteria: %d", serial);
> #endif
>     RIL_Errno e;
>     if (radioService[mSlotId]->mRadioResponseV1_2 != NULL) {
>          RadioResponseInfo responseInfo = {};
>          if (hysteresisDb >= 10) {
>              e = RIL_E_INVALID_ARGUMENTS;
>          } else {
>              e = RIL_E_SUCCESS;
>          }
>          populateResponseInfo(responseInfo, serial, RESPONSE_SOLICITED, e);
>          Return<void> retStatus
>                    = radioService[mSlotId]->mRadioResponseV1_2->setSignalStrengthReportingCriteriaResponse(responseInfo);
>          radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setSignalStrengthReportingCriteria: radioService[%d]->mRadioResponse == NULL",
>            mSlotId);
>     }
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setLinkCapacityReportingCriteria(int32_t serial,
>        int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps,
>        const hidl_vec<int32_t>& thresholdsDownlinkKbps,
>         const hidl_vec<int32_t>& thresholdsUplinkKbps,
>         V1_2::AccessNetwork accessNetwork) {
> #if VDBG
>     RLOGE("[%04d]< %s", serial, "Method is not implemented");
>     RLOGD("setLinkCapacityReportingCriteria: %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA);
>     if (pRI == NULL) {
>         return Void();
>     }
>     // TODO: for vts. hysteresisDlKbps and hysteresisUlKbps range not confirmed
>     if (hysteresisDlKbps >= 5000 || hysteresisUlKbps >= 1000) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return Void();
>     } else {
>         sendErrorResponse(pRI, RIL_E_SUCCESS);
>     }
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setupDataCall_1_2(int32_t serial, V1_2::AccessNetwork accessNetwork,
>         const V1_0::DataProfileInfo& dataProfileInfo, bool modemCognitive,
>         bool roamingAllowed, bool isRoaming, V1_2::DataRequestReason reason,
>         const hidl_vec<hidl_string>& addresses, const hidl_vec<hidl_string>& dnses) {
> #if VDBG
>     RLOGE("[%04d]< %s", serial, "Method is not implemented");
>     RLOGD("setupDataCall_1_2: serial %d", serial);
> #endif
> 
>     if (s_vendorFunctions->version >= 4 && s_vendorFunctions->version <= 14) {
>         const hidl_string &protocol =
>                 (isRoaming ? dataProfileInfo.roamingProtocol : dataProfileInfo.protocol);
>         dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 7,
>             std::to_string((int)accessNetwork).c_str(),
>             std::to_string((int)dataProfileInfo.profileId).c_str(),
>             dataProfileInfo.apn.c_str(),
>             dataProfileInfo.user.c_str(),
>             dataProfileInfo.password.c_str(),
>             std::to_string((int)dataProfileInfo.authType).c_str(),
>             protocol.c_str());
>     } else if (s_vendorFunctions->version >= 15) {
>         char *mvnoTypeStr = NULL;
>         if (!convertMvnoTypeToString(dataProfileInfo.mvnoType, mvnoTypeStr)) {
>             RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                     RIL_REQUEST_SETUP_DATA_CALL);
>             if (pRI != NULL) {
>                 sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>             }
>             return Void();
>         }
>         dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 15,
>             std::to_string((int)accessNetwork).c_str(),
>             std::to_string((int)dataProfileInfo.profileId).c_str(),
>             dataProfileInfo.apn.c_str(),
>             dataProfileInfo.user.c_str(),
>             dataProfileInfo.password.c_str(),
>             std::to_string((int) dataProfileInfo.authType).c_str(),
>             dataProfileInfo.protocol.c_str(),
>             dataProfileInfo.roamingProtocol.c_str(),
>             std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
>             std::to_string(dataProfileInfo.bearerBitmap).c_str(),
>             modemCognitive ? "1" : "0",
>             std::to_string(dataProfileInfo.mtu).c_str(),
>             mvnoTypeStr,
>             dataProfileInfo.mvnoMatchData.c_str(),
>             roamingAllowed ? "1" : "0");
>     } else {
>         RLOGE("Unsupported RIL version %d, min version expected 4", s_vendorFunctions->version);
>         RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                 RIL_REQUEST_SETUP_DATA_CALL);
>         if (pRI != NULL) {
>             sendErrorResponse(pRI, RIL_E_REQUEST_NOT_SUPPORTED);
>         }
>     }
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::deactivateDataCall_1_2(int32_t serial, int32_t cid,
>         ::android::hardware::radio::V1_2::DataRequestReason reason) {
> #if VDBG
>     RLOGD("deactivateDataCall_1_2: serial %d", serial);
> #endif
> 
>     RIL_DataRequestReason dataRequestReason = (RIL_DataRequestReason)reason;
>     const char *reasonStr = NULL;
>     switch (dataRequestReason) {
>         case DATA_REQ_REASOPN_NORMAL:
>             reasonStr = "normal";
>             break;
>         case DATA_REQ_REASOPN_SHUTDOWN:
>             reasonStr = "shutdown";
>             break;
>         case DATA_REQ_REASOPN_HANDOVER:
>             reasonStr = "handover";
>             break;
>         default:
>             reasonStr = "unknown";
>             break;
>     }
> 
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_DEACTIVATE_DATA_CALL, false,
>             2, (std::to_string(cid)).c_str(), reasonStr);
>     return Void();
> }
> 
> // Methods from ::android::hardware::radio::V1_3::IRadio follow.
> Return<void> RadioImpl_1_6::setSystemSelectionChannels(int32_t serial, bool /* specifyChannels */,
>         const hidl_vec<::android::hardware::radio::V1_1::RadioAccessSpecifier>& /* specifiers */) {
> #if VDBG
>     RLOGD("setSystemSelectionChannels: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::enableModem(int32_t serial, bool /* on */) {
> #if VDBG
>     RLOGE("enableModem: serial = %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_ENABLE_MODEM);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getModemStackStatus(int32_t serial) {
> #if VDBG
>     RLOGD("getModemStackStatus: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_MODEM_STACK_STATUS);
>     return Void();
> }
> 
> const char * getProtocolString(const ::android::hardware::radio::V1_4::PdpProtocolType protocolVal) {
>     switch(protocolVal) {
>         case ::android::hardware::radio::V1_4::PdpProtocolType::IP:
>             return "IP";
>         case ::android::hardware::radio::V1_4::PdpProtocolType::IPV6:
>             return "IPV6";
>         case ::android::hardware::radio::V1_4::PdpProtocolType::IPV4V6:
>             return "IPV4V6";
>         case ::android::hardware::radio::V1_4::PdpProtocolType::PPP:
>             return "PPP";
>         case ::android::hardware::radio::V1_4::PdpProtocolType::NON_IP:
>             return "NON_IP";
>         case ::android::hardware::radio::V1_4::PdpProtocolType::UNSTRUCTURED:
>             return "UNSTRUCTURED";
>         default:
>             return "UNKNOWN";
>     }
> }
> 
> // Methods from ::android::hardware::radio::V1_4::IRadio follow.
> Return<void> RadioImpl_1_6::setAllowedCarriers_1_4(int32_t  serial,
>         const V1_4::CarrierRestrictionsWithPriority& carriers,
>         V1_4::SimLockMultiSimPolicy multiSimPolicy) {
> #if VDBG
>     RLOGD("setAllowedCarriers_1_4: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_CARRIER_RESTRICTIONS);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     // Prepare legacy structure (defined in IRadio 1.0) to re-use existing code.
>     RIL_CarrierRestrictions cr = {};
>     if (prepareCarrierRestrictions(cr, false, carriers.allowedCarriers, carriers.excludedCarriers,
>             pRI) < 0) {
>         return Void();
>     }
>     // Copy the legacy structure into the new structure (defined in IRadio 1.4)
>     RIL_CarrierRestrictionsWithPriority crExt = {};
>     crExt.len_allowed_carriers = cr.len_allowed_carriers;
>     crExt.allowed_carriers = cr.allowed_carriers;
>     crExt.len_excluded_carriers = cr.len_excluded_carriers;
>     crExt.excluded_carriers = cr.excluded_carriers;
>     crExt.allowedCarriersPrioritized = BOOL_TO_INT(carriers.allowedCarriersPrioritized);
>     crExt.multiSimPolicy = (RIL_SimLockMultiSimPolicy)multiSimPolicy;
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &crExt, sizeof(RIL_CarrierRestrictionsWithPriority),
>             pRI, mSlotId);
> 
>     freeCarrierRestrictions(cr);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getAllowedCarriers_1_4(int32_t serial) {
> #if VDBG
>     RLOGD("getAllowedCarriers_1_4: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CARRIER_RESTRICTIONS);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setupDataCall_1_4(int32_t serial ,
>         ::android::hardware::radio::V1_4::AccessNetwork /* accessNetwork */,
>         const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo,
>         bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason /* reason */,
>         const hidl_vec<hidl_string>& /* addresses */, const hidl_vec<hidl_string>& /* dnses */) {
> 
> #if VDBG
>     RLOGD("setupDataCall_1_4: serial %d", serial);
> #endif
> 
>     char *mvnoTypeStr = NULL;
>     if (!convertMvnoTypeToString(MvnoType::IMSI, mvnoTypeStr)) {
>         RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                 RIL_REQUEST_SETUP_DATA_CALL);
>         if (pRI != NULL) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         }
>         return Void();
>     }
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 16,
>         std::to_string((int) RadioTechnology::UNKNOWN + 2).c_str(),
>         std::to_string((int) dataProfileInfo.profileId).c_str(),
>         dataProfileInfo.apn.c_str(),
>         dataProfileInfo.user.c_str(),
>         dataProfileInfo.password.c_str(),
>         std::to_string((int) dataProfileInfo.authType).c_str(),
>         getProtocolString(dataProfileInfo.protocol),
>         getProtocolString(dataProfileInfo.roamingProtocol),
>         std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
>         std::to_string(dataProfileInfo.bearerBitmap).c_str(),
>         dataProfileInfo.persistent ? "1" : "0",
>         std::to_string(dataProfileInfo.mtu).c_str(),
>         mvnoTypeStr,
>         "302720x94",
>         roamingAllowed ? "1" : "0",
>         "-1");
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setInitialAttachApn_1_4(int32_t  serial ,
>         const ::android::hardware::radio::V1_4::DataProfileInfo& dataProfileInfo) {
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_INITIAL_ATTACH_APN);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, RESPONSE_SOLICITED, RIL_E_SUCCESS);
> 
>     if (radioService[mSlotId]->mRadioResponseV1_4 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_4->setInitialAttachApnResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else if (radioService[mSlotId]->mRadioResponse != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponse->setInitialAttachApnResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setInitialAttachApnResponse: radioService[%d]->mRadioResponse == NULL", mSlotId);
>     }
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setDataProfile_1_4(int32_t  serial ,
>         const hidl_vec<::android::hardware::radio::V1_4::DataProfileInfo>& /* profiles */) {
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_DATA_PROFILE);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, RESPONSE_SOLICITED, RIL_E_SUCCESS);
> 
>     if (radioService[mSlotId]->mRadioResponseV1_4 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_4->setDataProfileResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else if (radioService[mSlotId]->mRadioResponse != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponse->setDataProfileResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setDataProfileResponse: radioService[%d]->mRadioResponse == NULL", mSlotId);
>     }
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::emergencyDial(int32_t serial,
>         const ::android::hardware::radio::V1_0::Dial& dialInfo,
>         hidl_bitfield<android::hardware::radio::V1_4::EmergencyServiceCategory> categories,
>         const hidl_vec<hidl_string>&  urns ,
>         ::android::hardware::radio::V1_4::EmergencyCallRouting routing,
>         bool fromEmergencyDialer, bool /* isTesting */) {
> #if VDBG
>     RLOGD("emergencyDial: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_EMERGENCY_DIAL);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_EmergencyDial eccDial = {};
>     RIL_Dial& dial = eccDial.dialInfo;
>     RIL_UUS_Info uusInfo = {};
> 
>     if (!copyHidlStringToRil(&dial.address, dialInfo.address, pRI)) {
>         return Void();
>     }
>     dial.clir = (int) dialInfo.clir;
> 
>     if (dialInfo.uusInfo.size() != 0) {
>         uusInfo.uusType = (RIL_UUS_Type) dialInfo.uusInfo[0].uusType;
>         uusInfo.uusDcs = (RIL_UUS_DCS) dialInfo.uusInfo[0].uusDcs;
> 
>         if (dialInfo.uusInfo[0].uusData.size() == 0) {
>             uusInfo.uusData = NULL;
>             uusInfo.uusLength = 0;
>         } else {
>             if (!copyHidlStringToRil(&uusInfo.uusData, dialInfo.uusInfo[0].uusData, pRI)) {
>                 memsetAndFreeStrings(1, dial.address);
>                 return Void();
>             }
>             uusInfo.uusLength = dialInfo.uusInfo[0].uusData.size();
>         }
> 
>         dial.uusInfo = &uusInfo;
>     }
> 
>     eccDial.urnsNumber = urns.size();
>     if (eccDial.urnsNumber != 0) {
>         char **ppUrns = (char **)calloc(eccDial.urnsNumber, sizeof(char *));
>         if (ppUrns == NULL) {
>             RLOGE("Memory allocation failed for request %s",
>                     requestToString(pRI->pCI->requestNumber));
>             sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>             memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>             return Void();
>         }
>         for (uint32_t i = 0; i < eccDial.urnsNumber; i++) {
>             if (!copyHidlStringToRil(&ppUrns[i], hidl_string(urns[i]), pRI)) {
>                 for (uint32_t j = 0; j < i; j++) {
>                     memsetAndFreeStrings(1, ppUrns[j]);
>                 }
>                 memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>                 free(ppUrns);
>                 return Void();
>             }
>         }
>         eccDial.urns = ppUrns;
>     }
> 
>     eccDial.categories = (RIL_EmergencyServiceCategory)categories;
>     eccDial.routing = (RIL_EmergencyCallRouting)routing;
>     eccDial.fromEmergencyDialer = fromEmergencyDialer;
> 
>     CALL_ONREQUEST(RIL_REQUEST_EMERGENCY_DIAL, &eccDial, sizeof(RIL_EmergencyDial), pRI, mSlotId);
> 
>     memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
>     if (eccDial.urns != NULL) {
>         for (size_t i = 0; i < eccDial.urnsNumber; i++) {
>             memsetAndFreeStrings(1, eccDial.urns[i]);
>         }
>         free(eccDial.urns);
>     }
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::startNetworkScan_1_4(int32_t serial,
>         const ::android::hardware::radio::V1_2::NetworkScanRequest& request) {
> #if VDBG
>     RLOGD("startNetworkScan_1_4: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_START_NETWORK_SCAN);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_NetworkScanRequest scan_request = {};
> 
>     if (prepareNetworkScanRequest_1_2(scan_request, request, pRI) < 0) {
>         return Void();
>     }
> 
>     CALL_ONREQUEST(RIL_REQUEST_START_NETWORK_SCAN, &scan_request, sizeof(scan_request), pRI,
>             mSlotId);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getPreferredNetworkTypeBitmap(int32_t serial ) {
> #if VDBG
>     RLOGD("getPreferredNetworkTypeBitmap: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setPreferredNetworkTypeBitmap(
>         int32_t serial, hidl_bitfield<RadioAccessFamily> networkTypeBitmap) {
> #if VDBG
>     RLOGD("setPreferredNetworkTypeBitmap: serial %d", serial);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP, 1, networkTypeBitmap);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setAllowedNetworkTypesBitmap(
>         uint32_t serial, hidl_bitfield<RadioAccessFamily> networkTypeBitmap) {
> #if VDBG
>     RLOGD("setAllowedNetworkTypesBitmap: serial %d", serial);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP, 1, networkTypeBitmap);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getAllowedNetworkTypesBitmap(int32_t serial) {
> #if VDBG
>     RLOGD("getAllowedNetworkTypesBitmap: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getSignalStrength_1_4(int32_t serial) {
> #if VDBG
>     RLOGD("getSignalStrength_1_4: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_SIGNAL_STRENGTH);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getSignalStrength_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getSignalStrength_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_SIGNAL_STRENGTH);
>     return Void();
> }
> 
> // Methods from ::android::hardware::radio::V1_5::IRadio follow.
> Return<void> RadioImpl_1_6::setSignalStrengthReportingCriteria_1_5(int32_t serial,
>         const V1_5::SignalThresholdInfo& signalThresholdInfo,
>         V1_5::AccessNetwork accessNetwork) {
> #if VDBG
>     RLOGD("setSignalStrengthReportingCriteria_1_5: %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     if (signalThresholdInfo.hysteresisDb >= 10) {  // TODO: for vts. hysteresisDb range not checked
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return Void();
>     }
> 
>     RIL_SignalStrengthReportingCriteria_v1_5 *criteria = (RIL_SignalStrengthReportingCriteria_v1_5 *)
>             calloc(1, sizeof(RIL_SignalStrengthReportingCriteria_v1_5));
>     if (criteria == NULL) {
>         RLOGE("Memory allocation failed for request %s",
>                 requestToString(pRI->pCI->requestNumber));
>         sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>         return Void();
>     }
> 
>     criteria->signalMeasurement = (SignalMeasurementType)signalThresholdInfo.signalMeasurement;
>     criteria->isEnabled = signalThresholdInfo.isEnabled;
>     criteria->hysteresisMs = signalThresholdInfo.hysteresisMs;
>     criteria->hysteresisDb = signalThresholdInfo.hysteresisDb;
>     criteria->thresholdsDbmNumber = signalThresholdInfo.thresholds.size();
>     criteria->thresholdsDbm = new int32_t[criteria->thresholdsDbmNumber];
>     memcpy(criteria->thresholdsDbm, signalThresholdInfo.thresholds.data(),
>             criteria->thresholdsDbmNumber * sizeof(int32_t));
>     criteria->accessNetwork = (RIL_RadioAccessNetworks_v1_5)accessNetwork;
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, criteria,
>             sizeof(RIL_SignalStrengthReportingCriteria_v1_5), pRI, mSlotId);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setLinkCapacityReportingCriteria_1_5(int32_t serial,
>     int32_t hysteresisMs, int32_t hysteresisDlKbps, int32_t hysteresisUlKbps,
>      const hidl_vec<int32_t>& thresholdsDownlinkKbps,
>      const hidl_vec<int32_t>& thresholdsUplinkKbps,
>      V1_5::AccessNetwork accessNetwork) {
> #if VDBG
>  RLOGD("setLinkCapacityReportingCriteria_1_5: %d", serial);
> #endif
> 
>      RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>              RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA);
>      if (pRI == NULL) {
>          return Void();
>      }
>      // TODO: for vts. hysteresisDlKbps and hysteresisUlKbps range not confirmed
>      if (hysteresisDlKbps >= 5000 || hysteresisUlKbps >= 1000) {
>          sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>          return Void();
>      }
> 
>      RIL_LinkCapacityReportingCriteria *criteria = (RIL_LinkCapacityReportingCriteria *)
>              calloc(1, sizeof(RIL_LinkCapacityReportingCriteria));
>      if (criteria == NULL) {
>          RLOGE("Memory allocation failed for request %s",
>                  requestToString(pRI->pCI->requestNumber));
>          sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>          return Void();
>      }
> 
>      criteria->hysteresisMs = hysteresisMs;
>      criteria->hysteresisDlKbps = hysteresisDlKbps;
>      criteria->hysteresisUlKbps = hysteresisUlKbps;
>      criteria->thresholdsDownlinkKbpsLength = thresholdsDownlinkKbps.size();
>      criteria->thresholdsUplinkKbpsLength = thresholdsUplinkKbps.size();
>      criteria->thresholdsDownlinkKbps = new int32_t[criteria->thresholdsDownlinkKbpsLength];
>      criteria->thresholdsUplinkKbps = new int32_t[criteria->thresholdsUplinkKbpsLength];
>      memcpy(criteria->thresholdsDownlinkKbps, thresholdsDownlinkKbps.data(),
>              criteria->thresholdsDownlinkKbpsLength * sizeof(int32_t));
>      memcpy(criteria->thresholdsUplinkKbps, thresholdsUplinkKbps.data(),
>              criteria->thresholdsUplinkKbpsLength * sizeof(int32_t));
>      criteria->accessNetwork = (RIL_RadioAccessNetworks_v1_5)accessNetwork;
> 
>      CALL_ONREQUEST(pRI->pCI->requestNumber, criteria,
>              sizeof(RIL_LinkCapacityReportingCriteria), pRI, pRI->socket_id);
> 
>      return Void();
> }
> 
> Return<void> RadioImpl_1_6::enableUiccApplications(int32_t serial, bool enable) {
> #if VDBG
>     RLOGD("enableUiccApplications: serial %d enable %d", serial, enable);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_ENABLE_UICC_APPLICATIONS, 1, BOOL_TO_INT(enable));
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setRadioPower_1_5(int32_t serial, bool powerOn, bool forEmergencyCall,
>                                           bool preferredForEmergencyCall) {
> #if VDBG
>     RLOGD("setRadioPower_1_6: serial %d powerOn %d forEmergency %d preferredForEmergencyCall %d",
>         serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_RADIO_POWER, 1, BOOL_TO_INT(powerOn));
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setRadioPower_1_6(int32_t serial, bool powerOn, bool forEmergencyCall,
>                                           bool preferredForEmergencyCall) {
> #if VDBG
>     RLOGD("setRadioPower_1_6: serial %d powerOn %d forEmergency %d preferredForEmergencyCall %d",
>         serial, powerOn, forEmergencyCall, preferredForEmergencyCall);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_RADIO_POWER, 1, BOOL_TO_INT(powerOn));
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::areUiccApplicationsEnabled(int32_t serial) {
> #if VDBG
>     RLOGD("areUiccApplicationsEnabled: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getVoiceRegistrationState_1_5(int32_t serial) {
> #if VDBG
>     RLOGD("getVoiceRegistrationState_1_5: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_VOICE_REGISTRATION_STATE);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getDataRegistrationState_1_5(int32_t serial) {
> #if VDBG
>     RLOGD("getDataRegistrationState_1_5: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_DATA_REGISTRATION_STATE);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getVoiceRegistrationState_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getVoiceRegistrationState_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_VOICE_REGISTRATION_STATE);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getDataRegistrationState_1_6(int32_t serial) {
> #if VDBG
>     RLOGD("getDataRegistrationState_1_6: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_DATA_REGISTRATION_STATE);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setSystemSelectionChannels_1_5(int32_t serial,
>         bool specifyChannels, const hidl_vec<V1_5::RadioAccessSpecifier>& specifiers) {
> 
> #if VDBG
> RLOGD("setSystemSelectionChannels_1_5: %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                   RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS);
>     if (pRI == NULL) {
>       return Void();
>     }
> 
>     if (specifiers.size() > RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE) {
>       sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>       return Void();
>     }
> 
>     RIL_SystemSelectionChannels_v1_5 *sysSelectionChannels =
>           (RIL_SystemSelectionChannels_v1_5 *)calloc(1, sizeof(RIL_SystemSelectionChannels_v1_5));
>     if (sysSelectionChannels == NULL) {
>       RLOGE("Memory allocation failed for request %s",
>               requestToString(pRI->pCI->requestNumber));
>       sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>       return Void();
>     }
>     sysSelectionChannels->specifyChannels = specifyChannels;
>     sysSelectionChannels->specifiers_length = specifiers.size();
>     for (size_t i = 0; i < specifiers.size(); ++i) {
>       const V1_5::RadioAccessSpecifier& ras_from = specifiers[i];
>       RIL_RadioAccessSpecifier_v1_5 &ras_to = sysSelectionChannels->specifiers[i];
> 
>       ras_to.radio_access_network = (RIL_RadioAccessNetworks_v1_5)ras_from.radioAccessNetwork;
>       ras_to.channels_length = ras_from.channels.size();
> 
>       std::copy(ras_from.channels.begin(), ras_from.channels.end(), ras_to.channels);
>       const std::vector<uint32_t> * bands = nullptr;
>       switch (specifiers[i].radioAccessNetwork) {
>           case V1_5::RadioAccessNetworks::GERAN:
>               ras_to.bands_length = ras_from.bands.geranBands().size();
>               bands = (std::vector<uint32_t> *) &ras_from.bands.geranBands();
>               break;
>           case V1_5::RadioAccessNetworks::UTRAN:
>               ras_to.bands_length = ras_from.bands.utranBands().size();
>               bands = (std::vector<uint32_t> *) &ras_from.bands.utranBands();
>               break;
>           case V1_5::RadioAccessNetworks::EUTRAN:
>               ras_to.bands_length = ras_from.bands.eutranBands().size();
>               bands = (std::vector<uint32_t> *) &ras_from.bands.eutranBands();
>               break;
>           case V1_5::RadioAccessNetworks::NGRAN:
>               ras_to.bands_length = ras_from.bands.ngranBands().size();
>               bands = (std::vector<uint32_t> *) &ras_from.bands.ngranBands();
>               break;
>           default: {
>               sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>               free(sysSelectionChannels);
>               return Void();
>           }
>       }
>       // safe to copy to geran_bands because it's a union member
>       for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>           ras_to.bands.geran_bands[idx] = (RIL_GeranBands)(*bands)[idx];
>       }
>     }
> 
>     CALL_ONREQUEST(RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS, sysSelectionChannels,
>           sizeof(RIL_SystemSelectionChannels_v1_5), pRI, mSlotId);
> 
>     return Void();
> }
> 
> int prepareNetworkScanRequest_1_5(RIL_NetworkScanRequest_v1_5 &scan_request,
>         const V1_5::NetworkScanRequest& request, RequestInfo *pRI) {
>     scan_request.type = (RIL_ScanType) request.type;
>     scan_request.interval = request.interval;
>     scan_request.specifiers_length = request.specifiers.size();
>     scan_request.maxSearchTime = request.maxSearchTime;
>     scan_request.incrementalResults = request.incrementalResults;
>     scan_request.incrementalResultsPeriodicity = request.incrementalResultsPeriodicity;
>     scan_request.mccMncsNumbers = request.mccMncs.size();
> 
>     int intervalLow = static_cast<int>(V1_2::ScanIntervalRange::MIN);
>     int intervalHigh = static_cast<int>(V1_2::ScanIntervalRange::MAX);
>     int maxSearchTimeLow = static_cast<int>(V1_2::MaxSearchTimeRange::MIN);
>     int maxSearchTimeHigh = static_cast<int>(V1_2::MaxSearchTimeRange::MAX);
>     int incrementalResultsPeriodicityRangeLow =
>             static_cast<int>(V1_2::IncrementalResultsPeriodicityRange::MIN);
>     int incrementalResultsPeriodicityRangeHigh =
>             static_cast<int>(V1_2::IncrementalResultsPeriodicityRange::MAX);
>     uint maxSpecifierSize = static_cast<uint>(V1_2::RadioConst::RADIO_ACCESS_SPECIFIER_MAX_SIZE);
> 
>     if (request.interval < intervalLow || request.interval > intervalHigh) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     // If defined, must fall in correct range.
>     if (request.maxSearchTime != 0 && (request.maxSearchTime < maxSearchTimeLow
>             || request.maxSearchTime > maxSearchTimeHigh)) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     if (request.maxSearchTime != 0
>             && (request.incrementalResultsPeriodicity < incrementalResultsPeriodicityRangeLow
>             || request.incrementalResultsPeriodicity > incrementalResultsPeriodicityRangeHigh
>             || request.incrementalResultsPeriodicity > request.maxSearchTime)) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
>     if (request.specifiers.size() == 0 || request.specifiers.size() > maxSpecifierSize) {
>         sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         return -1;
>     }
> 
>     for (size_t i = 0; i < request.specifiers.size(); ++i) {
>         if (request.specifiers[i].channels.size() > MAX_CHANNELS) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>             return -1;
>         }
>         switch (request.specifiers[i].bands.getDiscriminator()) {
>             case V1_5::RadioAccessSpecifier::Bands::hidl_discriminator::geranBands:
>                 if (request.specifiers[i].bands.geranBands().size() > MAX_BANDS) {
>                   sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                   return -1;
>                 }
>                 break;
>             case V1_5::RadioAccessSpecifier::Bands::hidl_discriminator::utranBands:
>                 if (request.specifiers[i].bands.utranBands().size() > MAX_BANDS) {
>                   sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                   return -1;
>                 }
>                 break;
>             case V1_5::RadioAccessSpecifier::Bands::hidl_discriminator::eutranBands:
>                 if (request.specifiers[i].bands.eutranBands().size() > MAX_BANDS) {
>                   sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                   return -1;
>                 }
>                 break;
>             case V1_5::RadioAccessSpecifier::Bands::hidl_discriminator::ngranBands:
>                 if (request.specifiers[i].bands.ngranBands().size() > MAX_BANDS) {
>                   sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                   return -1;
>                 }
>                 break;
>             default:
>               sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>               return -1;
>         }
> 
>         if (request.specifiers[i].channels.size() > MAX_CHANNELS) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>             return -1;
>         }
> 
>         const V1_5::RadioAccessSpecifier& ras_from = request.specifiers[i];
>         RIL_RadioAccessSpecifier_v1_5& ras_to = scan_request.specifiers[i];
> 
>         ras_to.radio_access_network = (RIL_RadioAccessNetworks_v1_5) ras_from.radioAccessNetwork;
>         ras_to.channels_length = ras_from.channels.size();
> 
>         std::copy(ras_from.channels.begin(), ras_from.channels.end(), ras_to.channels);
>         const std::vector<uint32_t> * bands = nullptr;
>         switch (request.specifiers[i].radioAccessNetwork) {
>             case V1_5::RadioAccessNetworks::GERAN:
>                 ras_to.bands_length = ras_from.bands.geranBands().size();
> 
>                 bands = (std::vector<uint32_t> *) &ras_from.bands.geranBands();
>                 // safe to copy to geran_bands because it's a union member
>                 for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>                     ras_to.bands.geran_bands[idx] = (RIL_GeranBands) (*bands)[idx];
>                 }
>                 break;
>             case V1_5::RadioAccessNetworks::UTRAN:
>                 ras_to.bands_length = ras_from.bands.utranBands().size();
>                 bands = (std::vector<uint32_t> *) &ras_from.bands;
>                 // safe to copy to geran_bands because it's a union member
>                 for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>                     ras_to.bands.utran_bands[idx] = (RIL_UtranBands) (*bands)[idx];
>                 }
>                 break;
>             case V1_5::RadioAccessNetworks::EUTRAN:
>                 ras_to.bands_length = ras_from.bands.eutranBands().size();
>                 bands = (std::vector<uint32_t> *) &ras_from.bands;
>                 // safe to copy to geran_bands because it's a union member
>                 for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>                     ras_to.bands.eutran_bands[idx] = (RIL_EutranBands) (*bands)[idx];
>                 }
>                 break;
>             case V1_5::RadioAccessNetworks::NGRAN:
>                 ras_to.bands_length = ras_from.bands.ngranBands().size();
>                 bands = (std::vector<uint32_t> *) &ras_from.bands;
>                 // safe to copy to geran_bands because it's a union member
>                 for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
>                     ras_to.bands.ngran_bands[idx] = (RIL_NgranBands) (*bands)[idx];
>                 }
>                 break;
>             default:
>                 sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>                 return -1;
>         }
>     }
>     if (scan_request.mccMncsNumbers != 0) {
>         char **pStrings = (char **)calloc(scan_request.mccMncsNumbers, sizeof(char *));
>         if (pStrings == NULL) {
>             RLOGE("Memory allocation failed for request %s",
>                     requestToString(pRI->pCI->requestNumber));
>             sendErrorResponse(pRI, RIL_E_NO_MEMORY);
>             return -1;
>         }
>         for (size_t i = 0; i < request.mccMncs.size(); ++i) {
>             if (!copyHidlStringToRil(&pStrings[i], hidl_string(request.mccMncs[i]), pRI)) {
>                 for (size_t j = 0; j < i; j++) {
>                     memsetAndFreeStrings(1, pStrings[j]);
>                 }
>                 free(pStrings);
>                 return -1;
>             }
>         }
>         scan_request.mccMncs = pStrings;
>     }
>     return 0;
> }
> 
> Return<void> RadioImpl_1_6::startNetworkScan_1_5(int32_t serial,
>         const ::android::hardware::radio::V1_5::NetworkScanRequest& request) {
> #if VDBG
>     RLOGD("startNetworkScan_1_6: serial %d", serial);
> #endif
> 
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_START_NETWORK_SCAN);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_NetworkScanRequest_v1_5 scan_request = {};
> 
>     if (prepareNetworkScanRequest_1_5(scan_request, request, pRI) < 0) {
>         return Void();
>     }
> 
>     CALL_ONREQUEST(RIL_REQUEST_START_NETWORK_SCAN, &scan_request, sizeof(scan_request), pRI,
>             mSlotId);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setupDataCall_1_5(int32_t serial ,
>         ::android::hardware::radio::V1_5::AccessNetwork /* accessNetwork */,
>         const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo,
>         bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason /* reason */,
>         const hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& /* addresses */,
>         const hidl_vec<hidl_string>& /* dnses */) {
> 
> #if VDBG
>     RLOGD("setupDataCall_1_5: serial %d", serial);
> #endif
> 
>     char *mvnoTypeStr = NULL;
>     if (!convertMvnoTypeToString(MvnoType::IMSI, mvnoTypeStr)) {
>         RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                 RIL_REQUEST_SETUP_DATA_CALL);
>         if (pRI != NULL) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         }
>         return Void();
>     }
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 15,
>         std::to_string((int) RadioTechnology::UNKNOWN + 2).c_str(),
>         std::to_string((int) dataProfileInfo.profileId).c_str(),
>         dataProfileInfo.apn.c_str(),
>         dataProfileInfo.user.c_str(),
>         dataProfileInfo.password.c_str(),
>         std::to_string((int) dataProfileInfo.authType).c_str(),
>         getProtocolString(dataProfileInfo.protocol),
>         getProtocolString(dataProfileInfo.roamingProtocol),
>         std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
>         std::to_string(dataProfileInfo.bearerBitmap).c_str(),
>         dataProfileInfo.persistent ? "1" : "0",
>         std::to_string(dataProfileInfo.mtuV4).c_str(),
>         std::to_string(dataProfileInfo.mtuV6).c_str(),
>         mvnoTypeStr,
>         "302720x94",
>         roamingAllowed ? "1" : "0");
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setupDataCall_1_6(int32_t serial ,
>         ::android::hardware::radio::V1_5::AccessNetwork /* accessNetwork */,
>         const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo,
>         bool roamingAllowed, ::android::hardware::radio::V1_2::DataRequestReason /* reason */,
>         const hidl_vec<::android::hardware::radio::V1_5::LinkAddress>& /* addresses */,
>         const hidl_vec<hidl_string>& /* dnses */,
>         int32_t /* pduSessionId */,
>         const ::android::hardware::radio::V1_6::OptionalSliceInfo& /* sliceInfo */,
>         const ::android::hardware::radio::V1_6::OptionalTrafficDescriptor& /*trafficDescriptor*/,
>         bool matchAllRuleAllowed) {
> 
> #if VDBG
>     RLOGD("setupDataCall_1_6: serial %d", serial);
> #endif
> 
>     char *mvnoTypeStr = NULL;
>     if (!convertMvnoTypeToString(MvnoType::IMSI, mvnoTypeStr)) {
>         RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>                 RIL_REQUEST_SETUP_DATA_CALL);
>         if (pRI != NULL) {
>             sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
>         }
>         return Void();
>     }
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 16,
>         std::to_string((int) RadioTechnology::UNKNOWN + 2).c_str(),
>         std::to_string((int) dataProfileInfo.profileId).c_str(),
>         dataProfileInfo.apn.c_str(),
>         dataProfileInfo.user.c_str(),
>         dataProfileInfo.password.c_str(),
>         std::to_string((int) dataProfileInfo.authType).c_str(),
>         getProtocolString(dataProfileInfo.protocol),
>         getProtocolString(dataProfileInfo.roamingProtocol),
>         std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
>         std::to_string(dataProfileInfo.bearerBitmap).c_str(),
>         dataProfileInfo.persistent ? "1" : "0",
>         std::to_string(dataProfileInfo.mtuV4).c_str(),
>         std::to_string(dataProfileInfo.mtuV6).c_str(),
>         mvnoTypeStr,
>         "302720x94",
>         roamingAllowed ? "1" : "0");
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setInitialAttachApn_1_5(int32_t  serial ,
>         const ::android::hardware::radio::V1_5::DataProfileInfo& dataProfileInfo) {
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_INITIAL_ATTACH_APN);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, RESPONSE_SOLICITED, RIL_E_SUCCESS);
> 
>     if (radioService[mSlotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_5->setInitialAttachApnResponse(responseInfo);
>     } else if (radioService[mSlotId]->mRadioResponseV1_4 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_4->setInitialAttachApnResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else if (radioService[mSlotId]->mRadioResponse != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponse->setInitialAttachApnResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setInitialAttachApnResponse: radioService[%d]->mRadioResponse == NULL", mSlotId);
>     }
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setDataProfile_1_5(int32_t  serial ,
>         const hidl_vec<::android::hardware::radio::V1_5::DataProfileInfo>& /* profiles */) {
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_SET_DATA_PROFILE);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, RESPONSE_SOLICITED, RIL_E_SUCCESS);
> 
>     if (radioService[mSlotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_5->setDataProfileResponse(responseInfo);
>     } else if (radioService[mSlotId]->mRadioResponseV1_4 != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponseV1_4->setDataProfileResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else if (radioService[mSlotId]->mRadioResponse != NULL) {
>         Return<void> retStatus
>                 = radioService[mSlotId]->mRadioResponse->setDataProfileResponse(responseInfo);
>         radioService[mSlotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setDataProfileResponse: radioService[%d]->mRadioResponse == NULL", mSlotId);
>     }
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setIndicationFilter_1_5(int32_t serial,
>         hidl_bitfield<::android::hardware::radio::V1_5::IndicationFilter> indicationFilter) {
> #if VDBG
>     RLOGE("setIndicationFilter_1_5: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getBarringInfo(int32_t serial) {
> #if VDBG
>     RLOGD("getBarringInfo: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_BARRING_INFO);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setNetworkSelectionModeManual_1_5(int32_t serial,
>         const hidl_string& operatorNumeric, V1_5::RadioAccessNetworks ran) {
> #if VDBG
>     RLOGD("setNetworkSelectionModeManual_1_6: serial %d", serial);
> #endif
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>         RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_NetworkOperator networkOperator = {};
> 
>     networkOperator.act = (RIL_RadioAccessNetworks)ran;
>     if (!copyHidlStringToRil(&networkOperator.operatorNumeric, operatorNumeric, pRI)) {
>         return Void();
>     }
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &networkOperator,
>         sizeof(networkOperator), pRI, mSlotId);
> 
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::sendCdmaSmsExpectMore(int32_t serial, const CdmaSmsMessage& sms) {
> #if VDBG
>     RLOGD("sendCdmaSmsExpectMore: serial %d", serial);
> #endif
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_CDMA_SMS_Message rcsm = {};
>     constructCdmaSms(rcsm, sms);
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm), pRI, mSlotId);
>     return Void();
> }
> 
> // Methods from ::android::hardware::radio::V1_6::IRadio follow.
> Return<void> RadioImpl_1_6::sendCdmaSmsExpectMore_1_6(int32_t serial, const CdmaSmsMessage& sms) {
> #if VDBG
>     RLOGD("sendCdmaSmsExpectMore: serial %d", serial);
> #endif
>     RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
>             RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_CDMA_SMS_Message rcsm = {};
>     constructCdmaSms(rcsm, sms);
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm), pRI, mSlotId);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::supplySimDepersonalization(int32_t serial,
>         V1_5::PersoSubstate persoType, const hidl_string& controlKey) {
> #if VDBG
>     RLOGD("supplySimDepersonalization: serial %d", serial);
> #endif
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION, true, 1,
>             controlKey.c_str());
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setNrDualConnectivityState(int32_t serial,
>         V1_6::NrDualConnectivityState nrDualConnectivityState) {
> #if VDBG
>     RLOGD("setNrDualConnectivityState: serial %d", serial);
> #endif
>     dispatchInts(serial, mSlotId, RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY, 1,
>             nrDualConnectivityState);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::isNrDualConnectivityEnabled(int32_t serial) {
> #if VDBG
>     RLOGD("isNrDualConnectivityEnabled: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::allocatePduSessionId(int32_t serial) {
> #if VDBG
>     RLOGD("allocatePduSessionId: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_ALLOCATE_PDU_SESSION_ID);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::releasePduSessionId(int32_t serial, int32_t id) {
> #if VDBG
>     RLOGD("releasePduSessionId: serial %d, pduSessionId: %d", serial, id);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_RELEASE_PDU_SESSION_ID);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::startHandover(int32_t serial, int32_t callId) {
> #if VDBG
>     RLOGD("startHandover: serial %d, callId: %d", serial, callId);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_START_HANDOVER);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::cancelHandover(int32_t serial, int32_t callId) {
> #if VDBG
>     RLOGD("cancelHandover: serial %d, callId: %d", serial, callId);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_CANCEL_HANDOVER);
>     return Void();
> }
> 
> 
> Return<void> RadioImpl_1_6::setDataThrottling(int32_t serial, V1_6::DataThrottlingAction dataThrottlingAction, int64_t completionDurationMillis) {
>    #if VDBG
>        RLOGD("OemHookImpl::sendRequestRaw: serial %d", serial);
>    #endif
>        dispatchInts(serial, mSlotId, RIL_REQUEST_SET_DATA_THROTTLING, 2,
>           dataThrottlingAction, completionDurationMillis);
>        return Void();
> }
> 
> Return<void> RadioImpl_1_6::getSystemSelectionChannels(int32_t serial) {
> #if VDBG
>     RLOGD("getSystemSelectionChannels: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getSlicingConfig(int32_t serial) {
> #if VDBG
>     RLOGD("getSlicingConfig: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SLICING_CONFIG);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::setCarrierInfoForImsiEncryption_1_6(
>         int32_t serial, const V1_6::ImsiEncryptionInfo& data) {
> #if VDBG
>     RLOGD("setCarrierInfoForImsiEncryption_1_6: serial %d", serial);
> #endif
>     RequestInfo* pRI = android::addRequestToList(serial, mSlotId,
>                                                  RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION);
>     if (pRI == NULL) {
>         return Void();
>     }
> 
>     RIL_CarrierInfoForImsiEncryption_v16 imsiEncryption = {};
> 
>     if (!copyHidlStringToRil(&imsiEncryption.mnc, data.base.mnc, pRI)) {
>         return Void();
>     }
>     if (!copyHidlStringToRil(&imsiEncryption.mcc, data.base.mcc, pRI)) {
>         memsetAndFreeStrings(1, imsiEncryption.mnc);
>         return Void();
>     }
>     if (!copyHidlStringToRil(&imsiEncryption.keyIdentifier, data.base.keyIdentifier, pRI)) {
>         memsetAndFreeStrings(2, imsiEncryption.mnc, imsiEncryption.mcc);
>         return Void();
>     }
>     imsiEncryption.carrierKeyLength = data.base.carrierKey.size();
>     imsiEncryption.carrierKey = new uint8_t[imsiEncryption.carrierKeyLength];
>     memcpy(imsiEncryption.carrierKey, data.base.carrierKey.data(), imsiEncryption.carrierKeyLength);
>     imsiEncryption.expirationTime = data.base.expirationTime;
>     imsiEncryption.keyType = (RIL_PublicKeyType)data.keyType;
> 
>     CALL_ONREQUEST(pRI->pCI->requestNumber, &imsiEncryption,
>                    sizeof(RIL_CarrierInfoForImsiEncryption_v16), pRI, mSlotId);
>     delete (imsiEncryption.carrierKey);
>     return Void();
> }
> 
> 
> Return<void> RadioImpl_1_6::getSimPhonebookRecords(int32_t serial) {
> #if VDBG
>     RLOGD("getSimPhonebookRecords: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::getSimPhonebookCapacity(int32_t serial) {
> #if VDBG
>     RLOGD("getSimPhonebookCapacity: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY);
>     return Void();
> }
> 
> Return<void> RadioImpl_1_6::updateSimPhonebookRecords(
>     int32_t serial,
>     const ::android::hardware::radio::V1_6::PhonebookRecordInfo& recordInfo) {
> #if VDBG
>     RLOGD("updateSimPhonebookRecords: serial %d", serial);
> #endif
>     dispatchVoid(serial, mSlotId, RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS);
>     return Void();
> }
> 
> 
> // OEM hook methods:
> Return<void> OemHookImpl::setResponseFunctions(
>         const ::android::sp<IOemHookResponse>& oemHookResponseParam,
>         const ::android::sp<IOemHookIndication>& oemHookIndicationParam) {
> #if VDBG
>     RLOGD("OemHookImpl::setResponseFunctions");
> #endif
> 
>     pthread_rwlock_t *radioServiceRwlockPtr = radio_1_6::getRadioServiceRwlock(mSlotId);
>     int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
>     assert(ret == 0);
> 
>     mOemHookResponse = oemHookResponseParam;
>     mOemHookIndication = oemHookIndicationParam;
>     mCounterOemHook[mSlotId]++;
> 
>     ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
>     assert(ret == 0);
> 
>     return Void();
> }
> 
> Return<void> OemHookImpl::sendRequestRaw(int32_t serial, const hidl_vec<uint8_t>& data) {
> #if VDBG
>     RLOGD("OemHookImpl::sendRequestRaw: serial %d", serial);
> #endif
>     dispatchRaw(serial, mSlotId, RIL_REQUEST_OEM_HOOK_RAW, data);
>     return Void();
> }
> 
> Return<void> OemHookImpl::sendRequestStrings(int32_t serial,
>         const hidl_vec<hidl_string>& data) {
> #if VDBG
>     RLOGD("OemHookImpl::sendRequestStrings: serial %d", serial);
> #endif
>     dispatchStrings(serial, mSlotId, RIL_REQUEST_OEM_HOOK_STRINGS, data);
>     return Void();
> }
> 
2901c4777
< void radio::acknowledgeRequest(int slotId, int serial) {
---
> void radio_1_6::acknowledgeRequest(int slotId, int serial) {
2923a4800,4814
> void populateResponseInfo_1_6(
>     ::android::hardware::radio::V1_6::RadioResponseInfo &responseInfo,
>     int serial, int responseType, RIL_Errno e) {
>   responseInfo.serial = serial;
>   switch (responseType) {
>     case RESPONSE_SOLICITED:
>       responseInfo.type = RadioResponseType::SOLICITED;
>       break;
>     case RESPONSE_SOLICITED_ACK_EXP:
>       responseInfo.type = RadioResponseType::SOLICITED_ACK_EXP;
>       break;
>   }
>   responseInfo.error = (::android::hardware::radio::V1_6::RadioError)e;
> }
> 
2958c4849,4864
< int radio::getIccCardStatusResponse(int slotId,
---
> int responseInt_1_6(::android::hardware::radio::V1_6::RadioResponseInfo &responseInfo, int serial, int responseType, RIL_Errno e,
>                void *response, size_t responseLen) {
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
>     int ret = -1;
> 
>     if (response == NULL || responseLen != sizeof(int)) {
>         RLOGE("responseInt_1_6: Invalid response");
>         if (e == RIL_E_SUCCESS) responseInfo.error = ::android::hardware::radio::V1_6::RadioError::INVALID_RESPONSE;
>     } else {
>         int *p_int = (int *) response;
>         ret = p_int[0];
>     }
>     return ret;
> }
> 
> int radio_1_6::getIccCardStatusResponse(int slotId,
2961c4867,4873
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
> #if VDBG
>     RLOGD("getIccCardStatusResponse: serial %d", serial);
> #endif
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL
>         || radioService[slotId]->mRadioResponseV1_4 != NULL
>         || radioService[slotId]->mRadioResponseV1_2 != NULL
>         || radioService[slotId]->mRadioResponse != NULL) {
2965,2969c4877,4882
<         RIL_CardStatus_v6 *p_cur = ((RIL_CardStatus_v6 *) response);
<         if (response == NULL || responseLen != sizeof(RIL_CardStatus_v6)
<                 || p_cur->gsm_umts_subscription_app_index >= p_cur->num_applications
<                 || p_cur->cdma_subscription_app_index >= p_cur->num_applications
<                 || p_cur->ims_subscription_app_index >= p_cur->num_applications) {
---
>         RIL_AppStatus *rilAppStatus = NULL;
>         RIL_CardStatus_v1_5 *p_cur = ((RIL_CardStatus_v1_5 *) response);
>         if (response == NULL || responseLen != sizeof(RIL_CardStatus_v1_5)
>                 || p_cur->base.base.base.gsm_umts_subscription_app_index >= p_cur->base.base.base.num_applications
>                 || p_cur->base.base.base.cdma_subscription_app_index >= p_cur->base.base.base.num_applications
>                 || p_cur->base.base.base.ims_subscription_app_index >= p_cur->base.base.base.num_applications) {
2973,2980c4886,4892
<             cardStatus.cardState = (CardState) p_cur->card_state;
<             cardStatus.universalPinState = (PinState) p_cur->universal_pin_state;
<             cardStatus.gsmUmtsSubscriptionAppIndex = p_cur->gsm_umts_subscription_app_index;
<             cardStatus.cdmaSubscriptionAppIndex = p_cur->cdma_subscription_app_index;
<             cardStatus.imsSubscriptionAppIndex = p_cur->ims_subscription_app_index;
< 
<             RIL_AppStatus *rilAppStatus = p_cur->applications;
<             cardStatus.applications.resize(p_cur->num_applications);
---
>             cardStatus.cardState = (CardState) p_cur->base.base.base.card_state;
>             cardStatus.universalPinState = (PinState) p_cur->base.base.base.universal_pin_state;
>             cardStatus.gsmUmtsSubscriptionAppIndex = p_cur->base.base.base.gsm_umts_subscription_app_index;
>             cardStatus.cdmaSubscriptionAppIndex = p_cur->base.base.base.cdma_subscription_app_index;
>             cardStatus.imsSubscriptionAppIndex = p_cur->base.base.base.ims_subscription_app_index;
>             rilAppStatus = p_cur->base.base.base.applications;
>             cardStatus.applications.resize(p_cur->base.base.base.num_applications);
2983c4895
<             RLOGD("getIccCardStatusResponse: num_applications %d", p_cur->num_applications);
---
>             RLOGD("getIccCardStatusResponse: num_applications %d", p_cur->base.base.base.num_applications);
2985c4897
<             for (int i = 0; i < p_cur->num_applications; i++) {
---
>             for (int i = 0; i < p_cur->base.base.base.num_applications; i++) {
2996a4909,4930
>         if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>             ::android::hardware::radio::V1_2::CardStatus cardStatusV1_2;
>             ::android::hardware::radio::V1_4::CardStatus cardStatusV1_4;
>             ::android::hardware::radio::V1_5::CardStatus cardStatusV1_5;
>             cardStatusV1_2.base = cardStatus;
>             cardStatusV1_2.physicalSlotId = -1;
>             cardStatusV1_2.iccid = convertCharPtrToHidlString(p_cur->base.base.iccid);
>             cardStatusV1_4.base = cardStatusV1_2;
>             cardStatusV1_5.base = cardStatusV1_4;
>             cardStatusV1_5.applications.resize(p_cur->base.base.base.num_applications);
>             for (int i = 0; i < p_cur->base.base.base.num_applications; i++) {
>                 cardStatusV1_5.applications[i].base.appType = (AppType) rilAppStatus[i].app_type;
>                 cardStatusV1_5.applications[i].base.appState = (AppState) rilAppStatus[i].app_state;
>                 cardStatusV1_5.applications[i].base.persoSubstate = (PersoSubstate) rilAppStatus[i].perso_substate;
>                 cardStatusV1_5.applications[i].base.aidPtr = convertCharPtrToHidlString(rilAppStatus[i].aid_ptr);
>                 cardStatusV1_5.applications[i].base.appLabelPtr = convertCharPtrToHidlString(
>                         rilAppStatus[i].app_label_ptr);
>                 cardStatusV1_5.applications[i].base.pin1Replaced = rilAppStatus[i].pin1_replaced;
>                 cardStatusV1_5.applications[i].base.pin1 = (PinState) rilAppStatus[i].pin1;
>                 cardStatusV1_5.applications[i].base.pin2 = (PinState) rilAppStatus[i].pin2;
>                 cardStatusV1_5.applications[i].persoSubstate = (V1_5::PersoSubstate)rilAppStatus[i].perso_substate;
>             }
2998,3000c4932,4971
<         Return<void> retStatus = radioService[slotId]->mRadioResponse->
<                 getIccCardStatusResponse(responseInfo, cardStatus);
<         radioService[slotId]->checkReturnStatus(retStatus);
---
>             // If POWER_DOWN then set applications to empty
>             if (radioService[slotId]->mSimCardPowerState == V1_1::CardPowerState::POWER_DOWN) {
>                 RLOGD("getIccCardStatusResponse: state is POWER_DOWN so clearing apps");
>                 cardStatusV1_5.applications = {};
>             }
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5->
>                     getIccCardStatusResponse_1_5(responseInfo, cardStatusV1_5);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>             ::android::hardware::radio::V1_2::CardStatus cardStatusV1_2;
>             ::android::hardware::radio::V1_4::CardStatus cardStatusV1_4;
>             cardStatusV1_2.base = cardStatus;
>             cardStatusV1_2.physicalSlotId = -1;
>             cardStatusV1_2.iccid = convertCharPtrToHidlString(p_cur->base.base.iccid);
>             cardStatusV1_4.base = cardStatusV1_2;
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4->
>                     getIccCardStatusResponse_1_4(responseInfo, cardStatusV1_4);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_3 != NULL) {
>             ::android::hardware::radio::V1_2::CardStatus cardStatusV1_2;
>             cardStatusV1_2.base = cardStatus;
>             cardStatusV1_2.physicalSlotId = -1;
>             cardStatusV1_2.iccid = convertCharPtrToHidlString(p_cur->base.base.iccid);
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_3->
>                     getIccCardStatusResponse_1_2(responseInfo, cardStatusV1_2);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>             ::android::hardware::radio::V1_2::CardStatus cardStatusV1_2;
>             cardStatusV1_2.base = cardStatus;
>             cardStatusV1_2.physicalSlotId = -1;
>             cardStatusV1_2.iccid = convertCharPtrToHidlString(p_cur->base.base.iccid);
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2->
>                     getIccCardStatusResponse_1_2(responseInfo, cardStatusV1_2);
>             radioService[slotId]->checkReturnStatus(retStatus);
>             // TODO: add 1.1 if needed.
>         } else {
>             Return<void> retStatus = radioService[slotId]->mRadioResponse->
>                     getIccCardStatusResponse(responseInfo, cardStatus);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         }
3004d4974
< 
3008c4978
< int radio::supplyIccPinForAppResponse(int slotId,
---
> int radio_1_6::supplyIccPinForAppResponse(int slotId,
3030c5000
< int radio::supplyIccPukForAppResponse(int slotId,
---
> int radio_1_6::supplyIccPukForAppResponse(int slotId,
3051c5021
< int radio::supplyIccPin2ForAppResponse(int slotId,
---
> int radio_1_6::supplyIccPin2ForAppResponse(int slotId,
3072c5042
< int radio::supplyIccPuk2ForAppResponse(int slotId,
---
> int radio_1_6::supplyIccPuk2ForAppResponse(int slotId,
3093c5063
< int radio::changeIccPinForAppResponse(int slotId,
---
> int radio_1_6::changeIccPinForAppResponse(int slotId,
3114c5084
< int radio::changeIccPin2ForAppResponse(int slotId,
---
> int radio_1_6::changeIccPin2ForAppResponse(int slotId,
3135c5105
< int radio::supplyNetworkDepersonalizationResponse(int slotId,
---
> int radio_1_6::supplyNetworkDepersonalizationResponse(int slotId,
3156c5126
< int radio::getCurrentCallsResponse(int slotId,
---
> int radio_1_6::getCurrentCallsResponse(int slotId,
3163c5133,5142
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioIndicationV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>         hidl_vec<::android::hardware::radio::V1_6::Call> calls_1_6;
> 
>         // TODO: future implementation needs
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->
>                 getCurrentCallsResponse_1_6(responseInfo_1_6, calls_1_6);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
3214c5193
< int radio::dialResponse(int slotId,
---
> int radio_1_6::dialResponse(int slotId,
3233c5212
< int radio::getIMSIForAppResponse(int slotId,
---
> int radio_1_6::getIMSIForAppResponse(int slotId,
3254c5233
< int radio::hangupConnectionResponse(int slotId,
---
> int radio_1_6::hangupConnectionResponse(int slotId,
3275c5254
< int radio::hangupWaitingOrBackgroundResponse(int slotId,
---
> int radio_1_6::hangupWaitingOrBackgroundResponse(int slotId,
3297c5276
< int radio::hangupForegroundResumeBackgroundResponse(int slotId, int responseType, int serial,
---
> int radio_1_6::hangupForegroundResumeBackgroundResponse(int slotId, int responseType, int serial,
3319c5298
< int radio::switchWaitingOrHoldingAndActiveResponse(int slotId, int responseType, int serial,
---
> int radio_1_6::switchWaitingOrHoldingAndActiveResponse(int slotId, int responseType, int serial,
3341c5320
< int radio::conferenceResponse(int slotId, int responseType,
---
> int radio_1_6::conferenceResponse(int slotId, int responseType,
3361c5340
< int radio::rejectCallResponse(int slotId, int responseType,
---
> int radio_1_6::rejectCallResponse(int slotId, int responseType,
3381c5360
< int radio::getLastCallFailCauseResponse(int slotId,
---
> int radio_1_6::getLastCallFailCauseResponse(int slotId,
3420c5399
< int radio::getSignalStrengthResponse(int slotId,
---
> int radio_1_6::getSignalStrengthResponse(int slotId,
3427c5406,5422
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         ::android::hardware::radio::V1_4::SignalStrength signalStrength_1_4 = {};
>         if (response == NULL || responseLen != sizeof(RIL_SignalStrength_v12)) {
>             RLOGE("getSignalStrengthResponse: Invalid response");
>             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>         } else {
>             convertRilSignalStrengthToHal_1_4(response, responseLen, signalStrength_1_4);
>         }
> 
>         //TODO: future implementation needs to fill tdScdma, wcdma and nr signal strength.
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4->
>                 getSignalStrengthResponse_1_4(responseInfo, signalStrength_1_4);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
3431c5426
<         if (response == NULL || responseLen != sizeof(RIL_SignalStrength_v10)) {
---
>         if (response == NULL || responseLen != sizeof(RIL_SignalStrength_v12)) {
3513c5508
<                     ril::util::mcc::decode(rilCellIdentity.cellIdentityGsm.mcc);
---
>                     std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
3516,3520d5510
< 
<             if (cellIdentity.cellIdentityGsm[0].mcc == "-1") {
<                 cellIdentity.cellIdentityGsm[0].mcc = "";
<             }
< 
3531c5521
<                     ril::util::mcc::decode(rilCellIdentity.cellIdentityWcdma.mcc);
---
>                     std::to_string(rilCellIdentity.cellIdentityWcdma.mcc);
3534,3538d5523
< 
<             if (cellIdentity.cellIdentityWcdma[0].mcc == "-1") {
<                 cellIdentity.cellIdentityWcdma[0].mcc = "";
<             }
< 
3560c5545
<                     ril::util::mcc::decode(rilCellIdentity.cellIdentityLte.mcc);
---
>                     std::to_string(rilCellIdentity.cellIdentityLte.mcc);
3563,3567d5547
< 
<             if (cellIdentity.cellIdentityLte[0].mcc == "-1") {
<                 cellIdentity.cellIdentityLte[0].mcc = "";
<             }
< 
3578c5558
<                     ril::util::mcc::decode(rilCellIdentity.cellIdentityTdscdma.mcc);
---
>                     std::to_string(rilCellIdentity.cellIdentityTdscdma.mcc);
3581,3585d5560
< 
<             if (cellIdentity.cellIdentityTdscdma[0].mcc == "-1") {
<                 cellIdentity.cellIdentityTdscdma[0].mcc = "";
<             }
< 
3597a5573,5753
> void fillCellIdentityResponse_1_5(V1_5::CellIdentity &cellIdentity,
>                                   RIL_CellIdentity_v16 &rilCellIdentity) {
> 
>     switch (rilCellIdentity.cellInfoType) {
>         case RIL_CELL_INFO_TYPE_GSM: {
>             V1_5::CellIdentityGsm gsm;
>             gsm.base.base.mcc = std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
>             gsm.base.base.mnc = ril::util::mnc::decode(rilCellIdentity.cellIdentityGsm.mnc);
>             if (gsm.base.base.mcc == "-1") {
>                 gsm.base.base.mcc = "";
>             }
>             gsm.base.base.lac = rilCellIdentity.cellIdentityGsm.lac;
>             gsm.base.base.cid = rilCellIdentity.cellIdentityGsm.cid;
>             gsm.base.base.arfcn = rilCellIdentity.cellIdentityGsm.arfcn;
>             gsm.base.base.bsic = rilCellIdentity.cellIdentityGsm.bsic;
>             cellIdentity.gsm(gsm);
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_WCDMA: {
>             V1_5::CellIdentityWcdma wcdma;
>             wcdma.base.base.mcc = std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
>             wcdma.base.base.mnc = ril::util::mnc::decode(rilCellIdentity.cellIdentityWcdma.mnc);
>             if (wcdma.base.base.mcc == "-1") {
>                 wcdma.base.base.mcc = "";
>             }
>             wcdma.base.base.lac = rilCellIdentity.cellIdentityWcdma.lac;
>             wcdma.base.base.cid = rilCellIdentity.cellIdentityWcdma.cid;
>             wcdma.base.base.psc = rilCellIdentity.cellIdentityWcdma.psc;
>             wcdma.base.base.uarfcn = rilCellIdentity.cellIdentityWcdma.uarfcn;
>             cellIdentity.wcdma(wcdma);
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_CDMA: {
>             V1_2::CellIdentityCdma cdma;
>             cdma.base.networkId = rilCellIdentity.cellIdentityCdma.networkId;
>             cdma.base.systemId = rilCellIdentity.cellIdentityCdma.systemId;
>             cdma.base.baseStationId =
>                     rilCellIdentity.cellIdentityCdma.basestationId;
>             cdma.base.longitude = rilCellIdentity.cellIdentityCdma.longitude;
>             cdma.base.latitude = rilCellIdentity.cellIdentityCdma.latitude;
>             cellIdentity.cdma(cdma);
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_LTE: {
>             V1_5::CellIdentityLte lte;
>             lte.base.base.mcc = std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
>             lte.base.base.mnc = ril::util::mnc::decode(rilCellIdentity.cellIdentityLte.mnc);
>             if (lte.base.base.mcc == "-1") {
>                 lte.base.base.mcc = "";
>             }
>             lte.base.base.ci = rilCellIdentity.cellIdentityLte.ci;
>             lte.base.base.pci = rilCellIdentity.cellIdentityLte.pci;
>             lte.base.base.tac = rilCellIdentity.cellIdentityLte.tac;
>             lte.base.base.earfcn = rilCellIdentity.cellIdentityLte.earfcn;
>             cellIdentity.lte(lte);
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_TD_SCDMA: {
>             V1_5::CellIdentityTdscdma tdscdma;
>             tdscdma.base.base.mcc = std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
>             tdscdma.base.base.mnc = ril::util::mnc::decode(rilCellIdentity.cellIdentityTdscdma.mnc);
>             if (tdscdma.base.base.mcc == "-1") {
>                 tdscdma.base.base.mcc = "";
>             }
>             tdscdma.base.base.lac = rilCellIdentity.cellIdentityTdscdma.lac;
>             tdscdma.base.base.cid = rilCellIdentity.cellIdentityTdscdma.cid;
>             tdscdma.base.base.cpid = rilCellIdentity.cellIdentityTdscdma.cpid;
>             cellIdentity.tdscdma(tdscdma);
>             break;
>         }
> 
>         default: {
>             break;
>         }
>     }
> }
> 
> void fillCellIdentityResponse_1_2(V1_2::CellIdentity &cellIdentity,
>                                   RIL_CellIdentity_v1_2 &rilCellIdentity) {
>     cellIdentity.cellIdentityGsm.resize(0);
>     cellIdentity.cellIdentityWcdma.resize(0);
>     cellIdentity.cellIdentityCdma.resize(0);
>     cellIdentity.cellIdentityTdscdma.resize(0);
>     cellIdentity.cellIdentityLte.resize(0);
>     cellIdentity.cellInfoType = (CellInfoType)rilCellIdentity.cellInfoType;
>     switch(rilCellIdentity.cellInfoType) {
> 
>         case RIL_CELL_INFO_TYPE_GSM: {
>             cellIdentity.cellIdentityGsm.resize(1);
>             cellIdentity.cellIdentityGsm[0].base.mcc =
>                 std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
>             cellIdentity.cellIdentityGsm[0].base.mnc =
>                     ril::util::mnc::decode(rilCellIdentity.cellIdentityGsm.mnc);
> 
>             if (cellIdentity.cellIdentityGsm[0].base.mcc == "-1") {
>                 cellIdentity.cellIdentityGsm[0].base.mcc = "";
>             }
> 
>             cellIdentity.cellIdentityGsm[0].base.lac = rilCellIdentity.cellIdentityGsm.lac;
>             cellIdentity.cellIdentityGsm[0].base.cid = rilCellIdentity.cellIdentityGsm.cid;
>             cellIdentity.cellIdentityGsm[0].base.arfcn = rilCellIdentity.cellIdentityGsm.arfcn;
>             cellIdentity.cellIdentityGsm[0].base.bsic = rilCellIdentity.cellIdentityGsm.bsic;
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_WCDMA: {
>             cellIdentity.cellIdentityWcdma.resize(1);
>             cellIdentity.cellIdentityWcdma[0].base.mcc =
>                 std::to_string(rilCellIdentity.cellIdentityWcdma.mcc);
>             cellIdentity.cellIdentityWcdma[0].base.mnc =
>                     ril::util::mnc::decode(rilCellIdentity.cellIdentityWcdma.mnc);
> 
>             if (cellIdentity.cellIdentityWcdma[0].base.mcc == "-1") {
>                 cellIdentity.cellIdentityWcdma[0].base.mcc = "";
>             }
> 
>             cellIdentity.cellIdentityWcdma[0].base.lac = rilCellIdentity.cellIdentityWcdma.lac;
>             cellIdentity.cellIdentityWcdma[0].base.cid = rilCellIdentity.cellIdentityWcdma.cid;
>             cellIdentity.cellIdentityWcdma[0].base.psc = rilCellIdentity.cellIdentityWcdma.psc;
>             cellIdentity.cellIdentityWcdma[0].base.uarfcn = rilCellIdentity.cellIdentityWcdma.uarfcn;
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_CDMA: {
>             cellIdentity.cellIdentityCdma.resize(1);
>             cellIdentity.cellIdentityCdma[0].base.networkId = rilCellIdentity.cellIdentityCdma.networkId;
>             cellIdentity.cellIdentityCdma[0].base.systemId = rilCellIdentity.cellIdentityCdma.systemId;
>             cellIdentity.cellIdentityCdma[0].base.baseStationId =
>                     rilCellIdentity.cellIdentityCdma.basestationId;
>             cellIdentity.cellIdentityCdma[0].base.longitude = rilCellIdentity.cellIdentityCdma.longitude;
>             cellIdentity.cellIdentityCdma[0].base.latitude = rilCellIdentity.cellIdentityCdma.latitude;
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_LTE: {
>             cellIdentity.cellIdentityLte.resize(1);
>             cellIdentity.cellIdentityLte[0].base.mcc =
>                 std::to_string(rilCellIdentity.cellIdentityLte.mcc);
>             cellIdentity.cellIdentityLte[0].base.mnc =
>                     ril::util::mnc::decode(rilCellIdentity.cellIdentityLte.mnc);
> 
>             if (cellIdentity.cellIdentityLte[0].base.mcc == "-1") {
>                 cellIdentity.cellIdentityLte[0].base.mcc = "";
>             }
> 
>             cellIdentity.cellIdentityLte[0].base.ci = rilCellIdentity.cellIdentityLte.ci;
>             cellIdentity.cellIdentityLte[0].base.pci = rilCellIdentity.cellIdentityLte.pci;
>             cellIdentity.cellIdentityLte[0].base.tac = rilCellIdentity.cellIdentityLte.tac;
>             cellIdentity.cellIdentityLte[0].base.earfcn = rilCellIdentity.cellIdentityLte.earfcn;
>             cellIdentity.cellIdentityLte[0].bandwidth = rilCellIdentity.cellIdentityLte.bandwidth;
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_TD_SCDMA: {
>             cellIdentity.cellIdentityTdscdma.resize(1);
>             cellIdentity.cellIdentityTdscdma[0].base.mcc =
>                 std::to_string(rilCellIdentity.cellIdentityTdscdma.mcc);
>             cellIdentity.cellIdentityTdscdma[0].base.mnc =
>                     ril::util::mnc::decode(rilCellIdentity.cellIdentityTdscdma.mnc);
> 
>             if (cellIdentity.cellIdentityTdscdma[0].base.mcc == "-1") {
>                 cellIdentity.cellIdentityTdscdma[0].base.mcc = "";
>             }
> 
>             cellIdentity.cellIdentityTdscdma[0].base.lac = rilCellIdentity.cellIdentityTdscdma.lac;
>             cellIdentity.cellIdentityTdscdma[0].base.cid = rilCellIdentity.cellIdentityTdscdma.cid;
>             cellIdentity.cellIdentityTdscdma[0].base.cpid = rilCellIdentity.cellIdentityTdscdma.cpid;
>             cellIdentity.cellIdentityTdscdma[0].uarfcn = rilCellIdentity.cellIdentityTdscdma.uarfcn;
>             break;
>         }
> 
>         default: {
>             break;
>         }
>     }
> }
> 
3620c5776
< void fillCellIdentityFromVoiceRegStateResponseString(CellIdentity &cellIdentity,
---
> void fillCellIdentityFromVoiceRegStateResponseString(V1_5::CellIdentity &cellIdentity,
3636a5793,5800
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
3649a5814,5821
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
3660a5833,5840
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
3686a5867,5874
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
3695c5883,5993
<     fillCellIdentityResponse(cellIdentity, rilCellIdentity);
---
>     fillCellIdentityResponse_1_5(cellIdentity, rilCellIdentity);
> }
> 
> void fillCellIdentityFromVoiceRegStateResponseString_1_2(V1_2::CellIdentity &cellIdentity,
>         int numStrings, char** response) {
>     RIL_CellIdentity_v1_2 rilCellIdentity;
>     memset(&rilCellIdentity, -1, sizeof(RIL_CellIdentity_v1_2));
> 
>     rilCellIdentity.cellInfoType = getCellInfoTypeRadioTechnology(response[3]);
> 
>     switch(rilCellIdentity.cellInfoType) {
>         case RIL_CELL_INFO_TYPE_GSM: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityGsm.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityGsm.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_WCDMA: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityWcdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityWcdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
>             rilCellIdentity.cellIdentityWcdma.psc =
>                     convertResponseStringEntryToInt(response, 14, numStrings);
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityWcdma.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityWcdma.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_TD_SCDMA:{
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityTdscdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityTdscdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityTdscdma.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityTdscdma.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_CDMA:{
>             rilCellIdentity.cellIdentityCdma.basestationId =
>                     convertResponseStringEntryToInt(response, 4, numStrings);
>             /* Order of Lat. and Long. swapped between RIL and HIDL interface versions. */
>             rilCellIdentity.cellIdentityCdma.latitude =
>                     convertResponseStringEntryToInt(response, 5, numStrings);
>             rilCellIdentity.cellIdentityCdma.longitude =
>                     convertResponseStringEntryToInt(response, 6, numStrings);
>             rilCellIdentity.cellIdentityCdma.systemId =
>                     convertResponseStringEntryToInt(response, 8, numStrings);
>             rilCellIdentity.cellIdentityCdma.networkId =
>                     convertResponseStringEntryToInt(response, 9, numStrings);
>             break;
>         }
> 
>         case RIL_CELL_INFO_TYPE_LTE:{
>             /* valid TAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityLte.tac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityLte.ci =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings > 15) {
>                 rilCellIdentity.cellIdentityLte.mcc =
>                         convertResponseStringEntryToInt(response, 15, numStrings);
> 
>                 rilCellIdentity.cellIdentityLte.mnc =
>                         convertResponseStringEntryToInt(response, 16, numStrings);
>             }
>             rilCellIdentity.cellIdentityLte.bandwidth = INT_MAX;
>             break;
>         }
> 
>         default: {
>             break;
>         }
>     }
> 
>     fillCellIdentityResponse_1_2(cellIdentity, rilCellIdentity);
3703c6001
< void fillCellIdentityFromDataRegStateResponseString(CellIdentity &cellIdentity,
---
> void fillCellIdentityFromDataRegStateResponseString_1_5(V1_5::CellIdentity &cellIdentity,
3725a6024,6027
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityGsm.mnc = 0;
>                 rilCellIdentity.cellIdentityGsm.mcc = 0;
3743a6046,6049
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityWcdma.mnc = 0;
>                 rilCellIdentity.cellIdentityWcdma.mcc = 0;
3761a6068,6071
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityTdscdma.mnc = 0;
>                 rilCellIdentity.cellIdentityTdscdma.mcc = 0;
3778a6089,6092
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityLte.mnc = 0;
>                 rilCellIdentity.cellIdentityLte.mcc = 0;
3786a6101,6309
>     fillCellIdentityResponse_1_5(cellIdentity, rilCellIdentity);
> }
> 
> void fillCellIdentityFromDataRegStateResponseString_1_2(V1_2::CellIdentity &cellIdentity,
>         int numStrings, char** response) {
> 
>     RIL_CellIdentity_v1_2 rilCellIdentity;
>     memset(&rilCellIdentity, -1, sizeof(RIL_CellIdentity_v1_2));
> 
>     rilCellIdentity.cellInfoType = getCellInfoTypeRadioTechnology(response[3]);
>     switch(rilCellIdentity.cellInfoType) {
>         case RIL_CELL_INFO_TYPE_GSM: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityGsm.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityGsm.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityGsm.mnc = 0;
>                 rilCellIdentity.cellIdentityGsm.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_WCDMA: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityWcdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityWcdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityWcdma.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityWcdma.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityWcdma.mnc = 0;
>                 rilCellIdentity.cellIdentityWcdma.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_TD_SCDMA: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityTdscdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityTdscdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityTdscdma.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityTdscdma.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityTdscdma.mnc = 0;
>                 rilCellIdentity.cellIdentityTdscdma.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_LTE: {
>             rilCellIdentity.cellIdentityLte.tac =
>                     convertResponseStringEntryToInt(response, 6, numStrings);
>             rilCellIdentity.cellIdentityLte.pci =
>                     convertResponseStringEntryToInt(response, 7, numStrings);
>             rilCellIdentity.cellIdentityLte.ci =
>                     convertResponseStringEntryToInt(response, 8, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityLte.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityLte.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityLte.mnc = 0;
>                 rilCellIdentity.cellIdentityLte.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_CDMA: {
>             break;
>         }
>         default: {
>             break;
>         }
>     }
> 
>     fillCellIdentityResponse_1_2(cellIdentity, rilCellIdentity);
> }
> 
> void fillCellIdentityFromDataRegStateResponseString(CellIdentity &cellIdentity,
>         int numStrings, char** response) {
> 
>     RIL_CellIdentity_v16 rilCellIdentity;
>     memset(&rilCellIdentity, -1, sizeof(RIL_CellIdentity_v16));
> 
>     rilCellIdentity.cellInfoType = getCellInfoTypeRadioTechnology(response[3]);
>     switch(rilCellIdentity.cellInfoType) {
>         case RIL_CELL_INFO_TYPE_GSM: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityGsm.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityGsm.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityGsm.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityGsm.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityGsm.mnc = 0;
>                 rilCellIdentity.cellIdentityGsm.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_WCDMA: {
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityWcdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityWcdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityWcdma.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityWcdma.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityWcdma.mnc = 0;
>                 rilCellIdentity.cellIdentityWcdma.mcc = 0;
>             }
> 
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_TD_SCDMA:{
>             /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
>             rilCellIdentity.cellIdentityTdscdma.lac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
> 
>             /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
>             rilCellIdentity.cellIdentityTdscdma.cid =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityTdscdma.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityTdscdma.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityTdscdma.mnc = 0;
>                 rilCellIdentity.cellIdentityTdscdma.mcc = 0;
>             }
>             break;
>         }
>         case RIL_CELL_INFO_TYPE_LTE: {
>             rilCellIdentity.cellIdentityLte.tac =
>                     convertResponseHexStringEntryToInt(response, 1, numStrings);
>             rilCellIdentity.cellIdentityLte.ci =
>                     convertResponseHexStringEntryToInt(response, 2, numStrings);
> 
>             if (numStrings >= 13) {
>                 rilCellIdentity.cellIdentityLte.mcc =
>                         convertResponseStringEntryToInt(response, 11, numStrings);
> 
>                 rilCellIdentity.cellIdentityLte.mnc =
>                         convertResponseStringEntryToInt(response, 12, numStrings);
>             } else {
>                 /* vts check the mcc [0, 999] and mnc [0, 999]. */
>                 rilCellIdentity.cellIdentityLte.mnc = 0;
>                 rilCellIdentity.cellIdentityLte.mcc = 0;
>             }
>             break;
>         }
>         // TODO add CDMA
>         default: {
>             break;
>         }
>     }
> 
3790c6313
< int radio::getVoiceRegistrationStateResponse(int slotId,
---
> int radio_1_6::getVoiceRegistrationStateResponse(int slotId,
3797c6320,6323
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponse != NULL ||
>         radioService[slotId]->mRadioResponseV1_2 != NULL ||
>         radioService[slotId]->mRadioResponseV1_5 != NULL ||
>         radioService[slotId]->mRadioResponseV1_6 != NULL) {
3804,3808c6330,6475
<                RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
<                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
<         } else if (s_vendorFunctions->version <= 14) {
<             if (numStrings != 15) {
<                 RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
---
>             RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
>             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
> 
>             // TODO: future implementation needs
>             Return<void> retStatus;
>             if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>                 ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>                 populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>                 RegStateResultV1_6 regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_6->
>                                          getVoiceRegistrationStateResponse_1_6(
>                                                  responseInfo_1_6, regResponse);
>             } else if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>                 RegStateResultV1_5 regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_5->
>                                          getVoiceRegistrationStateResponse_1_5(
>                                                  responseInfo, regResponse);
>             } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>                 V1_2::VoiceRegStateResult regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_2->
>                                          getVoiceRegistrationStateResponse_1_2(
>                                                  responseInfo, regResponse);
>             } else {
>                 VoiceRegStateResult regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponse->
>                                          getVoiceRegistrationStateResponse(
>                                                  responseInfo, regResponse);
>             }
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (s_vendorFunctions->version >= 15 &&
>                    radioService[slotId]->mRadioResponseV1_6 != NULL) {
>             ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>             populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>             RegStateResultV1_6 regResponse = {};
>             if (numStrings != 18) {
>                 RLOGE("getVoiceRegistrationStateResponse_1_6 Invalid response: NULL");
>                 if (e == RIL_E_SUCCESS) responseInfo_1_6.error =
>                         ::android::hardware::radio::V1_6::RadioError::INVALID_RESPONSE;
>             } else {
>                 char **resp = (char **) response;
>                 regResponse.regState = (RegState)ATOI_NULL_HANDLED_DEF(resp[0], 4);
>                 int rat = ATOI_NULL_HANDLED_DEF(resp[3], 0);
>                 regResponse.rat = (V1_4::RadioTechnology)rat;
>                 if (rat == RADIO_TECH_EVDO_0 || rat == RADIO_TECH_EVDO_A ||
>                     rat == RADIO_TECH_EVDO_B || rat == RADIO_TECH_1xRTT ||
>                     rat == RADIO_TECH_IS95A || rat == RADIO_TECH_IS95B ||
>                     rat == RADIO_TECH_EHRPD) {
>                     V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                             Cdma2000RegistrationInfo cdmaInfo;
>                     cdmaInfo.cssSupported = ATOI_NULL_HANDLED_DEF(resp[7], 0);
>                     cdmaInfo.roamingIndicator = ATOI_NULL_HANDLED(resp[10]);
>                     cdmaInfo.systemIsInPrl = (V1_5::PrlIndicator)ATOI_NULL_HANDLED_DEF(resp[11], 0);
>                     cdmaInfo.defaultRoamingIndicator= ATOI_NULL_HANDLED_DEF(resp[12], 0);
>                     regResponse.accessTechnologySpecificInfo.cdmaInfo(cdmaInfo);
>                 } else if (rat == RADIO_TECH_NR) {
>                     // rat is NR only for NR SA
>                     V1_6::NrVopsInfo nrVopsInfo;
>                     nrVopsInfo.vopsSupported =
>                             ::android::hardware::radio::V1_6::VopsIndicator::VOPS_NOT_SUPPORTED;
>                     nrVopsInfo.emcSupported =
>                             ::android::hardware::radio::V1_6::EmcIndicator::EMC_NOT_SUPPORTED;
>                     nrVopsInfo.emfSupported =
>                             ::android::hardware::radio::V1_6::EmfIndicator::EMF_NOT_SUPPORTED;
>                     regResponse.accessTechnologySpecificInfo.ngranNrVopsInfo(nrVopsInfo);
> 
>                 } else {
>                     V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                         EutranRegistrationInfo eutranInfo;
>                     if (rat == RADIO_TECH_LTE || rat == RADIO_TECH_LTE_CA) {
>                         eutranInfo.lteVopsInfo.isVopsSupported = false;
>                         eutranInfo.lteVopsInfo.isEmcBearerSupported = false;
>                     }
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     eutranInfo.nrIndicators.isDcNrRestricted = false;
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     regResponse.accessTechnologySpecificInfo.eutranInfo(eutranInfo);
>                 }
>                 regResponse.reasonForDenial = (V1_5::RegistrationFailCause)
>                         ATOI_NULL_HANDLED_DEF(resp[13], 0);
>                 regResponse.registeredPlmn = convertCharPtrToHidlString(resp[17]);
> 
>                 fillCellIdentityFromVoiceRegStateResponseString(regResponse.cellIdentity,
>                         numStrings, resp);
> 
>                 Return<void> retStatus =
>                     radioService[slotId]
>                         ->mRadioResponseV1_6
>                         ->getVoiceRegistrationStateResponse_1_6(
>                             responseInfo_1_6, regResponse);
>                 radioService[slotId]->checkReturnStatus(retStatus);
>             }
>         } else if (s_vendorFunctions->version <= 14 &&
>                    radioService[slotId]->mRadioResponseV1_5 != NULL) {
>             RegStateResultV1_5 regResponse = {};
>             if (numStrings != 18) {
>                 RLOGE("getVoiceRegistrationStateResponse_1_5 Invalid response: NULL");
>                 if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>             } else {
>                 char **resp = (char **) response;
>                 regResponse.regState = (RegState)ATOI_NULL_HANDLED_DEF(resp[0], 4);
>                 int rat = ATOI_NULL_HANDLED_DEF(resp[3], 0);
>                 regResponse.rat = (V1_4::RadioTechnology)rat;
>                 if (rat == RADIO_TECH_EVDO_0 || rat == RADIO_TECH_EVDO_A ||
>                     rat == RADIO_TECH_EVDO_B || rat == RADIO_TECH_1xRTT ||
>                     rat == RADIO_TECH_IS95A || rat == RADIO_TECH_IS95B ||
>                     rat == RADIO_TECH_EHRPD) {
>                     V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                             Cdma2000RegistrationInfo cdmaInfo;
>                     cdmaInfo.cssSupported = ATOI_NULL_HANDLED_DEF(resp[7], 0);
>                     cdmaInfo.roamingIndicator = ATOI_NULL_HANDLED(resp[10]);
>                     cdmaInfo.systemIsInPrl = (V1_5::PrlIndicator)ATOI_NULL_HANDLED_DEF(resp[11], 0);
>                     cdmaInfo.defaultRoamingIndicator= ATOI_NULL_HANDLED_DEF(resp[12], 0);
>                     regResponse.accessTechnologySpecificInfo.cdmaInfo(cdmaInfo);
>                 } else {
>                     V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                         EutranRegistrationInfo eutranInfo;
>                     if (rat == RADIO_TECH_LTE || rat == RADIO_TECH_LTE_CA ||
>                         rat == RADIO_TECH_NR) {
>                         eutranInfo.lteVopsInfo.isVopsSupported = false;
>                         eutranInfo.lteVopsInfo.isEmcBearerSupported = false;
>                     }
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     eutranInfo.nrIndicators.isDcNrRestricted = false;
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     regResponse.accessTechnologySpecificInfo.eutranInfo(eutranInfo);
>                 }
>                 regResponse.reasonForDenial = (V1_5::RegistrationFailCause)
>                         ATOI_NULL_HANDLED_DEF(resp[13], 0);
>                 regResponse.registeredPlmn = convertCharPtrToHidlString(resp[17]);
> 
>                 fillCellIdentityFromVoiceRegStateResponseString(regResponse.cellIdentity,
>                         numStrings, resp);
> 
>                 Return<void> retStatus =
>                     radioService[slotId]
>                         ->mRadioResponseV1_5
>                         ->getVoiceRegistrationStateResponse_1_5(
>                             responseInfo, regResponse);
>                 radioService[slotId]->checkReturnStatus(retStatus);
>             }
>         } else if (s_vendorFunctions->version <= 14 &&
>                       radioService[slotId]->mRadioResponseV1_2 != NULL) {
>             V1_2::VoiceRegStateResult voiceRegResponse = {};
>             int numStrings = responseLen / sizeof(char *);
>             if (numStrings != 18) {
>                 RLOGE("getVoiceRegistrationStateResponse_1_21 Invalid response: NULL");
3813c6480
<                 voiceRegResponse.rat = ATOI_NULL_HANDLED(resp[3]);
---
>                 voiceRegResponse.rat = ATOI_NULL_HANDLED_DEF(resp[3], 0);
3819,3821c6486,6491
<                 fillCellIdentityFromVoiceRegStateResponseString(voiceRegResponse.cellIdentity,
<                         numStrings, resp);
<             }
---
>                 fillCellIdentityFromVoiceRegStateResponseString_1_2(
>                         voiceRegResponse.cellIdentity, numStrings, resp);
>               }
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2->
>                     getVoiceRegistrationStateResponse_1_2(responseInfo, voiceRegResponse);
>             radioService[slotId]->checkReturnStatus(retStatus);
3823c6493
<             RIL_VoiceRegistrationStateResponse *voiceRegState =
---
>               RIL_VoiceRegistrationStateResponse *voiceRegState =
3825,3839c6495,6512
< 
<             if (responseLen != sizeof(RIL_VoiceRegistrationStateResponse)) {
<                 RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
<                 if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
<             } else {
<                 voiceRegResponse.regState = (RegState) voiceRegState->regState;
<                 voiceRegResponse.rat = voiceRegState->rat;;
<                 voiceRegResponse.cssSupported = voiceRegState->cssSupported;
<                 voiceRegResponse.roamingIndicator = voiceRegState->roamingIndicator;
<                 voiceRegResponse.systemIsInPrl = voiceRegState->systemIsInPrl;
<                 voiceRegResponse.defaultRoamingIndicator = voiceRegState->defaultRoamingIndicator;
<                 voiceRegResponse.reasonForDenial = voiceRegState->reasonForDenial;
<                 fillCellIdentityResponse(voiceRegResponse.cellIdentity,
<                         voiceRegState->cellIdentity);
<             }
---
>               if (responseLen != sizeof(RIL_VoiceRegistrationStateResponse)) {
>                   RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
>                   if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>               } else {
>                   voiceRegResponse.regState = (RegState) voiceRegState->regState;
>                   voiceRegResponse.rat = voiceRegState->rat;;
>                   voiceRegResponse.cssSupported = voiceRegState->cssSupported;
>                   voiceRegResponse.roamingIndicator = voiceRegState->roamingIndicator;
>                   voiceRegResponse.systemIsInPrl = voiceRegState->systemIsInPrl;
>                   voiceRegResponse.defaultRoamingIndicator = voiceRegState->defaultRoamingIndicator;
>                   voiceRegResponse.reasonForDenial = voiceRegState->reasonForDenial;
>                   fillCellIdentityResponse(voiceRegResponse.cellIdentity,
>                           voiceRegState->cellIdentity);
>               }
>               Return<void> retStatus =
>                       radioService[slotId]->mRadioResponse->getVoiceRegistrationStateResponse(
>                       responseInfo, voiceRegResponse);
>               radioService[slotId]->checkReturnStatus(retStatus);
3842,3845d6514
<         Return<void> retStatus =
<                 radioService[slotId]->mRadioResponse->getVoiceRegistrationStateResponse(
<                 responseInfo, voiceRegResponse);
<         radioService[slotId]->checkReturnStatus(retStatus);
3850d6518
< 
3854c6522
< int radio::getDataRegistrationStateResponse(int slotId,
---
> int radio_1_6::getDataRegistrationStateResponse(int slotId,
3860,3861c6528,6532
< 
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponse != NULL ||
>         radioService[slotId]->mRadioResponseV1_2 != NULL ||
>         radioService[slotId]->mRadioResponseV1_4 != NULL ||
>         radioService[slotId]->mRadioResponseV1_5 != NULL ||
>         radioService[slotId]->mRadioResponseV1_6 != NULL) {
3863d6533
<         populateResponseInfo(responseInfo, serial, responseType, e);
3864a6535
>         populateResponseInfo(responseInfo, serial, responseType, e);
3868c6539,6575
<         } else if (s_vendorFunctions->version <= 14) {
---
> 
>             // TODO: future implementation needs
>             Return<void> retStatus;
>             if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>                 ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>                 populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>                 RegStateResultV1_6 regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_6->
>                                          getDataRegistrationStateResponse_1_6(
>                                                  responseInfo_1_6, regResponse);
>             } else if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>                 RegStateResultV1_5 regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_5->
>                                          getDataRegistrationStateResponse_1_5(
>                                                  responseInfo, regResponse);
>             } else if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>                 V1_4::DataRegStateResult regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_4->
>                                          getDataRegistrationStateResponse_1_4(
>                                                  responseInfo, regResponse);
>             } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>                 V1_2::DataRegStateResult regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponseV1_2->
>                                          getDataRegistrationStateResponse_1_2(
>                                                  responseInfo, regResponse);
>             } else {
>                 DataRegStateResult regResponse = {};
>                 retStatus = radioService[slotId]->mRadioResponse->
>                                          getDataRegistrationStateResponse(
>                                                  responseInfo, regResponse);
>             }
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (s_vendorFunctions->version >= 15 &&
>                    radioService[slotId]->mRadioResponseV1_6 != NULL) {
>             ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>             populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>             RegStateResultV1_6 regResponse = {};
3870c6577,6686
<             if ((numStrings != 6) && (numStrings != 11) && (numStrings != 13)) {
---
>             if ((numStrings != 6) && (numStrings != 11) && (numStrings != 14)) {
>                 RLOGE("getDataRegistrationStateResponse Invalid response: NULL");
>                 if (e == RIL_E_SUCCESS) responseInfo_1_6.error =
>                         ::android::hardware::radio::V1_6::RadioError::INVALID_RESPONSE;
>             } else {
>                 char **resp = (char **) response;
>                 int rat = ATOI_NULL_HANDLED_DEF(resp[3], 0);
>                 regResponse.regState = (RegState)ATOI_NULL_HANDLED_DEF(resp[0], 4);
>                 regResponse.rat = (V1_4::RadioTechnology)rat;
>                 regResponse.reasonForDenial =
>                         (V1_5::RegistrationFailCause)ATOI_NULL_HANDLED(resp[4]);
>                 if (numStrings > 13) {
>                     regResponse.registeredPlmn = convertCharPtrToHidlString(resp[13]);
>                 }
> 
>                 fillCellIdentityFromDataRegStateResponseString_1_5(regResponse.cellIdentity,
>                         numStrings, resp);
>                 if (rat == RADIO_TECH_NR) {
>                     // rat is NR only for NR SA
>                     V1_6::NrVopsInfo nrVopsInfo;
>                     nrVopsInfo.vopsSupported =
>                             ::android::hardware::radio::V1_6::VopsIndicator::VOPS_NOT_SUPPORTED;
>                     nrVopsInfo.emcSupported =
>                             ::android::hardware::radio::V1_6::EmcIndicator::EMC_NOT_SUPPORTED;
>                     nrVopsInfo.emfSupported =
>                             ::android::hardware::radio::V1_6::EmfIndicator::EMF_NOT_SUPPORTED;
>                     regResponse.accessTechnologySpecificInfo.ngranNrVopsInfo(nrVopsInfo);
> 
>                 } else {
>                     V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                             EutranRegistrationInfo eutranInfo;
>                     if (rat == RADIO_TECH_LTE || rat == RADIO_TECH_LTE_CA) {
>                         eutranInfo.lteVopsInfo.isVopsSupported = false;
>                         eutranInfo.lteVopsInfo.isEmcBearerSupported = false;
>                     }
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     eutranInfo.nrIndicators.isDcNrRestricted = false;
>                     eutranInfo.nrIndicators.isEndcAvailable = false;
>                     regResponse.accessTechnologySpecificInfo.eutranInfo(eutranInfo);
>                 }
> 
>                 Return<void> retStatus =
>                     radioService[slotId]
>                         ->mRadioResponseV1_6
>                         ->getDataRegistrationStateResponse_1_6(
>                             responseInfo_1_6, regResponse);
>                 radioService[slotId]->checkReturnStatus(retStatus);
>             }
>         } else if (s_vendorFunctions->version <= 14 &&
>                    radioService[slotId]->mRadioResponseV1_5 != NULL) {
>             RegStateResultV1_5 regResponse = {};
>             int numStrings = responseLen / sizeof(char *);
>             if ((numStrings != 6) && (numStrings != 11) && (numStrings != 14)) {
>                 RLOGE("getDataRegistrationStateResponse Invalid response: NULL");
>                 if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>             } else {
>                 char **resp = (char **) response;
>                 int rat = ATOI_NULL_HANDLED_DEF(resp[3], 0);
>                 regResponse.regState = (RegState)ATOI_NULL_HANDLED_DEF(resp[0], 4);
>                 regResponse.rat = (V1_4::RadioTechnology)rat;
>                 regResponse.reasonForDenial =
>                         (V1_5::RegistrationFailCause)ATOI_NULL_HANDLED(resp[4]);
>                 if (numStrings > 13) {
>                     regResponse.registeredPlmn = convertCharPtrToHidlString(resp[13]);
>                 }
> 
>                 V1_5::RegStateResult::AccessTechnologySpecificInfo::
>                         EutranRegistrationInfo eutranInfo;
>                 if (rat == RADIO_TECH_LTE || rat == RADIO_TECH_LTE_CA ||
>                     rat == RADIO_TECH_NR) {
>                     eutranInfo.lteVopsInfo.isVopsSupported = false;
>                     eutranInfo.lteVopsInfo.isEmcBearerSupported = false;
>                 }
>                 eutranInfo.nrIndicators.isEndcAvailable = false;
>                 eutranInfo.nrIndicators.isDcNrRestricted = false;
>                 eutranInfo.nrIndicators.isEndcAvailable = false;
>                 regResponse.accessTechnologySpecificInfo.eutranInfo(eutranInfo);
> 
>                 fillCellIdentityFromDataRegStateResponseString_1_5(regResponse.cellIdentity,
>                         numStrings, resp);
> 
>                 Return<void> retStatus =
>                     radioService[slotId]
>                         ->mRadioResponseV1_5
>                         ->getDataRegistrationStateResponse_1_5(
>                             responseInfo, regResponse);
>                 radioService[slotId]->checkReturnStatus(retStatus);
>             }
>         } else if (s_vendorFunctions->version <= 14 &&
>                     radioService[slotId]->mRadioResponseV1_2 != NULL) {
>             V1_2::DataRegStateResult dataRegResponse = {};
>             int numStrings = responseLen / sizeof(char *);
>             if ((numStrings != 11) && (numStrings != 13) && (numStrings != 14)) {
>                 RLOGE("getDataRegistrationStateResponse_1_2 Invalid response: NULL");
>                 if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>             } else {
>                 char **resp = (char **)response;
>                 dataRegResponse.regState = (RegState)ATOI_NULL_HANDLED_DEF(resp[0], 4);
>                 dataRegResponse.rat =  ATOI_NULL_HANDLED_DEF(resp[3], 0);
>                 dataRegResponse.reasonDataDenied =  ATOI_NULL_HANDLED(resp[4]);
>                 dataRegResponse.maxDataCalls =  ATOI_NULL_HANDLED_DEF(resp[5], 1);
>                 fillCellIdentityFromDataRegStateResponseString_1_2(dataRegResponse.cellIdentity,
>                         numStrings, resp);
>                 Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2->
>                         getDataRegistrationStateResponse_1_2(responseInfo, dataRegResponse);
>                 radioService[slotId]->checkReturnStatus(retStatus);
>             }
>       } else if (s_vendorFunctions->version <= 14) {
>             int numStrings = responseLen / sizeof(char *);
>             if ((numStrings != 11) && (numStrings != 13) && (numStrings != 14)) {
3891c6707
<                 dataRegResponse.rat = dataRegState->rat;;
---
>                 dataRegResponse.rat = dataRegState->rat;
3899,3900c6715,6716
<                 radioService[slotId]->mRadioResponse->getDataRegistrationStateResponse(responseInfo,
<                 dataRegResponse);
---
>                 radioService[slotId]->mRadioResponse->getDataRegistrationStateResponse(
>                         responseInfo, dataRegResponse);
3910c6726
< int radio::getOperatorResponse(int slotId,
---
> int radio_1_6::getOperatorResponse(int slotId,
3945c6761
< int radio::setRadioPowerResponse(int slotId,
---
> int radio_1_6::setRadioPowerResponse(int slotId,
3947a6764
> #if VDBG
3948a6766,6770
> #endif
>     RadioResponseInfo responseInfo = {};
>     ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
>     populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
3950,3954c6772,6782
<     if (radioService[slotId]->mRadioResponse != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         Return<void> retStatus = radioService[slotId]->mRadioResponse->setRadioPowerResponse(
<                 responseInfo);
---
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                 ->setRadioPowerResponse_1_6(responseInfo_1_6);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setRadioPowerResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponse
>                 ->setRadioPowerResponse(responseInfo);
3957,3958c6785
<         RLOGE("setRadioPowerResponse: radioService[%d]->mRadioResponse == NULL",
<                 slotId);
---
>         RLOGE("setRadioPowerResponse: radioService[%d]->mRadioResponse == NULL", slotId);
3964c6791
< int radio::sendDtmfResponse(int slotId,
---
> int radio_1_6::sendDtmfResponse(int slotId,
4003c6830,6851
< int radio::sendSmsResponse(int slotId,
---
> SendSmsResult makeSendSmsResult_1_6(
>         ::android::hardware::radio::V1_6::RadioResponseInfo &responseInfo, int serial,
>         int responseType, RIL_Errno e, void *response, size_t responseLen) {
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
>     SendSmsResult result = {};
> 
>     if (response == NULL || responseLen != sizeof(RIL_SMS_Response)) {
>         RLOGE("Invalid response: NULL");
>         if (e == RIL_E_SUCCESS) {
>             responseInfo.error = ::android::hardware::radio::V1_6::RadioError::INVALID_RESPONSE;
>         }
>         result.ackPDU = hidl_string();
>     } else {
>         RIL_SMS_Response *resp = (RIL_SMS_Response *) response;
>         result.messageRef = resp->messageRef;
>         result.ackPDU = convertCharPtrToHidlString(resp->ackPDU);
>         result.errorCode = resp->errorCode;
>     }
>     return result;
> }
> 
> int radio_1_6::sendSmsResponse(int slotId,
4010c6858,6866
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         SendSmsResult result = makeSendSmsResult_1_6(responseInfo_1_6, serial, responseType, e, response,
>                 responseLen);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                 ->sendSmsResponse_1_6(responseInfo_1_6, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
4025c6881
< int radio::sendSMSExpectMoreResponse(int slotId,
---
> int radio_1_6::sendSmsExpectMoreResponse(int slotId,
4029c6885
<     RLOGD("sendSMSExpectMoreResponse: serial %d", serial);
---
>     RLOGD("sendSmsExpectMoreResponse: serial %d", serial);
4032c6888,6896
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         SendSmsResult result = makeSendSmsResult_1_6(responseInfo_1_6, serial, responseType, e, response,
>                 responseLen);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                 ->sendSmsExpectMoreResponse_1_6(responseInfo_1_6, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
4047c6911
< int radio::setupDataCallResponse(int slotId,
---
> int radio_1_6::setupDataCallResponse(int slotId,
4052a6917,6938
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         populateResponseInfo_1_6(responseInfo_1_6, serial, responseType, e);
>         ::android::hardware::radio::V1_6::SetupDataCallResult result;
>         if (response == NULL || (responseLen % sizeof(RIL_Data_Call_Response_v11)) != 0) {
>             if (response != NULL) {
>                 RLOGE("setupDataCallResponse_1_6: Invalid response");
>                 if (e == RIL_E_SUCCESS) responseInfo_1_6.error =
>                         ::android::hardware::radio::V1_6::RadioError::INVALID_RESPONSE;
>             }
>             result.cause = ::android::hardware::radio::V1_6::DataCallFailCause::ERROR_UNSPECIFIED;
>             result.type = ::android::hardware::radio::V1_4::PdpProtocolType::UNKNOWN;
>             result.ifname = hidl_string();
>             result.addresses = hidl_vec<::android::hardware::radio::V1_5::LinkAddress>();
>             result.dnses = hidl_vec<hidl_string>();
>             result.gateways = hidl_vec<hidl_string>();
>             result.pcscf = hidl_vec<hidl_string>();
>             result.trafficDescriptors =
>                     hidl_vec<::android::hardware::radio::V1_6::TrafficDescriptor>();
>         } else {
>             convertRilDataCallToHal((RIL_Data_Call_Response_v12 *) response, result);
>         }
4054c6940,6943
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->setupDataCallResponse_1_6(
>                 responseInfo_1_6, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
4056a6946,6961
>         ::android::hardware::radio::V1_5::SetupDataCallResult result;
>         if (response == NULL || (responseLen % sizeof(RIL_Data_Call_Response_v11)) != 0) {
>             if (response != NULL) {
>                 RLOGE("setupDataCallResponse_1_5: Invalid response");
>                 if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>             }
>             result.cause = ::android::hardware::radio::V1_4::DataCallFailCause::ERROR_UNSPECIFIED;
>             result.type = ::android::hardware::radio::V1_4::PdpProtocolType::UNKNOWN;
>             result.ifname = hidl_string();
>             result.addresses = hidl_vec<::android::hardware::radio::V1_5::LinkAddress>();
>             result.dnses = hidl_vec<hidl_string>();
>             result.gateways = hidl_vec<hidl_string>();
>             result.pcscf = hidl_vec<hidl_string>();
>         } else {
>             convertRilDataCallToHal((RIL_Data_Call_Response_v12 *) response, result);
>         }
4058c6963,6969
<         SetupDataCallResult result = {};
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5->setupDataCallResponse_1_5(
>                 responseInfo, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         ::android::hardware::radio::V1_4::SetupDataCallResult result;
4061c6972
<                 RLOGE("setupDataCallResponse: Invalid response");
---
>                 RLOGE("setupDataCallResponse_1_4: Invalid response");
4064,4065c6975,6976
<             result.status = DataCallFailCause::ERROR_UNSPECIFIED;
<             result.type = hidl_string();
---
>             result.cause = ::android::hardware::radio::V1_4::DataCallFailCause::ERROR_UNSPECIFIED;
>             result.type = ::android::hardware::radio::V1_4::PdpProtocolType::UNKNOWN;
4067,4070c6978,6981
<             result.addresses = hidl_string();
<             result.dnses = hidl_string();
<             result.gateways = hidl_string();
<             result.pcscf = hidl_string();
---
>             result.addresses = hidl_vec<hidl_string>();
>             result.dnses = hidl_vec<hidl_string>();
>             result.gateways = hidl_vec<hidl_string>();
>             result.pcscf = hidl_vec<hidl_string>();
4075c6986
<         Return<void> retStatus = radioService[slotId]->mRadioResponse->setupDataCallResponse(
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4->setupDataCallResponse_1_4(
4077a6989,7012
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
> 
>         SetupDataCallResult result = {};
>         if (response == NULL || (responseLen % sizeof(RIL_Data_Call_Response_v11)) != 0) {
>            if (response != NULL) {
>                RLOGE("setupDataCallResponse: Invalid response");
>                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>            }
>            result.status = DataCallFailCause::ERROR_UNSPECIFIED;
>            result.type = hidl_string();
>            result.ifname = hidl_string();
>            result.addresses = hidl_string();
>            result.dnses = hidl_string();
>            result.gateways = hidl_string();
>            result.pcscf = hidl_string();
>         } else {
>            convertRilDataCallToHal((RIL_Data_Call_Response_v11 *) response, result);
>         }
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponse->setupDataCallResponse(
>                responseInfo, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
4103c7038
< int radio::iccIOForAppResponse(int slotId,
---
> int radio_1_6::iccIOForAppResponse(int slotId,
4125c7060
< int radio::sendUssdResponse(int slotId,
---
> int radio_1_6::sendUssdResponse(int slotId,
4146c7081
< int radio::cancelPendingUssdResponse(int slotId,
---
> int radio_1_6::cancelPendingUssdResponse(int slotId,
4167c7102
< int radio::getClirResponse(int slotId,
---
> int radio_1_6::getClirResponse(int slotId,
4197c7132
< int radio::setClirResponse(int slotId,
---
> int radio_1_6::setClirResponse(int slotId,
4217c7152
< int radio::getCallForwardStatusResponse(int slotId,
---
> int radio_1_6::getCallForwardStatusResponse(int slotId,
4258c7193
< int radio::setCallForwardResponse(int slotId,
---
> int radio_1_6::setCallForwardResponse(int slotId,
4278c7213
< int radio::getCallWaitingResponse(int slotId,
---
> int radio_1_6::getCallWaitingResponse(int slotId,
4309c7244
< int radio::setCallWaitingResponse(int slotId,
---
> int radio_1_6::setCallWaitingResponse(int slotId,
4329c7264
< int radio::acknowledgeLastIncomingGsmSmsResponse(int slotId,
---
> int radio_1_6::acknowledgeLastIncomingGsmSmsResponse(int slotId,
4351c7286
< int radio::acceptCallResponse(int slotId,
---
> int radio_1_6::acceptCallResponse(int slotId,
4372c7307
< int radio::deactivateDataCallResponse(int slotId,
---
> int radio_1_6::deactivateDataCallResponse(int slotId,
4393c7328
< int radio::getFacilityLockForAppResponse(int slotId,
---
> int radio_1_6::getFacilityLockForAppResponse(int slotId,
4414c7349
< int radio::setFacilityLockForAppResponse(int slotId,
---
> int radio_1_6::setFacilityLockForAppResponse(int slotId,
4436c7371
< int radio::setBarringPasswordResponse(int slotId,
---
> int radio_1_6::setBarringPasswordResponse(int slotId,
4457c7392
< int radio::getNetworkSelectionModeResponse(int slotId,
---
> int radio_1_6::getNetworkSelectionModeResponse(int slotId,
4488c7423
< int radio::setNetworkSelectionModeAutomaticResponse(int slotId, int responseType, int serial,
---
> int radio_1_6::setNetworkSelectionModeAutomaticResponse(int slotId, int responseType, int serial,
4510c7445
< int radio::setNetworkSelectionModeManualResponse(int slotId,
---
> int radio_1_6::setNetworkSelectionModeManualResponse(int slotId,
4515a7451,7452
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
4517,4522c7454,7460
<     if (radioService[slotId]->mRadioResponse != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         Return<void> retStatus
<                 = radioService[slotId]->mRadioResponse->setNetworkSelectionModeManualResponse(
<                 responseInfo);
---
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setNetworkSelectionModeManualResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponse
>                 ->setNetworkSelectionModeManualResponse(responseInfo);
4546c7484
< int radio::getAvailableNetworksResponse(int slotId,
---
> int radio_1_6::getAvailableNetworksResponse(int slotId,
4589c7527
< int radio::startDtmfResponse(int slotId,
---
> int radio_1_6::startDtmfResponse(int slotId,
4609c7547
< int radio::stopDtmfResponse(int slotId,
---
> int radio_1_6::stopDtmfResponse(int slotId,
4629c7567
< int radio::getBasebandVersionResponse(int slotId,
---
> int radio_1_6::getBasebandVersionResponse(int slotId,
4650c7588
< int radio::separateConnectionResponse(int slotId,
---
> int radio_1_6::separateConnectionResponse(int slotId,
4671c7609
< int radio::setMuteResponse(int slotId,
---
> int radio_1_6::setMuteResponse(int slotId,
4691c7629
< int radio::getMuteResponse(int slotId,
---
> int radio_1_6::getMuteResponse(int slotId,
4719c7657
< int radio::getClipResponse(int slotId,
---
> int radio_1_6::getClipResponse(int slotId,
4739c7677
< int radio::getDataCallListResponse(int slotId,
---
> int radio_1_6::getDataCallListResponse(int slotId,
4769c7707
< int radio::setSuppServiceNotificationsResponse(int slotId,
---
> int radio_1_6::setSuppServiceNotificationsResponse(int slotId,
4791c7729
< int radio::deleteSmsOnSimResponse(int slotId,
---
> int radio_1_6::deleteSmsOnSimResponse(int slotId,
4811c7749
< int radio::setBandModeResponse(int slotId,
---
> int radio_1_6::setBandModeResponse(int slotId,
4831c7769
< int radio::writeSmsToSimResponse(int slotId,
---
> int radio_1_6::writeSmsToSimResponse(int slotId,
4851c7789
< int radio::getAvailableBandModesResponse(int slotId,
---
> int radio_1_6::getAvailableBandModesResponse(int slotId,
4885c7823
< int radio::sendEnvelopeResponse(int slotId,
---
> int radio_1_6::sendEnvelopeResponse(int slotId,
4906c7844
< int radio::sendTerminalResponseToSimResponse(int slotId,
---
> int radio_1_6::sendTerminalResponseToSimResponse(int slotId,
4928c7866
< int radio::handleStkCallSetupRequestFromSimResponse(int slotId,
---
> int radio_1_6::handleStkCallSetupRequestFromSimResponse(int slotId,
4951c7889
< int radio::explicitCallTransferResponse(int slotId,
---
> int radio_1_6::explicitCallTransferResponse(int slotId,
4972c7910
< int radio::setPreferredNetworkTypeResponse(int slotId,
---
> int radio_1_6::setPreferredNetworkTypeResponse(int slotId,
4993a7932,7977
> int radio_1_6::setAllowedNetworkTypesBitmapResponse(int slotId,
>                                  int responseType, int serial, RIL_Errno e,
>                                  void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("setAllowedNetworkTypesBitmapResponse: serial %d", serial);
> #endif
> 
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->setAllowedNetworkTypesBitmapResponse(
>             responseInfo);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::getAllowedNetworkTypesBitmapResponse(int slotId,
>                                           int responseType, int serial, RIL_Errno e,
>                                           void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("getAllowedNetworkTypesBitmapResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>       V1_6::RadioResponseInfo responseInfo = {};
>         int ret = responseInt_1_6(responseInfo, serial, responseType, e, response, responseLen);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_6->getAllowedNetworkTypesBitmapResponse(
>                 responseInfo,
>                 (const ::android::hardware::hidl_bitfield<
>                 ::android::hardware::radio::V1_4::RadioAccessFamily>) ret);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getAllowedNetworkTypesBitmapResponse: radioService[%d]->mRadioResponseV1_6 == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
4995c7979
< int radio::getPreferredNetworkTypeResponse(int slotId,
---
> int radio_1_6::getPreferredNetworkTypeResponse(int slotId,
5017c8001,8048
< int radio::getNeighboringCidsResponse(int slotId,
---
> int radio_1_6::setPreferredNetworkTypeBitmapResponse(int slotId,
>                                  int responseType, int serial, RIL_Errno e,
>                                  void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("setPreferredNetworkTypeBitmapResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_4->setPreferredNetworkTypeBitmapResponse(
>                 responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setPreferredNetworkTypeBitmapResponse: radioService[%d]->mRadioResponseV1_4 == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
> 
> 
> int radio_1_6::getPreferredNetworkTypeBitmapResponse(int slotId,
>                                           int responseType, int serial, RIL_Errno e,
>                                           void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("getPreferredNetworkTypeBitmapResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_4->getPreferredNetworkTypeBitmapResponse(
>                 responseInfo,
>                 (const ::android::hardware::hidl_bitfield<
>                 ::android::hardware::radio::V1_4::RadioAccessFamily>) ret);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getPreferredNetworkTypeBitmapResponse: radioService[%d]->mRadioResponseV1_4 == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::getNeighboringCidsResponse(int slotId,
5055c8086
< int radio::setLocationUpdatesResponse(int slotId,
---
> int radio_1_6::setLocationUpdatesResponse(int slotId,
5076c8107
< int radio::setCdmaSubscriptionSourceResponse(int slotId,
---
> int radio_1_6::setCdmaSubscriptionSourceResponse(int slotId,
5098c8129
< int radio::setCdmaRoamingPreferenceResponse(int slotId,
---
> int radio_1_6::setCdmaRoamingPreferenceResponse(int slotId,
5120c8151
< int radio::getCdmaRoamingPreferenceResponse(int slotId,
---
> int radio_1_6::getCdmaRoamingPreferenceResponse(int slotId,
5142c8173
< int radio::setTTYModeResponse(int slotId,
---
> int radio_1_6::setTTYModeResponse(int slotId,
5162c8193
< int radio::getTTYModeResponse(int slotId,
---
> int radio_1_6::getTTYModeResponse(int slotId,
5183c8214
< int radio::setPreferredVoicePrivacyResponse(int slotId,
---
> int radio_1_6::setPreferredVoicePrivacyResponse(int slotId,
5205c8236
< int radio::getPreferredVoicePrivacyResponse(int slotId,
---
> int radio_1_6::getPreferredVoicePrivacyResponse(int slotId,
5236c8267
< int radio::sendCDMAFeatureCodeResponse(int slotId,
---
> int radio_1_6::sendCDMAFeatureCodeResponse(int slotId,
5257c8288
< int radio::sendBurstDtmfResponse(int slotId,
---
> int radio_1_6::sendBurstDtmfResponse(int slotId,
5277c8308
< int radio::sendCdmaSmsResponse(int slotId,
---
> int radio_1_6::sendCdmaSmsResponse(int slotId,
5284c8315,8323
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         SendSmsResult result = makeSendSmsResult_1_6(responseInfo_1_6, serial, responseType, e,
>                 response, responseLen);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                 ->sendCdmaSmsResponse_1_6(responseInfo_1_6, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
5299c8338
< int radio::acknowledgeLastIncomingCdmaSmsResponse(int slotId,
---
> int radio_1_6::acknowledgeLastIncomingCdmaSmsResponse(int slotId,
5321c8360
< int radio::getGsmBroadcastConfigResponse(int slotId,
---
> int radio_1_6::getGsmBroadcastConfigResponse(int slotId,
5363c8402
< int radio::setGsmBroadcastConfigResponse(int slotId,
---
> int radio_1_6::setGsmBroadcastConfigResponse(int slotId,
5384c8423
< int radio::setGsmBroadcastActivationResponse(int slotId,
---
> int radio_1_6::setGsmBroadcastActivationResponse(int slotId,
5406c8445
< int radio::getCdmaBroadcastConfigResponse(int slotId,
---
> int radio_1_6::getCdmaBroadcastConfigResponse(int slotId,
5446c8485
< int radio::setCdmaBroadcastConfigResponse(int slotId,
---
> int radio_1_6::setCdmaBroadcastConfigResponse(int slotId,
5468c8507
< int radio::setCdmaBroadcastActivationResponse(int slotId,
---
> int radio_1_6::setCdmaBroadcastActivationResponse(int slotId,
5490c8529
< int radio::getCDMASubscriptionResponse(int slotId,
---
> int radio_1_6::getCDMASubscriptionResponse(int slotId,
5530c8569
< int radio::writeSmsToRuimResponse(int slotId,
---
> int radio_1_6::writeSmsToRuimResponse(int slotId,
5550c8589
< int radio::deleteSmsOnRuimResponse(int slotId,
---
> int radio_1_6::deleteSmsOnRuimResponse(int slotId,
5570c8609
< int radio::getDeviceIdentityResponse(int slotId,
---
> int radio_1_6::getDeviceIdentityResponse(int slotId,
5608c8647
< int radio::exitEmergencyCallbackModeResponse(int slotId,
---
> int radio_1_6::exitEmergencyCallbackModeResponse(int slotId,
5630c8669
< int radio::getSmscAddressResponse(int slotId,
---
> int radio_1_6::getSmscAddressResponse(int slotId,
5651c8690
< int radio::setSmscAddressResponse(int slotId,
---
> int radio_1_6::setSmscAddressResponse(int slotId,
5671c8710
< int radio::reportSmsMemoryStatusResponse(int slotId,
---
> int radio_1_6::reportSmsMemoryStatusResponse(int slotId,
5692c8731
< int radio::reportStkServiceIsRunningResponse(int slotId,
---
> int radio_1_6::reportStkServiceIsRunningResponse(int slotId,
5713c8752
< int radio::getCdmaSubscriptionSourceResponse(int slotId,
---
> int radio_1_6::getCdmaSubscriptionSourceResponse(int slotId,
5735c8774
< int radio::requestIsimAuthenticationResponse(int slotId,
---
> int radio_1_6::requestIsimAuthenticationResponse(int slotId,
5758c8797
< int radio::acknowledgeIncomingGsmSmsWithPduResponse(int slotId,
---
> int radio_1_6::acknowledgeIncomingGsmSmsWithPduResponse(int slotId,
5781c8820
< int radio::sendEnvelopeWithStatusResponse(int slotId,
---
> int radio_1_6::sendEnvelopeWithStatusResponse(int slotId,
5805c8844
< int radio::getVoiceRadioTechnologyResponse(int slotId,
---
> int radio_1_6::getVoiceRadioTechnologyResponse(int slotId,
5827c8866
< int radio::getCellInfoListResponse(int slotId,
---
> int radio_1_6::getCellInfoListResponse(int slotId,
5835c8874,8875
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponse != NULL ||
>         radioService[slotId]->mRadioResponseV1_2 != NULL) {
5838a8879
>         Return<void> retStatus;
5843a8885,8894
> 
>             if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>                 hidl_vec<V1_2::CellInfo> ret;
>                 retStatus = radioService[slotId]->mRadioResponseV1_2->
>                         getCellInfoListResponse_1_2(responseInfo, ret);
>             } else {
>                 hidl_vec<CellInfo> ret;
>                 retStatus = radioService[slotId]->mRadioResponse->
>                         getCellInfoListResponse(responseInfo, ret);
>             }
5845c8896,8906
<             convertRilCellInfoListToHal(response, responseLen, ret);
---
>             if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>                 hidl_vec<V1_2::CellInfo> ret;
>                 convertRilCellInfoListToHal_1_2(response, responseLen, ret);
>                 retStatus = radioService[slotId]->mRadioResponseV1_2->
>                         getCellInfoListResponse_1_2(responseInfo, ret);
>             } else {
>                 hidl_vec<CellInfo> ret;
>                 convertRilCellInfoListToHal(response, responseLen, ret);
>                 retStatus = radioService[slotId]->mRadioResponse->
>                         getCellInfoListResponse(responseInfo, ret);
>             }
5847,5849d8907
< 
<         Return<void> retStatus = radioService[slotId]->mRadioResponse->getCellInfoListResponse(
<                 responseInfo, ret);
5858c8916
< int radio::setCellInfoListRateResponse(int slotId,
---
> int radio_1_6::setCellInfoListRateResponse(int slotId,
5880c8938
< int radio::setInitialAttachApnResponse(int slotId,
---
> int radio_1_6::setInitialAttachApnResponse(int slotId,
5887c8945,8951
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_5->setInitialAttachApnResponse_1_5(
>                 responseInfo);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
5901c8965
< int radio::getImsRegistrationStateResponse(int slotId,
---
> int radio_1_6::getImsRegistrationStateResponse(int slotId,
5912c8976
<         RadioTechnologyFamily ratFamily = RadioTechnologyFamily::THREE_GPP;
---
>         int ratFamily = 0;
5920,5925c8984
<             // Map RIL_RadioTechnologyFamily to RadioTechnologyFamily
<             if (pInt[1] == RADIO_TECH_3GPP) {
<                 ratFamily = RadioTechnologyFamily::THREE_GPP;
<             } else {
<                 ratFamily = RadioTechnologyFamily::THREE_GPP2;
<             }
---
>             ratFamily = pInt[1];
5929c8988
<                 responseInfo, isRegistered, ratFamily);
---
>                 responseInfo, isRegistered, (RadioTechnologyFamily) ratFamily);
5939c8998
< int radio::sendImsSmsResponse(int slotId,
---
> int radio_1_6::sendImsSmsResponse(int slotId,
5961c9020
< int radio::iccTransmitApduBasicChannelResponse(int slotId,
---
> int radio_1_6::iccTransmitApduBasicChannelResponse(int slotId,
5985c9044
< int radio::iccOpenLogicalChannelResponse(int slotId,
---
> int radio_1_6::iccOpenLogicalChannelResponse(int slotId,
6023c9082
< int radio::iccCloseLogicalChannelResponse(int slotId,
---
> int radio_1_6::iccCloseLogicalChannelResponse(int slotId,
6045c9104
< int radio::iccTransmitApduLogicalChannelResponse(int slotId,
---
> int radio_1_6::iccTransmitApduLogicalChannelResponse(int slotId,
6069c9128
< int radio::nvReadItemResponse(int slotId,
---
> int radio_1_6::nvReadItemResponse(int slotId,
6090c9149
< int radio::nvWriteItemResponse(int slotId,
---
> int radio_1_6::nvWriteItemResponse(int slotId,
6110c9169
< int radio::nvWriteCdmaPrlResponse(int slotId,
---
> int radio_1_6::nvWriteCdmaPrlResponse(int slotId,
6130c9189
< int radio::nvResetConfigResponse(int slotId,
---
> int radio_1_6::nvResetConfigResponse(int slotId,
6150c9209
< int radio::setUiccSubscriptionResponse(int slotId,
---
> int radio_1_6::setUiccSubscriptionResponse(int slotId,
6171c9230
< int radio::setDataAllowedResponse(int slotId,
---
> int radio_1_6::setDataAllowedResponse(int slotId,
6191c9250
< int radio::getHardwareConfigResponse(int slotId,
---
> int radio_1_6::getHardwareConfigResponse(int slotId,
6221c9280
< int radio::requestIccSimAuthenticationResponse(int slotId,
---
> int radio_1_6::requestIccSimAuthenticationResponse(int slotId,
6245c9304
< int radio::setDataProfileResponse(int slotId,
---
> int radio_1_6::setDataProfileResponse(int slotId,
6252c9311,9317
<     if (radioService[slotId]->mRadioResponse != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_5->setDataProfileResponse_1_5(
>                 responseInfo);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
6265c9330
< int radio::requestShutdownResponse(int slotId,
---
> int radio_1_6::requestShutdownResponse(int slotId,
6298c9363
< int radio::getRadioCapabilityResponse(int slotId,
---
> int radio_1_6::getRadioCapabilityResponse(int slotId,
6320c9385
< int radio::setRadioCapabilityResponse(int slotId,
---
> int radio_1_6::setRadioCapabilityResponse(int slotId,
6358c9423
< int radio::startLceServiceResponse(int slotId,
---
> int radio_1_6::startLceServiceResponse(int slotId,
6381c9446
< int radio::stopLceServiceResponse(int slotId,
---
> int radio_1_6::stopLceServiceResponse(int slotId,
6404c9469
< int radio::pullLceDataResponse(int slotId,
---
> int radio_1_6::pullLceDataResponse(int slotId,
6433c9498
< int radio::getModemActivityInfoResponse(int slotId,
---
> int radio_1_6::getModemActivityInfoResponse(int slotId,
6469c9534
< int radio::setAllowedCarriersResponse(int slotId,
---
> int radio_1_6::setAllowedCarriersResponse(int slotId,
6474a9540
>     RadioResponseInfo responseInfo = {};
6476,6477c9542,9548
<     if (radioService[slotId]->mRadioResponse != NULL) {
<         RadioResponseInfo responseInfo = {};
---
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         // TODO: future implementation needs
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4
>                 ->setAllowedCarriersResponse_1_4(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
6479,6481c9550,9551
<         Return<void> retStatus
<                 = radioService[slotId]->mRadioResponse->setAllowedCarriersResponse(responseInfo,
<                 ret);
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponse
>                 ->setAllowedCarriersResponse(responseInfo, ret);
6484,6485c9554
<         RLOGE("setAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL",
<                 slotId);
---
>         RLOGE("setAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL", slotId);
6491c9560,9588
< int radio::getAllowedCarriersResponse(int slotId,
---
> void prepareCarrierRestrictionsResponse(hidl_vec<Carrier>& allowedCarriers,
>                                        hidl_vec<Carrier>& excludedCarriers,
>                                        bool& allAllowed,
>                                        const RIL_CarrierRestrictions* pCr) {
>     if (pCr->len_allowed_carriers > 0 || pCr->len_excluded_carriers > 0) {
>         allAllowed = false;
>     }
>     allowedCarriers.resize(pCr->len_allowed_carriers);
>     for(int i = 0; i < pCr->len_allowed_carriers; i++) {
>         RIL_Carrier *carrier = pCr->allowed_carriers + i;
>         allowedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
>         allowedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
>         allowedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
>         allowedCarriers[i].matchData =
>                 convertCharPtrToHidlString(carrier->match_data);
>     }
> 
>     excludedCarriers.resize(pCr->len_excluded_carriers);
>     for(int i = 0; i < pCr->len_excluded_carriers; i++) {
>         RIL_Carrier *carrier = pCr->excluded_carriers + i;
>         excludedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
>         excludedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
>         excludedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
>         excludedCarriers[i].matchData =
>                 convertCharPtrToHidlString(carrier->match_data);
>     }
> }
> 
> int radio_1_6::getAllowedCarriersResponse(int slotId,
6496a9594,9595
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
6498,6501c9597,9600
<     if (radioService[slotId]->mRadioResponse != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         CarrierRestrictions carrierInfo = {};
---
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         V1_4::CarrierRestrictionsWithPriority carrierInfo = {};
>         V1_4::SimLockMultiSimPolicy multiSimPolicy =
>                 V1_4::SimLockMultiSimPolicy::NO_MULTISIM_POLICY;
6502a9602
> 
6509c9609,9610
<         } else if (responseLen != sizeof(RIL_CarrierRestrictions)) {
---
>             carrierInfo.allowedCarriersPrioritized = false;
>         } else if (responseLen != sizeof(RIL_CarrierRestrictionsWithPriority)) {
6511,6515c9612,9613
<             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
<         } else {
<             RIL_CarrierRestrictions *pCr = (RIL_CarrierRestrictions *)response;
<             if (pCr->len_allowed_carriers > 0 || pCr->len_excluded_carriers > 0) {
<                 allAllowed = false;
---
>             if (e == RIL_E_SUCCESS) {
>                 responseInfo.error = RadioError::INVALID_RESPONSE;
6516a9615,9617
>         } else {
>             RIL_CarrierRestrictionsWithPriority *pCrExt =
>                     (RIL_CarrierRestrictionsWithPriority *)response;
6518,6526c9619,9630
<             carrierInfo.allowedCarriers.resize(pCr->len_allowed_carriers);
<             for(int i = 0; i < pCr->len_allowed_carriers; i++) {
<                 RIL_Carrier *carrier = pCr->allowed_carriers + i;
<                 carrierInfo.allowedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
<                 carrierInfo.allowedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
<                 carrierInfo.allowedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
<                 carrierInfo.allowedCarriers[i].matchData =
<                         convertCharPtrToHidlString(carrier->match_data);
<             }
---
>             // Convert into the structure used in IRadio 1.0 to re-use existing code
>             RIL_CarrierRestrictions cr = {};
>             cr.len_allowed_carriers = pCrExt->len_allowed_carriers;
>             cr.len_excluded_carriers = pCrExt->len_excluded_carriers;
>             cr.allowed_carriers = pCrExt->allowed_carriers;
>             cr.excluded_carriers = pCrExt->excluded_carriers;
>             prepareCarrierRestrictionsResponse(carrierInfo.allowedCarriers,
>                     carrierInfo.excludedCarriers, allAllowed, &cr);
> 
>             carrierInfo.allowedCarriersPrioritized = (bool)pCrExt->allowedCarriersPrioritized;
>             multiSimPolicy = (V1_4::SimLockMultiSimPolicy)pCrExt->multiSimPolicy;
>         }
6528,6535c9632,9647
<             carrierInfo.excludedCarriers.resize(pCr->len_excluded_carriers);
<             for(int i = 0; i < pCr->len_excluded_carriers; i++) {
<                 RIL_Carrier *carrier = pCr->excluded_carriers + i;
<                 carrierInfo.excludedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
<                 carrierInfo.excludedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
<                 carrierInfo.excludedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
<                 carrierInfo.excludedCarriers[i].matchData =
<                         convertCharPtrToHidlString(carrier->match_data);
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4
>                 ->getAllowedCarriersResponse_1_4(responseInfo, carrierInfo, multiSimPolicy);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
>         CarrierRestrictions carrierInfo = {};
>         bool allAllowed = true;
>         if (response == NULL) {
> #if VDBG
>             RLOGD("getAllowedCarriersResponse response is NULL: all allowed");
> #endif
>             carrierInfo.allowedCarriers.resize(0);
>             carrierInfo.excludedCarriers.resize(0);
>         } else if (responseLen != sizeof(RIL_CarrierRestrictions)) {
>             RLOGE("getAllowedCarriersResponse Invalid response");
>             if (e == RIL_E_SUCCESS) {
>                 responseInfo.error = RadioError::INVALID_RESPONSE;
6536a9649,9652
>         } else {
>             RIL_CarrierRestrictions *pCr = (RIL_CarrierRestrictions *)response;
>             prepareCarrierRestrictionsResponse(carrierInfo.allowedCarriers,
>                     carrierInfo.excludedCarriers, allAllowed, pCr);
6539,6541c9655,9656
<         Return<void> retStatus
<                 = radioService[slotId]->mRadioResponse->getAllowedCarriersResponse(responseInfo,
<                 allAllowed, carrierInfo);
---
>         Return<void> retStatus = radioService[slotId]->mRadioResponse
>                 ->getAllowedCarriersResponse(responseInfo, allAllowed, carrierInfo);
6544,6545c9659
<         RLOGE("getAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL",
<                 slotId);
---
>         RLOGE("getAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL", slotId);
6551c9665
< int radio::sendDeviceStateResponse(int slotId,
---
> int radio_1_6::sendDeviceStateResponse(int slotId,
6571c9685
< int radio::setCarrierInfoForImsiEncryptionResponse(int slotId,
---
> int radio_1_6::setCarrierInfoForImsiEncryptionResponse(int slotId,
6574,6585c9688,9699
<     RLOGD("setCarrierInfoForImsiEncryptionResponse: serial %d", serial);
<     if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_1->
<                 setCarrierInfoForImsiEncryptionResponse(responseInfo);
<         radioService[slotId]->checkReturnStatus(retStatus);
<     } else {
<         RLOGE("setCarrierInfoForImsiEncryptionResponse: radioService[%d]->mRadioResponseV1_1 == "
<                 "NULL", slotId);
<     }
<     return 0;
---
>   RLOGD("setCarrierInfoForImsiEncryptionResponse: serial %d", serial);
>   if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
>       RadioResponseInfo responseInfo = {};
>       populateResponseInfo(responseInfo, serial, responseType, e);
>       Return<void> retStatus = radioService[slotId]->mRadioResponseV1_1->
>               setCarrierInfoForImsiEncryptionResponse(responseInfo);
>       radioService[slotId]->checkReturnStatus(retStatus);
>   } else {
>       RLOGE("setCarrierInfoForImsiEncryptionResponse: radioService[%d]->mRadioResponseV1_1 == "
>               "NULL", slotId);
>   }
>   return 0;
6588c9702
< int radio::setIndicationFilterResponse(int slotId,
---
> int radio_1_6::setIndicationFilterResponse(int slotId,
6593a9708,9709
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
6595,6599c9711,9717
<     if (radioService[slotId]->mRadioResponse != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         Return<void> retStatus
<                 = radioService[slotId]->mRadioResponse->setIndicationFilterResponse(responseInfo);
---
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setIndicationFilterResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponse != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponse
>                 ->setIndicationFilterResponse(responseInfo);
6602,6603c9720
<         RLOGE("setIndicationFilterResponse: radioService[%d]->mRadioResponse == NULL",
<                 slotId);
---
>         RLOGE("setIndicationFilterResponse: radioService[%d]->mRadioResponse == NULL", slotId);
6609c9726
< int radio::setSimCardPowerResponse(int slotId,
---
> int radio_1_6::setSimCardPowerResponse(int slotId,
6617,6620c9734,9745
<             || radioService[slotId]->mRadioResponseV1_1 != NULL) {
<         RadioResponseInfo responseInfo = {};
<         populateResponseInfo(responseInfo, serial, responseType, e);
<         if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
---
>             || radioService[slotId]->mRadioResponseV1_1 != NULL
>             || radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>             ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo = {};
>             populateResponseInfo_1_6(responseInfo, serial, responseType, e);
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->
>                     setSimCardPowerResponse_1_6(responseInfo);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
>             RLOGD("setSimCardPowerResponse: radioService[%d]->mRadioResponseV1_6 == NULL", slotId);
>             RadioResponseInfo responseInfo = {};
>             populateResponseInfo(responseInfo, serial, responseType, e);
6625c9750
<             RLOGD("setSimCardPowerResponse: radioService[%d]->mRadioResponseV1_1 == NULL",
---
>             RLOGD("setSimCardPowerResponse: radioService[%d]->mRadioResponseV1_6 and V1_1 == NULL",
6627,6628c9752,9755
<             Return<void> retStatus
<                     = radioService[slotId]->mRadioResponse->setSimCardPowerResponse(responseInfo);
---
>             RadioResponseInfo responseInfo = {};
>             populateResponseInfo(responseInfo, serial, responseType, e);
>             Return<void> retStatus = radioService[slotId]->mRadioResponse
>                     ->setSimCardPowerResponse(responseInfo);
6633c9760
<                 "radioService[%d]->mRadioResponseV1_1 == NULL", slotId, slotId);
---
>                 "radioService[%d]->mRadioResponseV1_1 and V1_6 == NULL", slotId, slotId);
6638,6639c9765,9766
< int radio::startNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
<                                     void *response, size_t responseLen) {
---
> int radio_1_6::startNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                         void *response, size_t responseLen) {
6644c9771,9774
<     if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
---
>     if (radioService[slotId]->mRadioResponseV1_1 != NULL ||
>           radioService[slotId]->mRadioResponseV1_2 != NULL ||
>           radioService[slotId]->mRadioResponseV1_4 != NULL ||
>           radioService[slotId]->mRadioResponseV1_6 != NULL) {
6647,6651c9777,9797
<         Return<void> retStatus
<                 = radioService[slotId]->mRadioResponseV1_1->startNetworkScanResponse(responseInfo);
<         radioService[slotId]->checkReturnStatus(retStatus);
<     } else {
<         RLOGE("startNetworkScanResponse: radioService[%d]->mRadioResponseV1_1 == NULL", slotId);
---
> 
>         if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                     ->startNetworkScanResponse_1_5(responseInfo);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_4
>                     ->startNetworkScanResponse_1_4(responseInfo);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>             Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2
>                     ->startNetworkScanResponse(responseInfo);
>             radioService[slotId]->checkReturnStatus(retStatus);
>         }  else if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
>           Return<void> retStatus = radioService[slotId]->mRadioResponseV1_1
>                   ->startNetworkScanResponse(responseInfo);
>           radioService[slotId]->checkReturnStatus(retStatus);
>         } else {
>             RLOGE("startNetworkScanResponse: radioService[%d]->mRadioResponseV1_1 == NULL or "
>                     "radioService[%d]->mRadioResponseV1_4 == NULL", slotId, slotId);
>         }
6657c9803
< int radio::stopNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
---
> int radio_1_6::stopNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
6675a9822,9839
> int radio_1_6::emergencyDialResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                     void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("emergencyDialResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_4 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_4->emergencyDialResponse(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("emergencyDialResponse: radioService[%d]->mRadioResponseV1_4 == NULL", slotId);
>     }
>     return 0;
> }
> 
6682c9846
< int radio::startKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
---
> int radio_1_6::startKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
6710c9874
< int radio::stopKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
---
> int radio_1_6::stopKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
6729a9894,10459
> int radio_1_6::getModemStackStatusResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                     void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_3 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_3 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_3->getModemStackStatusResponse(
>             responseInfo, true);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::enableModemResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                     void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_3 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_3 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_3->enableModemResponse(responseInfo);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::sendRequestRawResponse(int slotId,
>                                   int responseType, int serial, RIL_Errno e,
>                                   void *response, size_t responseLen) {
> #if VDBG
>    RLOGD("sendRequestRawResponse: serial %d", serial);
> #endif
> 
>     if (!kOemHookEnabled) return 0;
> 
>     if (oemHookService[slotId]->mOemHookResponse != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         hidl_vec<uint8_t> data;
> 
>         if (response == NULL) {
>             RLOGE("sendRequestRawResponse: Invalid response");
>             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>         } else {
>             data.setToExternal((uint8_t *) response, responseLen);
>         }
>         Return<void> retStatus = oemHookService[slotId]->mOemHookResponse->
>                 sendRequestRawResponse(responseInfo, data);
>         checkReturnStatus(slotId, retStatus, false);
>     } else {
>         RLOGE("sendRequestRawResponse: oemHookService[%d]->mOemHookResponse == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::sendRequestStringsResponse(int slotId,
>                                       int responseType, int serial, RIL_Errno e,
>                                       void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("sendRequestStringsResponse: serial %d", serial);
> #endif
> 
>     if (!kOemHookEnabled) return 0;
> 
>     if (oemHookService[slotId]->mOemHookResponse != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         hidl_vec<hidl_string> data;
> 
>         if ((response == NULL && responseLen != 0) || responseLen % sizeof(char *) != 0) {
>             RLOGE("sendRequestStringsResponse Invalid response: NULL");
>             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>         } else {
>             char **resp = (char **) response;
>             int numStrings = responseLen / sizeof(char *);
>             data.resize(numStrings);
>             for (int i = 0; i < numStrings; i++) {
>                 data[i] = convertCharPtrToHidlString(resp[i]);
>             }
>         }
>         Return<void> retStatus
>                 = oemHookService[slotId]->mOemHookResponse->sendRequestStringsResponse(
>                 responseInfo, data);
>         checkReturnStatus(slotId, retStatus, false);
>     } else {
>         RLOGE("sendRequestStringsResponse: oemHookService[%d]->mOemHookResponse == "
>                 "NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::setSystemSelectionChannelsResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("setSystemSelectionChannelsResponse: serial %d", serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setSystemSelectionChannelsResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_3 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_3
>                 ->setSystemSelectionChannelsResponse(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setSystemSelectionChannelsResponse: radioService[%d]->mRadioResponse == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::getSystemSelectionChannelsResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("getSystemSelectionChannelsResponse: serial %d", serial);
> #endif
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>       hidl_vec<::android::hardware::radio::V1_5::RadioAccessSpecifier> ret;
>       Return<void> retStatus =
>           radioService[slotId]
>               ->mRadioResponseV1_6->getSystemSelectionChannelsResponse(
>                   responseInfo, ret);
>       radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getSystemSelectionChannelsResponse: radioService[%d]->mRadioResponse == NULL",
>                 slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::setSignalStrengthReportingCriteriaResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("setSignalStrengthReportingCriteriaResponse: serial %d", serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setSignalStrengthReportingCriteriaResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2
>                 ->setSignalStrengthReportingCriteriaResponse(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setSignalStrengthReportingCriteriaResponse: radioService[%d]->mRadioResponse "
>                 "== NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::setLinkCapacityReportingCriteriaResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("setLinkCapacityReportingCriteriaResponse: serial %d", serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->setLinkCapacityReportingCriteriaResponse_1_5(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_2 != NULL) {
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_2
>                 ->setLinkCapacityReportingCriteriaResponse(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("setLinkCapacityReportingCriteriaResponse: radioService[%d]->mRadioResponse "
>                 "== NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::enableUiccApplicationsResponse(int slotId, int responseType, int serial,
>                                     RIL_Errno e, void* /* response */, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_5 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_5 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_5->enableUiccApplicationsResponse(
>             responseInfo);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::areUiccApplicationsEnabledResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     RadioResponseInfo responseInfo = {};
>     populateResponseInfo(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_5 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_5 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     bool enable = false;
>     if (response == NULL || responseLen != sizeof(bool)) {
>         RLOGE("isSimDetachedFromNetwork Invalid response.");
>     } else {
>         enable = (*((bool *) response));
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_5->areUiccApplicationsEnabledResponse(
>             responseInfo, enable);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::getBarringInfoResponse(int slotId,
>                               int responseType, int serial, RIL_Errno e,
>                               void *response, size_t responselen) {
> #if VDBG
>     RLOGD("getBarringInfoResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         populateResponseInfo(responseInfo, serial, responseType, e);
>         ::android::hardware::radio::V1_5::CellIdentity cellIdentity;
>         hidl_vec<::android::hardware::radio::V1_5::BarringInfo> barringInfos = {};
> 
>         if (response == NULL) { /* data for vts */
>             V1_5::BarringInfo barringInfo = {};
>             barringInfo.serviceType = V1_5::BarringInfo::ServiceType::CS_SERVICE;
>             barringInfo.barringType = V1_5::BarringInfo::BarringType::NONE;
> 
>             V1_5::CellIdentityLte cellIdentityLte = {};
>             cellIdentity.lte(cellIdentityLte);
>             barringInfos.resize(1);
>             barringInfos[0] = barringInfo;
> 
>         Return<void> retStatus
>                 = radioService[slotId]->mRadioResponseV1_5->
>                         getBarringInfoResponse(responseInfo, cellIdentity, barringInfos);
>         radioService[slotId]->checkReturnStatus(retStatus);
>       } else {
>           RLOGE("getBarringInfoResponse: radioService[%d]->mRadioResponse == NULL",
>                   slotId);
>       }
>     }
>     return 0;
> }
> 
> int radio_1_6::sendCdmaSmsExpectMoreResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                              void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("sendCdmaSmsExpectMoreResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         ::android::hardware::radio::V1_6::RadioResponseInfo responseInfo_1_6 = {};
>         SendSmsResult result = makeSendSmsResult_1_6(responseInfo_1_6, serial, responseType, e,
>                 response, responseLen);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6
>                 ->sendCdmaSmsExpectMoreResponse_1_6(responseInfo_1_6, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         SendSmsResult result = makeSendSmsResult(responseInfo, serial, responseType, e, response,
>                 responseLen);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->sendCdmaSmsExpectMoreResponse(responseInfo, result);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("sendCdmaSmsExpectMoreResponse: radioService[%d]->mRadioResponse == NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::supplySimDepersonalizationResponse(int slotId, int responseType, int serial,
>                                                   RIL_Errno e, void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("supplySimDepersonalizationResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponseV1_5 != NULL) {
>         RadioResponseInfo responseInfo = {};
>         int persoType = -1, remainingRetries = -1;
>         int numInts = responseLen / sizeof(int);
>         if (response == NULL || numInts != 2) {
>             RLOGE("getClirResponse Invalid response: NULL");
>             if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
>         } else {
>             int *pInt = (int *) response;
>             persoType = pInt[0];
>             remainingRetries = pInt[1];
>         }
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_5
>                 ->supplySimDepersonalizationResponse(responseInfo, (V1_5::PersoSubstate) persoType,
>                 remainingRetries);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("supplySimDepersonalizationResponse: radioService[%d]->mRadioResponseV1_5 == "
>                 "NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::setNrDualConnectivityStateResponse(int slotId, int responseType, int serial,
>                                     RIL_Errno e, void* /* response */, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->setNrDualConnectivityStateResponse(
>             responseInfo);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::isNrDualConnectivityEnabledResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     bool enable = false;
>     if (response == NULL || responseLen != sizeof(bool)) {
>         RLOGE("isNrDualConnectivityEnabledResponseInvalid response.");
>     } else {
>         enable = (*((bool *) response));
>     }
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->isNrDualConnectivityEnabledResponse(
>             responseInfo, enable);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::allocatePduSessionIdResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>       RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>       return 0;
>     }
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->allocatePduSessionIdResponse(responseInfo, -1);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::releasePduSessionIdResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
> 
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->releasePduSessionIdResponse(responseInfo);
>     radioService[slotId]->checkReturnStatus(retStatus);
>     return 0;
> }
> 
> int radio_1_6::startHandoverResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->startHandoverResponse(responseInfo);
> 
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     return 0;
> }
> 
> int radio_1_6::cancelHandoverResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
>     // If we don't have a radio service, there's nothing we can do
>     if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>         RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>         return 0;
>     }
>     V1_6::RadioResponseInfo responseInfo = {};
>     populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>     Return<void> retStatus =
>             radioService[slotId]->mRadioResponseV1_6->cancelHandoverResponse(responseInfo);
> 
> #if VDBG
>     RLOGD("%s(): %d", __FUNCTION__, serial);
> #endif
>     return 0;
> }
> 
> 
> int radio_1_6::setDataThrottlingResponse(int slotId, int responseType,
>                    int serial, RIL_Errno e, void *response, size_t responselen) {
> #if VDBG
>     RLOGD("setDataThrottlingResponse: serial %d", serial);
> #endif
> 
>    if (radioService[slotId]->mRadioResponseV1_6 == NULL) {
>        RLOGE("%s: radioService[%d]->mRadioResponseV1_6 == NULL", __FUNCTION__, slotId);
>        return 0;
>    }
> 
>    V1_6::RadioResponseInfo responseInfo = {};
>    populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
> 
>    Return<void> retstatus =
>         radioService[slotId]->mRadioResponseV1_6->setDataThrottlingResponse(
>                     responseInfo);
>    radioService[slotId]->checkReturnStatus(retstatus);
>    return 0;
> }
> 
> int radio_1_6::getSlicingConfigResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen) {
> #if VDBG
>     RLOGD("getSlicingConfigResponse: serial %d", serial);
> #endif
> 
>     if (radioService[slotId]->mRadioResponse != NULL) {
>         V1_6::RadioResponseInfo responseInfo = {};
>         populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>         V1_6::SlicingConfig slicingConfig = {};
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->
>                 getSlicingConfigResponse(responseInfo, slicingConfig);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getSlicingConfigResponse: radioService[%d]->mRadioResponse == NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> int radio_1_6::getSimPhonebookRecordsResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("getSimPhonebookRecordsResponse: serial %d", serial);
> #endif
> 
>     // TODO: future implementation needs
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         V1_6::RadioResponseInfo responseInfo = {};
>         populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->
>                 getSimPhonebookRecordsResponse(responseInfo);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getSimPhonebookRecordsResponse: radioService[%d]->mRadioResponse == NULL", slotId);
>     }
>     return 0;
> }
> 
> int radio_1_6::getSimPhonebookCapacityResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("getSimPhonebookCapacityResponse: serial %d", serial);
> #endif
> 
>     // TODO: future implementation needs
>     if (radioService[slotId]->mRadioResponseV1_6 != NULL) {
>         V1_6::RadioResponseInfo responseInfo = {};
>         V1_6::PhonebookCapacity capacity = {};
>         populateResponseInfo_1_6(responseInfo, serial, responseType, e);
> 
>         Return<void> retStatus = radioService[slotId]->mRadioResponseV1_6->
>                 getSimPhonebookCapacityResponse(responseInfo, capacity);
>         radioService[slotId]->checkReturnStatus(retStatus);
>     } else {
>         RLOGE("getSimPhonebookCapacityResponse: radioService[%d]->mRadioResponse == NULL", slotId);
>     }
>     return 0;
> }
> 
> int radio_1_6::updateSimPhonebookRecordsResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen) {
> #if VDBG
>     RLOGD("getSimPhonebookRecordsResponse: serial %d", serial);
> #endif
>     return 0;
> }
> 
6741c10471
< int radio::radioStateChangedInd(int slotId,
---
> int radio_1_6::radioStateChangedInd(int slotId,
6758c10488
< int radio::callStateChangedInd(int slotId,
---
> int radio_1_6::callStateChangedInd(int slotId,
6775c10505
< int radio::networkStateChangedInd(int slotId,
---
> int radio_1_6::networkStateChangedInd(int slotId,
6793c10523
< uint8_t hexCharToInt(uint8_t c) {
---
> extern "C" uint8_t hexCharToInt(uint8_t c) {
6801c10531
< uint8_t * convertHexStringToBytes(void *response, size_t responseLen) {
---
> extern "C" uint8_t * convertHexStringToBytes(void *response, size_t responseLen) {
6829c10559
< int radio::newSmsInd(int slotId, int indicationType,
---
> int radio_1_6::newSmsInd(int slotId, int indicationType,
6859c10589
< int radio::newSmsStatusReportInd(int slotId,
---
> int radio_1_6::newSmsStatusReportInd(int slotId,
6890c10620
< int radio::newSmsOnSimInd(int slotId, int indicationType,
---
> int radio_1_6::newSmsOnSimInd(int slotId, int indicationType,
6911c10641
< int radio::onUssdInd(int slotId, int indicationType,
---
> int radio_1_6::onUssdInd(int slotId, int indicationType,
6935c10665
< int radio::nitzTimeReceivedInd(int slotId,
---
> int radio_1_6::nitzTimeReceivedInd(int slotId,
6962c10692
<     RIL_SignalStrength_v10 *rilSignalStrength = (RIL_SignalStrength_v10 *) response;
---
>     RIL_SignalStrength_v12 *rilSignalStrength = (RIL_SignalStrength_v12 *) response;
7007c10737,10766
< int radio::currentSignalStrengthInd(int slotId,
---
> void convertRilSignalStrengthToHal_1_4(void *response, size_t responseLen,
>         V1_4::SignalStrength& signalStrength_1_4) {
>     SignalStrength signalStrength = {};
>     convertRilSignalStrengthToHal(response, responseLen, signalStrength);
>     signalStrength_1_4.gsm = signalStrength.gw;
>     signalStrength_1_4.cdma = signalStrength.cdma;
>     signalStrength_1_4.evdo = signalStrength.evdo;
>     signalStrength_1_4.lte = signalStrength.lte;
> 
>     RIL_SignalStrength_v12 *rilSignalStrength = (RIL_SignalStrength_v12 *) response;
>     signalStrength_1_4.wcdma.base.signalStrength =
>         rilSignalStrength->WCDMA_SignalStrength.signalStrength;
>     signalStrength_1_4.wcdma.base.bitErrorRate =
>         rilSignalStrength->WCDMA_SignalStrength.bitErrorRate;
>     signalStrength_1_4.wcdma.rscp = INT_MAX;
>     signalStrength_1_4.wcdma.ecno = INT_MAX;
> 
>     signalStrength_1_4.tdscdma.signalStrength = INT_MAX;
>     signalStrength_1_4.tdscdma.bitErrorRate = INT_MAX;
>     signalStrength_1_4.tdscdma.rscp = INT_MAX;
> 
>     signalStrength_1_4.nr.ssRsrp = rilSignalStrength->NR_SignalStrength.ssRsrp;
>     signalStrength_1_4.nr.ssRsrq = rilSignalStrength->NR_SignalStrength.ssRsrq;
>     signalStrength_1_4.nr.ssSinr = rilSignalStrength->NR_SignalStrength.ssSinr;
>     signalStrength_1_4.nr.csiRsrp = rilSignalStrength->NR_SignalStrength.csiRsrp;
>     signalStrength_1_4.nr.csiRsrq = rilSignalStrength->NR_SignalStrength.csiRsrq;
>     signalStrength_1_4.nr.csiSinr = rilSignalStrength->NR_SignalStrength.ssSinr;
> }
> 
> int radio_1_6::currentSignalStrengthInd(int slotId,
7010,7011c10769,10772
<     if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
<         if (response == NULL || responseLen != sizeof(RIL_SignalStrength_v10)) {
---
>     if (radioService[slotId] != NULL &&
>        (radioService[slotId]->mRadioIndication != NULL ||
>         radioService[slotId]->mRadioIndicationV1_4 != NULL)) {
>         if (response == NULL || responseLen != sizeof(RIL_SignalStrength_v12)) {
7016,7018d10776
<         SignalStrength signalStrength = {};
<         convertRilSignalStrengthToHal(response, responseLen, signalStrength);
< 
7022,7023c10780,10791
<         Return<void> retStatus = radioService[slotId]->mRadioIndication->currentSignalStrength(
<                 convertIntToRadioIndicationType(indicationType), signalStrength);
---
>         Return<void> retStatus;
>         if (radioService[slotId]->mRadioIndicationV1_4 != NULL) {
>           V1_4::SignalStrength signalStrength_1_4 = {};
>           convertRilSignalStrengthToHal_1_4(response, responseLen, signalStrength_1_4);
>           retStatus = radioService[slotId]->mRadioIndicationV1_4->currentSignalStrength_1_4(
>                           convertIntToRadioIndicationType(indicationType), signalStrength_1_4);
>         } else {
>           SignalStrength signalStrength = {};
>           convertRilSignalStrengthToHal(response, responseLen, signalStrength);
>           retStatus = radioService[slotId]->mRadioIndication->currentSignalStrength(
>                           convertIntToRadioIndicationType(indicationType), signalStrength);
>         }
7047a10816,10928
> hidl_vec<hidl_string> split(hidl_string str) {
>     std::vector<hidl_string> ret;
>     std::stringstream ss(static_cast<std::string>(str));
> 
>     std::string tok;
> 
>     while(getline(ss, tok, ' ')) {
>         ret.push_back(hidl_string(tok));
>     }
> 
>     return ret;
> }
> 
> ::android::hardware::radio::V1_4::PdpProtocolType convertToPdpProtocolType(hidl_string str) {
>     if (strncmp("IP", str.c_str(), 2) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::IP;
>     } else if (strncmp("IPV6", str.c_str(), 4) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::IPV6;
>     } else if (strncmp("IPV4V6", str.c_str(), 6) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::IPV4V6;
>     } else if (strncmp("PPP", str.c_str(), 3) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::PPP;
>     } else if (strncmp("NON_IP", str.c_str(), 6) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::NON_IP;
>     } else if (strncmp("UNSTRUCTURED", str.c_str(), 12) == 0) {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::UNSTRUCTURED;
>     } else {
>         return ::android::hardware::radio::V1_4::PdpProtocolType::UNKNOWN;
>     }
> }
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v11 *dcResponse,
>         ::android::hardware::radio::V1_4::SetupDataCallResult& dcResult) {
>     dcResult.cause = (::android::hardware::radio::V1_4::DataCallFailCause) dcResponse->status;
>     dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
>     dcResult.cid = dcResponse->cid;
>     dcResult.active = (::android::hardware::radio::V1_4::DataConnActiveStatus)dcResponse->active;
>     dcResult.type = convertToPdpProtocolType(convertCharPtrToHidlString(dcResponse->type));
>     dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
>     dcResult.addresses = split(convertCharPtrToHidlString(dcResponse->addresses));
>     dcResult.dnses = split(convertCharPtrToHidlString(dcResponse->dnses));
>     dcResult.gateways = split(convertCharPtrToHidlString(dcResponse->gateways));
>     dcResult.pcscf = split(convertCharPtrToHidlString(dcResponse->pcscf));
>     dcResult.mtu = dcResponse->mtu;
> }
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v12 *dcResponse,
>         ::android::hardware::radio::V1_5::SetupDataCallResult& dcResult) {
>     dcResult.cause = (::android::hardware::radio::V1_4::DataCallFailCause) dcResponse->status;
>     dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
>     dcResult.cid = dcResponse->cid;
>     dcResult.active = (::android::hardware::radio::V1_4::DataConnActiveStatus)dcResponse->active;
>     dcResult.type = convertToPdpProtocolType(convertCharPtrToHidlString(dcResponse->type));
>     dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
> 
>     std::vector<::android::hardware::radio::V1_5::LinkAddress> linkAddresses;
>     std::stringstream ss(static_cast<std::string>(dcResponse->addresses));
>     std::string tok;
>     while(getline(ss, tok, ' ')) {
>         ::android::hardware::radio::V1_5::LinkAddress la;
>         la.address = hidl_string(tok);
>         la.properties = 0;
>         la.deprecationTime = 0;
>         la.expirationTime = 0;
>         linkAddresses.push_back(la);
>     }
> 
>     dcResult.addresses = linkAddresses;
>     dcResult.dnses = split(convertCharPtrToHidlString(dcResponse->dnses));
>     dcResult.gateways = split(convertCharPtrToHidlString(dcResponse->gateways));
>     dcResult.pcscf = split(convertCharPtrToHidlString(dcResponse->pcscf));
>     dcResult.mtuV4 = dcResponse->mtuV4;
>     dcResult.mtuV6 = dcResponse->mtuV6;
> }
> 
> void convertRilDataCallToHal(RIL_Data_Call_Response_v12 *dcResponse,
>         ::android::hardware::radio::V1_6::SetupDataCallResult& dcResult) {
>     dcResult.cause = (::android::hardware::radio::V1_6::DataCallFailCause) dcResponse->status;
>     dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
>     dcResult.cid = dcResponse->cid;
>     dcResult.active = (::android::hardware::radio::V1_4::DataConnActiveStatus)dcResponse->active;
>     dcResult.type = convertToPdpProtocolType(convertCharPtrToHidlString(dcResponse->type));
>     dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
> 
>     std::vector<::android::hardware::radio::V1_5::LinkAddress> linkAddresses;
>     std::stringstream ss(static_cast<std::string>(dcResponse->addresses));
>     std::string tok;
>     while(getline(ss, tok, ' ')) {
>         ::android::hardware::radio::V1_5::LinkAddress la;
>         la.address = hidl_string(tok);
>         la.properties = 0;
>         la.deprecationTime = 0;
>         la.expirationTime = 0;
>         linkAddresses.push_back(la);
>     }
> 
>     dcResult.addresses = linkAddresses;
>     dcResult.dnses = split(convertCharPtrToHidlString(dcResponse->dnses));
>     dcResult.gateways = split(convertCharPtrToHidlString(dcResponse->gateways));
>     dcResult.pcscf = split(convertCharPtrToHidlString(dcResponse->pcscf));
>     dcResult.mtuV4 = dcResponse->mtuV4;
>     dcResult.mtuV6 = dcResponse->mtuV6;
> 
>     std::vector<::android::hardware::radio::V1_6::TrafficDescriptor> trafficDescriptors;
>     ::android::hardware::radio::V1_6::TrafficDescriptor trafficDescriptor;
>     ::android::hardware::radio::V1_6::OsAppId osAppId;
> 
>     osAppId.osAppId = 1;
>     trafficDescriptor.osAppId.value(osAppId);
>     trafficDescriptors.push_back(trafficDescriptor);
>     dcResult.trafficDescriptors = trafficDescriptors;
> }
> 
7059c10940
< int radio::dataCallListChangedInd(int slotId,
---
> int radio_1_6::dataCallListChangedInd(int slotId,
7083c10964
< int radio::suppSvcNotifyInd(int slotId, int indicationType,
---
> int radio_1_6::suppSvcNotifyInd(int slotId, int indicationType,
7113c10994
< int radio::stkSessionEndInd(int slotId, int indicationType,
---
> int radio_1_6::stkSessionEndInd(int slotId, int indicationType,
7129c11010
< int radio::stkProactiveCommandInd(int slotId,
---
> int radio_1_6::stkProactiveCommandInd(int slotId,
7151c11032
< int radio::stkEventNotifyInd(int slotId, int indicationType,
---
> int radio_1_6::stkEventNotifyInd(int slotId, int indicationType,
7172c11053
< int radio::stkCallSetupInd(int slotId, int indicationType,
---
> int radio_1_6::stkCallSetupInd(int slotId, int indicationType,
7193c11074
< int radio::simSmsStorageFullInd(int slotId,
---
> int radio_1_6::simSmsStorageFullInd(int slotId,
7210c11091
< int radio::simRefreshInd(int slotId, int indicationType,
---
> int radio_1_6::simRefreshInd(int slotId, int indicationType,
7246c11127
< int radio::callRingInd(int slotId, int indicationType,
---
> int radio_1_6::callRingInd(int slotId, int indicationType,
7275c11156
< int radio::simStatusChangedInd(int slotId,
---
> int radio_1_6::simStatusChangedInd(int slotId,
7292c11173
< int radio::cdmaNewSmsInd(int slotId, int indicationType,
---
> int radio_1_6::cdmaNewSmsInd(int slotId, int indicationType,
7340c11221
< int radio::newBroadcastSmsInd(int slotId,
---
> int radio_1_6::newBroadcastSmsInd(int slotId,
7364c11245
< int radio::cdmaRuimSmsStorageFullInd(int slotId,
---
> int radio_1_6::cdmaRuimSmsStorageFullInd(int slotId,
7382c11263
< int radio::restrictedStateChangedInd(int slotId,
---
> int radio_1_6::restrictedStateChangedInd(int slotId,
7405c11286
< int radio::enterEmergencyCallbackModeInd(int slotId,
---
> int radio_1_6::enterEmergencyCallbackModeInd(int slotId,
7423c11304
< int radio::cdmaCallWaitingInd(int slotId,
---
> int radio_1_6::cdmaCallWaitingInd(int slotId,
7456c11337
< int radio::cdmaOtaProvisionStatusInd(int slotId,
---
> int radio_1_6::cdmaOtaProvisionStatusInd(int slotId,
7479c11360
< int radio::cdmaInfoRecInd(int slotId,
---
> int radio_1_6::cdmaInfoRecInd(int slotId,
7657c11538
< int radio::indicateRingbackToneInd(int slotId,
---
> int radio_1_6::indicateRingbackToneInd(int slotId,
7679c11560
< int radio::resendIncallMuteInd(int slotId,
---
> int radio_1_6::resendIncallMuteInd(int slotId,
7696c11577
< int radio::cdmaSubscriptionSourceChangedInd(int slotId,
---
> int radio_1_6::cdmaSubscriptionSourceChangedInd(int slotId,
7720c11601
< int radio::cdmaPrlChangedInd(int slotId,
---
> int radio_1_6::cdmaPrlChangedInd(int slotId,
7742c11623
< int radio::exitEmergencyCallbackModeInd(int slotId,
---
> int radio_1_6::exitEmergencyCallbackModeInd(int slotId,
7760c11641
< int radio::rilConnectedInd(int slotId,
---
> int radio_1_6::rilConnectedInd(int slotId,
7775c11656
< int radio::voiceRadioTechChangedInd(int slotId,
---
> int radio_1_6::voiceRadioTechChangedInd(int slotId,
7820c11701
<                         ril::util::mcc::decode(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mcc);
---
>                         std::to_string(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mcc);
7844c11725
<                         ril::util::mcc::decode(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mcc);
---
>                         std::to_string(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mcc);
7892c11773
<                         ril::util::mcc::decode(rillCellInfo->CellInfo.lte.cellIdentityLte.mcc);
---
>                         std::to_string(rillCellInfo->CellInfo.lte.cellIdentityLte.mcc);
7922,7923c11803
<                         ril::util::mcc::decode(
<                                 rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
---
>                         std::to_string(rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
7945c11825,12144
< int radio::cellInfoListInd(int slotId,
---
> void convertRilCellInfoListToHal_1_2(void *response, size_t responseLen, hidl_vec<V1_2::CellInfo>& records) {
>     int num = responseLen / sizeof(RIL_CellInfo_v12);
>     records.resize(num);
>     RIL_CellInfo_v12 *rillCellInfo = (RIL_CellInfo_v12 *) response;
>     for (int i = 0; i < num; i++) {
>         records[i].cellInfoType = (CellInfoType) rillCellInfo->cellInfoType;
>         records[i].registered = rillCellInfo->registered;
>         records[i].timeStampType = (TimeStampType) rillCellInfo->timeStampType;
>         records[i].timeStamp = rillCellInfo->timeStamp;
>         records[i].connectionStatus =(V1_2::CellConnectionStatus)0;
>         // All vectors should be size 0 except one which will be size 1. Set everything to
>         // size 0 initially.
>         records[i].gsm.resize(0);
>         records[i].wcdma.resize(0);
>         records[i].cdma.resize(0);
>         records[i].lte.resize(0);
>         records[i].tdscdma.resize(0);
>         switch(rillCellInfo->cellInfoType) {
>             case RIL_CELL_INFO_TYPE_GSM: {
>                 records[i].gsm.resize(1);
>                 V1_2::CellInfoGsm *cellInfoGsm = &records[i].gsm[0];
>                 cellInfoGsm->cellIdentityGsm.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mcc);
>                 cellInfoGsm->cellIdentityGsm.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mnc);
>                 cellInfoGsm->cellIdentityGsm.base.lac =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.lac;
>                 cellInfoGsm->cellIdentityGsm.base.cid =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.cid;
>                 cellInfoGsm->cellIdentityGsm.base.arfcn =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.arfcn;
>                 cellInfoGsm->cellIdentityGsm.base.bsic =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.bsic;
>                 cellInfoGsm->signalStrengthGsm.signalStrength =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.signalStrength;
>                 cellInfoGsm->signalStrengthGsm.bitErrorRate =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.bitErrorRate;
>                 cellInfoGsm->signalStrengthGsm.timingAdvance =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.timingAdvance;
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_WCDMA: {
>                 records[i].wcdma.resize(1);
>                 V1_2::CellInfoWcdma *cellInfoWcdma = &records[i].wcdma[0];
>                 cellInfoWcdma->cellIdentityWcdma.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mcc);
>                 cellInfoWcdma->cellIdentityWcdma.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mnc);
>                 cellInfoWcdma->cellIdentityWcdma.base.lac =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.lac;
>                 cellInfoWcdma->cellIdentityWcdma.base.cid =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.cid;
>                 cellInfoWcdma->cellIdentityWcdma.base.psc =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.psc;
>                 cellInfoWcdma->cellIdentityWcdma.base.uarfcn =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.uarfcn;
>                 cellInfoWcdma->signalStrengthWcdma.base.signalStrength =
>                         rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.signalStrength;
>                 cellInfoWcdma->signalStrengthWcdma.base.bitErrorRate =
>                         rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate;
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_CDMA: {
>                 records[i].cdma.resize(1);
>                 V1_2::CellInfoCdma *cellInfoCdma = &records[i].cdma[0];
>                 cellInfoCdma->cellIdentityCdma.base.networkId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.networkId;
>                 cellInfoCdma->cellIdentityCdma.base.systemId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.systemId;
>                 cellInfoCdma->cellIdentityCdma.base.baseStationId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.basestationId;
>                 cellInfoCdma->cellIdentityCdma.base.longitude =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.longitude;
>                 cellInfoCdma->cellIdentityCdma.base.latitude =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.latitude;
>                 cellInfoCdma->signalStrengthCdma.dbm =
>                         rillCellInfo->CellInfo.cdma.signalStrengthCdma.dbm;
>                 cellInfoCdma->signalStrengthCdma.ecio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthCdma.ecio;
>                 cellInfoCdma->signalStrengthEvdo.dbm =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.dbm;
>                 cellInfoCdma->signalStrengthEvdo.ecio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.ecio;
>                 cellInfoCdma->signalStrengthEvdo.signalNoiseRatio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio;
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_LTE: {
>                 records[i].lte.resize(1);
>                 V1_2::CellInfoLte *cellInfoLte = &records[i].lte[0];
>                 cellInfoLte->cellIdentityLte.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.lte.cellIdentityLte.mcc);
>                 cellInfoLte->cellIdentityLte.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.lte.cellIdentityLte.mnc);
>                 cellInfoLte->cellIdentityLte.base.ci =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.ci;
>                 cellInfoLte->cellIdentityLte.base.pci =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.pci;
>                 cellInfoLte->cellIdentityLte.base.tac =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.tac;
>                 cellInfoLte->cellIdentityLte.base.earfcn =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.earfcn;
>                 cellInfoLte->signalStrengthLte.signalStrength =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.signalStrength;
>                 cellInfoLte->signalStrengthLte.rsrp =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rsrp;
>                 cellInfoLte->signalStrengthLte.rsrq =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rsrq;
>                 cellInfoLte->signalStrengthLte.rssnr =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rssnr;
>                 cellInfoLte->signalStrengthLte.cqi =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.cqi;
>                 cellInfoLte->signalStrengthLte.timingAdvance =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.timingAdvance;
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_TD_SCDMA: {
>                 records[i].tdscdma.resize(1);
>                 V1_2::CellInfoTdscdma *cellInfoTdscdma = &records[i].tdscdma[0];
>                 cellInfoTdscdma->cellIdentityTdscdma.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
>                 cellInfoTdscdma->cellIdentityTdscdma.base.mnc =
>                         ril::util::mnc::decode(
>                                 rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
>                 cellInfoTdscdma->cellIdentityTdscdma.base.lac =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.lac;
>                 cellInfoTdscdma->cellIdentityTdscdma.base.cid =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cid;
>                 cellInfoTdscdma->cellIdentityTdscdma.base.cpid =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cpid;
>                 cellInfoTdscdma->signalStrengthTdscdma.rscp =
>                         rillCellInfo->CellInfo.tdscdma.signalStrengthTdscdma.rscp;
>                 break;
>             }
>             default: {
>                 break;
>             }
>         }
>         rillCellInfo += 1;
>     }
> }
> 
> void convertRilCellInfoListToHal_1_4(void *response, size_t responseLen, hidl_vec<V1_4::CellInfo>& records) {
>     int num = responseLen / sizeof(RIL_CellInfo_v16);
>     records.resize(num);
>     RIL_CellInfo_v16 *rillCellInfo = (RIL_CellInfo_v16 *) response;
>     for (int i = 0; i < num; i++) {
>         records[i].isRegistered = rillCellInfo->registered;
>         records[i].connectionStatus = (V1_2::CellConnectionStatus)rillCellInfo->connectionStatus;
> 
>         switch(rillCellInfo->cellInfoType) {
>             case RIL_CELL_INFO_TYPE_GSM: {
>                 V1_2::CellInfoGsm cellInfoGsm;
>                 cellInfoGsm.cellIdentityGsm.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mcc);
>                 cellInfoGsm.cellIdentityGsm.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mnc);
>                 cellInfoGsm.cellIdentityGsm.base.lac =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.lac;
>                 cellInfoGsm.cellIdentityGsm.base.cid =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.cid;
>                 cellInfoGsm.cellIdentityGsm.base.arfcn =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.arfcn;
>                 cellInfoGsm.cellIdentityGsm.base.bsic =
>                         rillCellInfo->CellInfo.gsm.cellIdentityGsm.bsic;
>                 cellInfoGsm.signalStrengthGsm.signalStrength =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.signalStrength;
>                 cellInfoGsm.signalStrengthGsm.bitErrorRate =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.bitErrorRate;
>                 cellInfoGsm.signalStrengthGsm.timingAdvance =
>                         rillCellInfo->CellInfo.gsm.signalStrengthGsm.timingAdvance;
>                 records[i].info.gsm(cellInfoGsm);
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_WCDMA: {
>                 V1_2::CellInfoWcdma cellInfoWcdma;
>                 cellInfoWcdma.cellIdentityWcdma.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mcc);
>                 cellInfoWcdma.cellIdentityWcdma.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mnc);
>                 cellInfoWcdma.cellIdentityWcdma.base.lac =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.lac;
>                 cellInfoWcdma.cellIdentityWcdma.base.cid =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.cid;
>                 cellInfoWcdma.cellIdentityWcdma.base.psc =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.psc;
>                 cellInfoWcdma.cellIdentityWcdma.base.uarfcn =
>                         rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.uarfcn;
>                 cellInfoWcdma.signalStrengthWcdma.base.signalStrength =
>                         rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.signalStrength;
>                 cellInfoWcdma.signalStrengthWcdma.base.bitErrorRate =
>                         rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate;
>                 records[i].info.wcdma(cellInfoWcdma);
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_CDMA: {
>                 V1_2::CellInfoCdma cellInfoCdma;
>                 cellInfoCdma.cellIdentityCdma.base.networkId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.networkId;
>                 cellInfoCdma.cellIdentityCdma.base.systemId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.systemId;
>                 cellInfoCdma.cellIdentityCdma.base.baseStationId =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.basestationId;
>                 cellInfoCdma.cellIdentityCdma.base.longitude =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.longitude;
>                 cellInfoCdma.cellIdentityCdma.base.latitude =
>                         rillCellInfo->CellInfo.cdma.cellIdentityCdma.latitude;
>                 cellInfoCdma.signalStrengthCdma.dbm =
>                         rillCellInfo->CellInfo.cdma.signalStrengthCdma.dbm;
>                 cellInfoCdma.signalStrengthCdma.ecio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthCdma.ecio;
>                 cellInfoCdma.signalStrengthEvdo.dbm =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.dbm;
>                 cellInfoCdma.signalStrengthEvdo.ecio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.ecio;
>                 cellInfoCdma.signalStrengthEvdo.signalNoiseRatio =
>                         rillCellInfo->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio;
>                 records[i].info.cdma(cellInfoCdma);
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_LTE: {
>                 V1_4::CellInfoLte cellInfoLte;
>                 cellInfoLte.base.cellIdentityLte.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.lte.cellIdentityLte.mcc);
>                 cellInfoLte.base.cellIdentityLte.base.mnc =
>                         ril::util::mnc::decode(rillCellInfo->CellInfo.lte.cellIdentityLte.mnc);
>                 cellInfoLte.base.cellIdentityLte.base.ci =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.ci;
>                 cellInfoLte.base.cellIdentityLte.base.pci =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.pci;
>                 cellInfoLte.base.cellIdentityLte.base.tac =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.tac;
>                 cellInfoLte.base.cellIdentityLte.base.earfcn =
>                         rillCellInfo->CellInfo.lte.cellIdentityLte.earfcn;
>                 cellInfoLte.base.signalStrengthLte.signalStrength =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.signalStrength;
>                 cellInfoLte.base.signalStrengthLte.rsrp =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rsrp;
>                 cellInfoLte.base.signalStrengthLte.rsrq =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rsrq;
>                 cellInfoLte.base.signalStrengthLte.rssnr =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.rssnr;
>                 cellInfoLte.base.signalStrengthLte.cqi =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.cqi;
>                 cellInfoLte.base.signalStrengthLte.timingAdvance =
>                         rillCellInfo->CellInfo.lte.signalStrengthLte.timingAdvance;
>                 records[i].info.lte(cellInfoLte);
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_TD_SCDMA: {
>                 V1_2::CellInfoTdscdma cellInfoTdscdma;
>                 cellInfoTdscdma.cellIdentityTdscdma.base.mcc =
>                         std::to_string(rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
>                 cellInfoTdscdma.cellIdentityTdscdma.base.mnc =
>                         ril::util::mnc::decode(
>                                 rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
>                 cellInfoTdscdma.cellIdentityTdscdma.base.lac =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.lac;
>                 cellInfoTdscdma.cellIdentityTdscdma.base.cid =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cid;
>                 cellInfoTdscdma.cellIdentityTdscdma.base.cpid =
>                         rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cpid;
>                 cellInfoTdscdma.signalStrengthTdscdma.rscp =
>                         rillCellInfo->CellInfo.tdscdma.signalStrengthTdscdma.rscp;
>                 records[i].info.tdscdma(cellInfoTdscdma);
>                 break;
>             }
> 
>             case RIL_CELL_INFO_TYPE_NR: {
>                 V1_4::CellInfoNr cellInfoNr;
>                 cellInfoNr.cellidentity.mcc =
>                         std::to_string(rillCellInfo->CellInfo.nr.cellidentity.mcc);
>                 cellInfoNr.cellidentity.mnc =
>                         ril::util::mnc::decode(
>                                 rillCellInfo->CellInfo.nr.cellidentity.mnc);
>                 cellInfoNr.cellidentity.nci =
>                         rillCellInfo->CellInfo.nr.cellidentity.nci;
>                 cellInfoNr.cellidentity.pci =
>                         rillCellInfo->CellInfo.nr.cellidentity.pci;
>                 cellInfoNr.cellidentity.tac =
>                         rillCellInfo->CellInfo.nr.cellidentity.tac;
>                 cellInfoNr.cellidentity.nrarfcn =
>                         rillCellInfo->CellInfo.nr.cellidentity.nrarfcn;
>                 cellInfoNr.cellidentity.operatorNames.alphaLong =
>                         convertCharPtrToHidlString(rillCellInfo->CellInfo.nr.cellidentity.operatorNames.alphaLong);
>                 cellInfoNr.cellidentity.operatorNames.alphaShort =
>                         convertCharPtrToHidlString(rillCellInfo->CellInfo.nr.cellidentity.operatorNames.alphaShort);
> 
>                 cellInfoNr.signalStrength.ssRsrp =
>                         rillCellInfo->CellInfo.nr.signalStrength.ssRsrp;
>                 cellInfoNr.signalStrength.ssRsrq =
>                         rillCellInfo->CellInfo.nr.signalStrength.ssRsrq;
>                 cellInfoNr.signalStrength.ssSinr =
>                         rillCellInfo->CellInfo.nr.signalStrength.ssSinr;
>                 cellInfoNr.signalStrength.csiRsrp =
>                         rillCellInfo->CellInfo.nr.signalStrength.csiRsrp;
>                 cellInfoNr.signalStrength.csiRsrq =
>                         rillCellInfo->CellInfo.nr.signalStrength.csiRsrq;
>                 cellInfoNr.signalStrength.csiSinr =
>                         rillCellInfo->CellInfo.nr.signalStrength.csiSinr;
>                 records[i].info.nr(cellInfoNr);
>                 break;
>             }
>             default: {
>                 break;
>             }
>         }
>         rillCellInfo += 1;
>     }
> }
> 
> int radio_1_6::cellInfoListInd(int slotId,
7970c12169
< int radio::imsNetworkStateChangedInd(int slotId,
---
> int radio_1_6::imsNetworkStateChangedInd(int slotId,
7988c12187
< int radio::subscriptionStatusChangedInd(int slotId,
---
> int radio_1_6::subscriptionStatusChangedInd(int slotId,
8011c12210
< int radio::srvccStateNotifyInd(int slotId,
---
> int radio_1_6::srvccStateNotifyInd(int slotId,
8066c12265
< int radio::hardwareConfigChangedInd(int slotId,
---
> int radio_1_6::hardwareConfigChangedInd(int slotId,
8102c12301
< int radio::radioCapabilityIndicationInd(int slotId,
---
> int radio_1_6::radioCapabilityIndicationInd(int slotId,
8141c12340
< int radio::onSupplementaryServiceIndicationInd(int slotId,
---
> int radio_1_6::onSupplementaryServiceIndicationInd(int slotId,
8221c12420
< int radio::stkCallControlAlphaNotifyInd(int slotId,
---
> int radio_1_6::stkCallControlAlphaNotifyInd(int slotId,
8251c12450
< int radio::lceDataInd(int slotId,
---
> int radio_1_6::lceDataInd(int slotId,
8275c12474
< int radio::pcoDataInd(int slotId,
---
> int radio_1_6::pcoDataInd(int slotId,
8304c12503
< int radio::modemResetInd(int slotId,
---
> int radio_1_6::modemResetInd(int slotId,
8326c12525
< int radio::networkScanResultInd(int slotId,
---
> int radio_1_6::networkScanResultInd(int slotId,
8332c12531
<     if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_1 != NULL) {
---
>     if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_4 != NULL) {
8353c12552
<         Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_1->networkScanResult(
---
>         Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_4->networkScanResult(
8357c12556
<         RLOGE("networkScanResultInd: radioService[%d]->mRadioIndicationV1_1 == NULL", slotId);
---
>         RLOGE("networkScanResultInd: radioService[%d]->mRadioIndicationV1_4 == NULL", slotId);
8362c12561
< int radio::carrierInfoForImsiEncryption(int slotId,
---
> int radio_1_6::carrierInfoForImsiEncryption(int slotId,
8365c12564
<     if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_1 != NULL) {
---
>     if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_4 != NULL) {
8371c12570
<         Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_1->
---
>         Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_4->
8375c12574
<         RLOGE("carrierInfoForImsiEncryption: radioService[%d]->mRadioIndicationV1_1 == NULL",
---
>         RLOGE("carrierInfoForImsiEncryption: radioService[%d]->mRadioIndicationV1_4 == NULL",
8382c12581,12632
< int radio::keepaliveStatusInd(int slotId,
---
> int radio_1_6::reportPhysicalChannelConfigs(int slotId, int indicationType,
>                                             int token, RIL_Errno e,
>                                             void *response,
>                                             size_t responseLen) {
>     if (radioService[slotId] != NULL &&
>         radioService[slotId]->mRadioIndicationV1_4 != NULL) {
>       int *configs = (int *)response;
>       ::android::hardware::hidl_vec<PhysicalChannelConfigV1_4> physChanConfig;
>       physChanConfig.resize(1);
>       physChanConfig[0].base.status =
>           (::android::hardware::radio::V1_2::CellConnectionStatus)configs[0];
>       physChanConfig[0].base.cellBandwidthDownlink = configs[1];
>       physChanConfig[0].rat =
>           (::android::hardware::radio::V1_4::RadioTechnology)configs[2];
>       physChanConfig[0].rfInfo.range(
>           (::android::hardware::radio::V1_4::FrequencyRange)configs[3]);
>       physChanConfig[0].contextIds.resize(1);
>       physChanConfig[0].contextIds[0] = configs[4];
>       RLOGD("reportPhysicalChannelConfigs: %d %d %d %d %d", configs[0],
>             configs[1], configs[2], configs[3], configs[4]);
>       Return<void> retStatus = radioService[slotId]
>           ->mRadioIndicationV1_4->currentPhysicalChannelConfigs_1_4(
>               RadioIndicationType::UNSOLICITED, physChanConfig);
>       radioService[slotId]->checkReturnStatus(retStatus);
>       {
>           // just send the link estimate along with physical channel
>           // config, as it has at least the downlink bandwidth.
>           // Note: the bandwidth is just some hardcoded
>           // value, as there is not way to get that reliably on
>           // virtual devices, as of now.
>           V1_2::LinkCapacityEstimate lce = {
>             .downlinkCapacityKbps = static_cast<uint32_t>(configs[1]),
>             .uplinkCapacityKbps = static_cast<uint32_t>(configs[1])
>           };
>         RLOGD("reporting link capacity estimate download: %d upload: %d",
>                         lce.downlinkCapacityKbps, lce.uplinkCapacityKbps );
>         Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_4->
>             currentLinkCapacityEstimate(RadioIndicationType::UNSOLICITED, lce);
>         radioService[slotId]->checkReturnStatus(retStatus);
>       }
>     } else {
>       RLOGE(
>           "reportPhysicalChannelConfigs: radioService[%d]->mRadioIndicationV1_4 "
>           "== NULL",
>           slotId);
>       return -1;
>     }
> 
>   return 0;
> }
> 
> int radio_1_6::keepaliveStatusInd(int slotId,
8415c12665,12691
< void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) {
---
> int radio_1_6::oemHookRawInd(int slotId,
>                          int indicationType, int token, RIL_Errno e, void *response,
>                          size_t responseLen) {
>     if (!kOemHookEnabled) return 0;
> 
>     if (oemHookService[slotId] != NULL && oemHookService[slotId]->mOemHookIndication != NULL) {
>         if (response == NULL || responseLen == 0) {
>             RLOGE("oemHookRawInd: invalid response");
>             return 0;
>         }
> 
>         hidl_vec<uint8_t> data;
>         data.setToExternal((uint8_t *) response, responseLen);
> #if VDBG
>         RLOGD("oemHookRawInd");
> #endif
>         Return<void> retStatus = oemHookService[slotId]->mOemHookIndication->oemHookRaw(
>                 convertIntToRadioIndicationType(indicationType), data);
>         checkReturnStatus(slotId, retStatus, false);
>     } else {
>         RLOGE("oemHookRawInd: oemHookService[%d]->mOemHookIndication == NULL", slotId);
>     }
> 
>     return 0;
> }
> 
> void radio_1_6::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) {
8444c12720,12722
<         radioService[i] = new RadioImpl;
---
>         RLOGD("sim i = %d registering ...", i);
> 
>         radioService[i] = new RadioImpl_1_6;
8446,8448c12724,12736
<         RLOGD("registerService: starting android::hardware::radio::V1_1::IRadio %s",
<                 serviceNames[i]);
<         (void) radioService[i]->registerAsService(serviceNames[i]);
---
>         RLOGD("registerService: initializing power state to POWER_UP");
>         radioService[i]->mSimCardPowerState = V1_1::CardPowerState::POWER_UP;
>         RLOGD("registerService: starting android::hardware::radio::V1_6::IRadio %s for slot %d",
>                 serviceNames[i], i);
>         android::status_t status = radioService[i]->registerAsService(serviceNames[i]);
>         LOG_ALWAYS_FATAL_IF(status != android::OK, "status %d", status);
> 
>         RLOGD("registerService: OemHook is enabled = %s", kOemHookEnabled ? "true" : "false");
>         if (kOemHookEnabled) {
>             oemHookService[i] = new OemHookImpl;
>             oemHookService[i]->mSlotId = i;
>             // status = oemHookService[i]->registerAsService(serviceNames[i]);
>         }
8459c12747
< pthread_rwlock_t * radio::getRadioServiceRwlock(int slotId) {
---
> pthread_rwlock_t * radio_1_6::getRadioServiceRwlock(int slotId) {
8476c12764
< void radio::setNitzTimeReceived(int slotId, int64_t timeReceived) {
---
> void radio_1_6::setNitzTimeReceived(int slotId, long timeReceived) {
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/ril_service.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/ril_service.h
23c23
< namespace radio {
---
> namespace radio_1_6 {
120c120
< int sendSMSExpectMoreResponse(int slotId,
---
> int sendSmsExpectMoreResponse(int slotId,
285a286,293
> int setPreferredNetworkTypeBitmapResponse(int slotId,
>                                    int responseType, int serial, RIL_Errno e, void *response,
>                                    size_t responselen);
> 
> int getPreferredNetworkTypeBitmapResponse(int slotId,
>                                    int responseType, int serial, RIL_Errno e, void *response,
>                                    size_t responselen);
> 
523a532,538
> int getModemStackStatusResponse(int slotId,
>                                 int responseType, int serial, RIL_Errno e,
>                                 void *response, size_t responselen);
> 
> int enableModemResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                 void *response, size_t responselen);
> 
643a659,662
> int oemHookRawInd(int slotId,
>                   int indicationType, int token, RIL_Errno e, void *response,
>                   size_t responselen);
> 
719a739,741
> int reportPhysicalChannelConfigs(int slotId, int indicationType,
>                         int token, RIL_Errno e, void *response, size_t responselen);
> 
723a746,753
> int sendRequestRawResponse(int slotId,
>                            int responseType, int serial, RIL_Errno e,
>                            void *response, size_t responseLen);
> 
> int sendRequestStringsResponse(int slotId,
>                                int responseType, int serial, RIL_Errno e,
>                                void *response, size_t responseLen);
> 
727a758,761
> int emergencyDialResponse(int slotId,
>                           int responseType, int serial, RIL_Errno e,
>                           void *response, size_t responselen);
> 
731a766,833
> int setSystemSelectionChannelsResponse(int slotId, int responseType, int serial,
>                                        RIL_Errno e, void *response, size_t responseLen);
> 
> int getSystemSelectionChannelsResponse(int slotId, int responseType, int serial,
>                                        RIL_Errno e, void *response, size_t responseLen);
> 
> int setSignalStrengthReportingCriteriaResponse(int slotId, int responseType, int serial,
>                                                RIL_Errno e, void *response, size_t responselen);
> 
> int setLinkCapacityReportingCriteriaResponse(int slotId, int responseType, int serial,
>                                              RIL_Errno e, void *response, size_t responselen);
> 
> int enableUiccApplicationsResponse(int slotId,
>                                  int responseType, int serial, RIL_Errno e,
>                                  void *response, size_t responselen);
> 
> int areUiccApplicationsEnabledResponse(int slotId,
>                                      int responseType, int serial, RIL_Errno e,
>                                      void *response, size_t responselen);
> 
> int setRadioPowerResponse(int slotId, int responseType, int serial, RIL_Errno e, void *response,
>                           size_t responselen);
> 
> int getBarringInfoResponse(int slotId, int responseType, int serial, RIL_Errno e, void *response,
>                            size_t responselen);
> 
> int sendCdmaSmsExpectMoreResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                   void *response, size_t responselen);
> 
> int supplySimDepersonalizationResponse(int slotId, int responseType, int serial, RIL_Errno e,
>                                        void *response, size_t responselen);
> 
> int setNrDualConnectivityStateResponse(int slotId, int responseType, int serial,
>                                     RIL_Errno e, void* /* response */, size_t responseLen);
> int isNrDualConnectivityEnabledResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen);
> 
> int allocatePduSessionIdResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen);
> int releasePduSessionIdResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen);
> int startHandoverResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen);
> int cancelHandoverResponse(int slotId, int responseType, int serial,
>                                         RIL_Errno e, void* response, size_t responseLen);
> 
> int setAllowedNetworkTypesBitmapResponse(int slotId, int responseType, int serial,
>                                   RIL_Errno e, void *response, size_t responselen);
> 
> int setDataThrottlingResponse(int slotId, int responseType, int serial,
>                               RIL_Errno e, void *response, size_t responselen);
> 
> int getAllowedNetworkTypesBitmapResponse(int slotId, int responseType, int serial,
>                                   RIL_Errno e, void *response, size_t responselen);
> 
> int getSlicingConfigResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen);
> 
> int getSimPhonebookRecordsResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen);
> 
> int getSimPhonebookCapacityResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen);
> 
> int updateSimPhonebookRecordsResponse(int slotId, int responseType, int serial,
>                              RIL_Errno e, void *response, size_t responseLen);
> 
> 
734c836,868
< void setNitzTimeReceived(int slotId, int64_t timeReceived);
---
> void setNitzTimeReceived(int slotId, long timeReceived);
> 
> /******************************************************************************/
> /*          Radio Config interfaces' corresponding responseFunction           */
> /******************************************************************************/
> void registerConfigService(RIL_RadioFunctions *callbacks, android::CommandInfo *commands);
> 
> int getSimSlotsStatusResponse(int slotId, int responseType, int serial,
>                               RIL_Errno e, void *response, size_t responseLen);
> 
> int setSimSlotsMappingResponse(int slotId, int responseType, int serial,
>                                RIL_Errno e, void *response, size_t responseLen);
> 
> int getPhoneCapabilityResponse(int slotId, int responseType, int serial,
>                                RIL_Errno e, void *response, size_t responseLen);
> 
> int setPreferredDataModemResponse(int slotId, int responseType, int serial,
>                                   RIL_Errno e, void *response, size_t responseLen);
> 
> int setModemsConfigResponse(int slotId, int responseType, int serial,
>                             RIL_Errno e, void *response, size_t responseLen);
> 
> int getModemsConfigResponse(int slotId, int responseType, int serial,
>                             RIL_Errno e, void *response, size_t responseLen);
> 
> int getHalDeviceCapabilitiesResponse(int slotId, int responseType, int serial,
>                             RIL_Errno e, void *response, size_t responseLen);
> 
> /******************************************************************************/
> /*    Radio Config unsolicited interfaces' corresponding responseFunction     */
> /******************************************************************************/
> int simSlotsStatusChanged(int slotId, int indicationType, int token,
>                           RIL_Errno e, void *response, size_t responseLen);
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/ril_unsol_commands.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/ril_unsol_commands.h
17,57c17,57
<     {RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, radio::radioStateChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, radio::callStateChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, radio::networkStateChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_NEW_SMS, radio::newSmsInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT, radio::newSmsStatusReportInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM, radio::newSmsOnSimInd, WAKE_PARTIAL},
<     {RIL_UNSOL_ON_USSD, radio::onUssdInd, WAKE_PARTIAL},
<     {RIL_UNSOL_ON_USSD_REQUEST, radio::onUssdInd, DONT_WAKE},
<     {RIL_UNSOL_NITZ_TIME_RECEIVED, radio::nitzTimeReceivedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_SIGNAL_STRENGTH, radio::currentSignalStrengthInd, DONT_WAKE},
<     {RIL_UNSOL_DATA_CALL_LIST_CHANGED, radio::dataCallListChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_SUPP_SVC_NOTIFICATION, radio::suppSvcNotifyInd, WAKE_PARTIAL},
<     {RIL_UNSOL_STK_SESSION_END, radio::stkSessionEndInd, WAKE_PARTIAL},
<     {RIL_UNSOL_STK_PROACTIVE_COMMAND, radio::stkProactiveCommandInd, WAKE_PARTIAL},
<     {RIL_UNSOL_STK_EVENT_NOTIFY, radio::stkEventNotifyInd, WAKE_PARTIAL},
<     {RIL_UNSOL_STK_CALL_SETUP, radio::stkCallSetupInd, WAKE_PARTIAL},
<     {RIL_UNSOL_SIM_SMS_STORAGE_FULL, radio::simSmsStorageFullInd, WAKE_PARTIAL},
<     {RIL_UNSOL_SIM_REFRESH, radio::simRefreshInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CALL_RING, radio::callRingInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, radio::simStatusChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_CDMA_NEW_SMS, radio::cdmaNewSmsInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS, radio::newBroadcastSmsInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL, radio::cdmaRuimSmsStorageFullInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESTRICTED_STATE_CHANGED, radio::restrictedStateChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, radio::enterEmergencyCallbackModeInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_CALL_WAITING, radio::cdmaCallWaitingInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, radio::cdmaOtaProvisionStatusInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_INFO_REC, radio::cdmaInfoRecInd, WAKE_PARTIAL},
<     {RIL_UNSOL_OEM_HOOK_RAW, NULL, WAKE_PARTIAL},
<     {RIL_UNSOL_RINGBACK_TONE, radio::indicateRingbackToneInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESEND_INCALL_MUTE, radio::resendIncallMuteInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, radio::cdmaSubscriptionSourceChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CDMA_PRL_CHANGED, radio::cdmaPrlChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, radio::exitEmergencyCallbackModeInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RIL_CONNECTED, radio::rilConnectedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, radio::voiceRadioTechChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CELL_INFO_LIST, radio::cellInfoListInd, WAKE_PARTIAL},
<     {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, radio::imsNetworkStateChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, radio::subscriptionStatusChangedInd, WAKE_PARTIAL},
<     {RIL_UNSOL_SRVCC_STATE_NOTIFY, radio::srvccStateNotifyInd, WAKE_PARTIAL},
<     {RIL_UNSOL_HARDWARE_CONFIG_CHANGED, radio::hardwareConfigChangedInd, WAKE_PARTIAL},
---
>     {RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, radio_1_6::radioStateChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, radio_1_6::callStateChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, radio_1_6::networkStateChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_NEW_SMS, radio_1_6::newSmsInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT, radio_1_6::newSmsStatusReportInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM, radio_1_6::newSmsOnSimInd, WAKE_PARTIAL},
>     {RIL_UNSOL_ON_USSD, radio_1_6::onUssdInd, WAKE_PARTIAL},
>     {RIL_UNSOL_ON_USSD_REQUEST, radio_1_6::onUssdInd, DONT_WAKE},
>     {RIL_UNSOL_NITZ_TIME_RECEIVED, radio_1_6::nitzTimeReceivedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_SIGNAL_STRENGTH, radio_1_6::currentSignalStrengthInd, DONT_WAKE},
>     {RIL_UNSOL_DATA_CALL_LIST_CHANGED, radio_1_6::dataCallListChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_SUPP_SVC_NOTIFICATION, radio_1_6::suppSvcNotifyInd, WAKE_PARTIAL},
>     {RIL_UNSOL_STK_SESSION_END, radio_1_6::stkSessionEndInd, WAKE_PARTIAL},
>     {RIL_UNSOL_STK_PROACTIVE_COMMAND, radio_1_6::stkProactiveCommandInd, WAKE_PARTIAL},
>     {RIL_UNSOL_STK_EVENT_NOTIFY, radio_1_6::stkEventNotifyInd, WAKE_PARTIAL},
>     {RIL_UNSOL_STK_CALL_SETUP, radio_1_6::stkCallSetupInd, WAKE_PARTIAL},
>     {RIL_UNSOL_SIM_SMS_STORAGE_FULL, radio_1_6::simSmsStorageFullInd, WAKE_PARTIAL},
>     {RIL_UNSOL_SIM_REFRESH, radio_1_6::simRefreshInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CALL_RING, radio_1_6::callRingInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, radio_1_6::simStatusChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_CDMA_NEW_SMS, radio_1_6::cdmaNewSmsInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS, radio_1_6::newBroadcastSmsInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL, radio_1_6::cdmaRuimSmsStorageFullInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESTRICTED_STATE_CHANGED, radio_1_6::restrictedStateChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, radio_1_6::enterEmergencyCallbackModeInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_CALL_WAITING, radio_1_6::cdmaCallWaitingInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, radio_1_6::cdmaOtaProvisionStatusInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_INFO_REC, radio_1_6::cdmaInfoRecInd, WAKE_PARTIAL},
>     {RIL_UNSOL_OEM_HOOK_RAW, radio_1_6::oemHookRawInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RINGBACK_TONE, radio_1_6::indicateRingbackToneInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESEND_INCALL_MUTE, radio_1_6::resendIncallMuteInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, radio_1_6::cdmaSubscriptionSourceChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CDMA_PRL_CHANGED, radio_1_6::cdmaPrlChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, radio_1_6::exitEmergencyCallbackModeInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RIL_CONNECTED, radio_1_6::rilConnectedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, radio_1_6::voiceRadioTechChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CELL_INFO_LIST, radio_1_6::cellInfoListInd, WAKE_PARTIAL},
>     {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, radio_1_6::imsNetworkStateChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, radio_1_6::subscriptionStatusChangedInd, WAKE_PARTIAL},
>     {RIL_UNSOL_SRVCC_STATE_NOTIFY, radio_1_6::srvccStateNotifyInd, WAKE_PARTIAL},
>     {RIL_UNSOL_HARDWARE_CONFIG_CHANGED, radio_1_6::hardwareConfigChangedInd, WAKE_PARTIAL},
59,67c59,68
<     {RIL_UNSOL_RADIO_CAPABILITY, radio::radioCapabilityIndicationInd, WAKE_PARTIAL},
<     {RIL_UNSOL_ON_SS, radio::onSupplementaryServiceIndicationInd, WAKE_PARTIAL},
<     {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, radio::stkCallControlAlphaNotifyInd, WAKE_PARTIAL},
<     {RIL_UNSOL_LCEDATA_RECV, radio::lceDataInd, WAKE_PARTIAL},
<     {RIL_UNSOL_PCO_DATA, radio::pcoDataInd, WAKE_PARTIAL},
<     {RIL_UNSOL_MODEM_RESTART, radio::modemResetInd, WAKE_PARTIAL},
<     {RIL_UNSOL_CARRIER_INFO_IMSI_ENCRYPTION, radio::carrierInfoForImsiEncryption, WAKE_PARTIAL},
<     {RIL_UNSOL_NETWORK_SCAN_RESULT, radio::networkScanResultInd, WAKE_PARTIAL},
<     {RIL_UNSOL_KEEPALIVE_STATUS, radio::keepaliveStatusInd, WAKE_PARTIAL},
---
>     {RIL_UNSOL_RADIO_CAPABILITY, radio_1_6::radioCapabilityIndicationInd, WAKE_PARTIAL},
>     {RIL_UNSOL_ON_SS, radio_1_6::onSupplementaryServiceIndicationInd, WAKE_PARTIAL},
>     {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, radio_1_6::stkCallControlAlphaNotifyInd, WAKE_PARTIAL},
>     {RIL_UNSOL_LCEDATA_RECV, radio_1_6::lceDataInd, WAKE_PARTIAL},
>     {RIL_UNSOL_PCO_DATA, radio_1_6::pcoDataInd, WAKE_PARTIAL},
>     {RIL_UNSOL_MODEM_RESTART, radio_1_6::modemResetInd, WAKE_PARTIAL},
>     {RIL_UNSOL_CARRIER_INFO_IMSI_ENCRYPTION, radio_1_6::carrierInfoForImsiEncryption, WAKE_PARTIAL},
>     {RIL_UNSOL_NETWORK_SCAN_RESULT, radio_1_6::networkScanResultInd, WAKE_PARTIAL},
>     {RIL_UNSOL_KEEPALIVE_STATUS, radio_1_6::keepaliveStatusInd, WAKE_PARTIAL},
>     {RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS, radio_1_6::reportPhysicalChannelConfigs, WAKE_PARTIAL},
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/libril/sap_service.cpp /home/yajat/Desktop/H618-Android12-Src/hardware/ril/libril/sap_service.cpp
19a20
> #include <android/hardware/radio/1.2/ISap.h>
45c46
< struct SapImpl : public android::hardware::radio::V1_1::ISap {
---
> struct SapImpl : public android::hardware::radio::V1_2::ISap {
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/Android.mk /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/Android.mk
8a9
>     base64util.cpp \
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/atchannel.c /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/atchannel.c
55c55
< void  AT_DUMP(const char*  prefix, const char*  buff, int  len)
---
> void  AT_DUMP(const char*  prefix __unused, const char*  buff, int  len)
743a744
>     bool inEmulator;
748a750,751
> 
>     pthread_mutex_lock(&s_writeMutex);
755a759,760
>     pthread_mutex_unlock(&s_writeMutex);
> 
894a900
>     bool inEmulator;
899a906,909
>     inEmulator = isInEmulator();
>     if (inEmulator) {
>         pthread_mutex_lock(&s_writeMutex);
>     }
919a930,932
>     if (inEmulator) {
>         pthread_mutex_unlock(&s_writeMutex);
>     }
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/at_tok.c /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/at_tok.c
57c57
< static void skipNextComma(char **p_cur)
---
> void skipNextComma(char **p_cur)
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/at_tok.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/at_tok.h
29a30,31
> void skipNextComma(char **p_cur);
> 
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril: base64util.cpp
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril: base64util.h
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/misc.c /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/misc.c
18a19
> #include <fcntl.h>
29a31,49
> }
> 
> // Returns true iff running this process in an emulator VM
> bool isInEmulator(void) {
>   static int inQemu = -1;
>   if (inQemu < 0) {
>       char propValue[PROP_VALUE_MAX];
>       inQemu = (__system_property_get("ro.boot.qemu", propValue) != 0);
>   }
>   return inQemu == 1;
> }
> 
> int qemu_open_modem_port() {
>     char propValue[PROP_VALUE_MAX];
>     if (__system_property_get("vendor.qemu.vport.modem", propValue) <= 0) {
>         return -1;
>     }
>     int fd = open(propValue, O_RDWR);
>     return fd;
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/misc.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/misc.h
20a21,24
> /** Returns true iff running this process in an emulator VM */
> bool isInEmulator(void);
> /** open the modem port inside emulator VM; -1 if fails */
> int qemu_open_modem_port();
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/reference-ril.c /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/reference-ril.c
33a34
> #include "base64util.h"
43a45,46
> #include <linux/vm_sockets.h>
> #include <arpa/inet.h>
54a58,59
> #define MAX_PDP         3
> 
56a62,64
> #ifdef CUTTLEFISH_ENABLE
> #define PPP_TTY_PATH_ETH0 "rmnet0"
> #else
58,59c66,74
< // This is used if Wifi is supported to separate radio and wifi interface
< #define PPP_TTY_PATH_RADIO0 "radio0"
---
> #endif
> // This is used for emulator
> #define EMULATOR_RADIO_INTERFACE "eth0"
> 
> // for sim
> #define AUTH_CONTEXT_EAP_SIM                    128
> #define AUTH_CONTEXT_EAP_AKA                    129
> #define SIM_AUTH_RESPONSE_SUCCESS               0
> #define SIM_AUTH_RESPONSE_SYNC_FAILURE          3
73c88
< // Some varients of the TI stack do not support the +CGEV unsolicited
---
> // Some variants of the TI stack do not support the +CGEV unsolicited
83c98,100
< #define MDM_LTE         0x10
---
> #define MDM_TDSCDMA     0x10
> #define MDM_LTE         0x20
> #define MDM_NR          0x40
129a147,168
>     MDM_LTE | MDM_WCDMA,                                 // 12 - LTE and WCDMA
>     MDM_TDSCDMA,                                         // 13 - TD-SCDMA only
>     MDM_WCDMA | MDM_TDSCDMA,                             // 14 - TD-SCDMA and WCDMA
>     MDM_LTE | MDM_TDSCDMA,                               // 15 - LTE and TD-SCDMA
>     MDM_TDSCDMA | MDM_GSM,                               // 16 - TD-SCDMA and GSM
>     MDM_LTE | MDM_TDSCDMA | MDM_GSM,                     // 17 - TD-SCDMA, GSM and LTE
>     MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,                   // 18 - TD-SCDMA, GSM and WCDMA
>     MDM_LTE | MDM_WCDMA | MDM_TDSCDMA,                   // 19 - LTE, TD-SCDMA and WCDMA
>     MDM_LTE | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,         // 20 - LTE, TD-SCDMA, GSM, and WCDMA
>     MDM_EVDO | MDM_CDMA | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,            // 21 - TD-SCDMA, CDMA, EVDO, GSM and WCDMA
>     MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,  // 22 - LTE, TDCSDMA, CDMA, EVDO, GSM and WCDMA
>     MDM_NR,                                                             // 23 - NR 5G only mode
>     MDM_NR | MDM_LTE,                                                   // 24 - NR 5G, LTE
>     MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO,                             // 25 - NR 5G, LTE, CDMA and EvDo
>     MDM_NR | MDM_LTE | MDM_WCDMA | MDM_GSM,                             // 26 - NR 5G, LTE, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,       // 27 - NR 5G, LTE, CDMA, EvDo, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_WCDMA,                                       // 28 - NR 5G, LTE and WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA,                                     // 29 - NR 5G, LTE and TDSCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_GSM,                           // 30 - NR 5G, LTE, TD-SCDMA and GSM
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA,                         // 31 - NR 5G, LTE, TD-SCDMA, WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA | MDM_GSM,               // 32 - NR 5G, LTE, TD-SCDMA, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,  // 33 - NR 5G, LTE, TD-SCDMA, CDMA, EVDO, GSM and WCDMA
144a184,254
>     MDM_LTE | MDM_WCDMA,                                 // 12 - LTE and WCDMA
>     MDM_TDSCDMA,                                         // 13 - TD-SCDMA only
>     MDM_WCDMA | MDM_TDSCDMA,                             // 14 - TD-SCDMA and WCDMA
>     MDM_LTE | MDM_TDSCDMA,                               // 15 - LTE and TD-SCDMA
>     MDM_TDSCDMA | MDM_GSM,                               // 16 - TD-SCDMA and GSM
>     MDM_LTE | MDM_TDSCDMA | MDM_GSM,                     // 17 - TD-SCDMA, GSM and LTE
>     MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,                   // 18 - TD-SCDMA, GSM and WCDMA
>     MDM_LTE | MDM_WCDMA | MDM_TDSCDMA,                   // 19 - LTE, TD-SCDMA and WCDMA
>     MDM_LTE | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,         // 20 - LTE, TD-SCDMA, GSM, and WCDMA
>     MDM_EVDO | MDM_CDMA | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM,            // 21 - TD-SCDMA, CDMA, EVDO, GSM and WCDMA
>     MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,  // 22 - LTE, TDCSDMA, CDMA, EVDO, GSM and WCDMA
>     MDM_NR,                                                             // 23 - NR 5G only mode
>     MDM_NR | MDM_LTE,                                                   // 24 - NR 5G, LTE
>     MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO,                             // 25 - NR 5G, LTE, CDMA and EvDo
>     MDM_NR | MDM_LTE | MDM_WCDMA | MDM_GSM,                             // 26 - NR 5G, LTE, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,       // 27 - NR 5G, LTE, CDMA, EvDo, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_WCDMA,                                       // 28 - NR 5G, LTE and WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA,                                     // 29 - NR 5G, LTE and TDSCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_GSM,                           // 30 - NR 5G, LTE, TD-SCDMA and GSM
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA,                         // 31 - NR 5G, LTE, TD-SCDMA, WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA | MDM_GSM,               // 32 - NR 5G, LTE, TD-SCDMA, GSM and WCDMA
>     MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM,  // 33 - NR 5G, LTE, TD-SCDMA, CDMA, EVDO, GSM and WCDMA
> };
> 
> #define GSM   (RAF_GSM | RAF_GPRS | RAF_EDGE)
> #define CDMA  (RAF_IS95A | RAF_IS95B | RAF_1xRTT)
> #define EVDO  (RAF_EVDO_0 | RAF_EVDO_A | RAF_EVDO_B | RAF_EHRPD)
> #define WCDMA (RAF_HSUPA | RAF_HSDPA | RAF_HSPA | RAF_HSPAP | RAF_UMTS)
> #define LTE   (RAF_LTE | RAF_LTE_CA)
> #define NR    (RAF_NR)
> 
> typedef struct {
>     int bitmap;
>     int type;
> } NetworkTypeBitmap;
> 
> static NetworkTypeBitmap s_networkMask[] = {
>     {WCDMA | GSM,                     MDM_GSM | (MDM_WCDMA << 8)},                // 0 - GSM / WCDMA Pref
>     {GSM,                             MDM_GSM},                                   // 1 - GSM only
>     {WCDMA,                           MDM_WCDMA},                                 // 2 - WCDMA only
>     {WCDMA | GSM,                     MDM_GSM | MDM_WCDMA},                       // 3 - GSM / WCDMA Auto
>     {CDMA | EVDO,                     MDM_CDMA | MDM_EVDO},                       // 4 - CDMA / EvDo Auto
>     {CDMA,                            MDM_CDMA},                                  // 5 - CDMA only
>     {EVDO,                            MDM_EVDO},                                  // 6 - EvDo only
>     {GSM | WCDMA | CDMA | EVDO,       MDM_GSM | MDM_WCDMA | MDM_CDMA | MDM_EVDO}, // 7 - GSM/WCDMA, CDMA, EvDo
>     {LTE | CDMA | EVDO,               MDM_LTE | MDM_CDMA | MDM_EVDO},             // 8 - LTE, CDMA and EvDo
>     {LTE | GSM | WCDMA,               MDM_LTE | MDM_GSM | MDM_WCDMA},             // 9 - LTE, GSM/WCDMA
>     {LTE | CDMA | EVDO | GSM | WCDMA, MDM_LTE | MDM_CDMA | MDM_EVDO | MDM_GSM | MDM_WCDMA}, // 10 - LTE, CDMA, EvDo, GSM/WCDMA
>     {LTE,                             MDM_LTE},                                             // 11 - LTE only
>     {LTE | WCDMA,                     MDM_LTE | MDM_WCDMA},                                 // 12 - LTE and WCDMA
>     {RAF_TD_SCDMA,                    MDM_TDSCDMA},                                         // 13 - TD-SCDMA only
>     {RAF_TD_SCDMA | WCDMA,            MDM_WCDMA | MDM_TDSCDMA},                             // 14 - TD-SCDMA and WCDMA
>     {LTE | RAF_TD_SCDMA,              MDM_LTE | MDM_TDSCDMA},                               // 15 - LTE and TD-SCDMA
>     {RAF_TD_SCDMA | GSM,              MDM_TDSCDMA | MDM_GSM},                               // 16 - TD-SCDMA and GSM
>     {LTE | RAF_TD_SCDMA | GSM,        MDM_LTE | MDM_TDSCDMA | MDM_GSM},                     // 17 - TD-SCDMA, GSM and LTE
>     {RAF_TD_SCDMA | GSM | WCDMA,      MDM_WCDMA | MDM_TDSCDMA | MDM_GSM},                   // 18 - TD-SCDMA, GSM and WCDMA
>     {LTE | RAF_TD_SCDMA | WCDMA,      MDM_LTE | MDM_WCDMA | MDM_TDSCDMA},                   // 19 - LTE, TD-SCDMA and WCDMA
>     {LTE | RAF_TD_SCDMA | GSM | WCDMA,MDM_LTE | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM},         // 20 - LTE, TD-SCDMA, GSM, and WCDMA
>     {RAF_TD_SCDMA | CDMA | EVDO | GSM | WCDMA,  MDM_EVDO | MDM_CDMA | MDM_WCDMA | MDM_TDSCDMA | MDM_GSM},            // 21 - TD-SCDMA, CDMA, EVDO, GSM and WCDMA
>     {LTE | RAF_TD_SCDMA | CDMA | EVDO | GSM | WCDMA, MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM},  // 22 - LTE, TDCSDMA, CDMA, EVDO, GSM and WCDMA
>     {NR,                              MDM_NR},                                                             // 23 - NR 5G only mode
>     {NR | LTE,                        MDM_NR | MDM_LTE},                                                   // 24 - NR 5G, LTE
>     {NR | LTE | CDMA | EVDO,          MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO},                             // 25 - NR 5G, LTE, CDMA and EvDo
>     {NR | LTE | GSM | WCDMA,          MDM_NR | MDM_LTE | MDM_WCDMA | MDM_GSM},                             // 26 - NR 5G, LTE, GSM and WCDMA
>     {NR | LTE | CDMA | EVDO | GSM | WCDMA, MDM_NR | MDM_LTE | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM},  // 27 - NR 5G, LTE, CDMA, EvDo, GSM and WCDMA
>     {NR | LTE | WCDMA,                MDM_NR | MDM_LTE | MDM_WCDMA},                                       // 28 - NR 5G, LTE and WCDMA
>     {NR | LTE | RAF_TD_SCDMA,         MDM_NR | MDM_LTE | MDM_TDSCDMA},                                     // 29 - NR 5G, LTE and TDSCDMA
>     {NR | LTE | RAF_TD_SCDMA | GSM,   MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_GSM},                           // 30 - NR 5G, LTE, TD-SCDMA and GSM
>     {NR | LTE | RAF_TD_SCDMA | WCDMA, MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA},                         // 31 - NR 5G, LTE, TD-SCDMA, WCDMA
>     {NR | LTE | RAF_TD_SCDMA | GSM | WCDMA, MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_WCDMA | MDM_GSM},         // 32 - NR 5G, LTE, TD-SCDMA, GSM and WCDMA
>     {NR | LTE | RAF_TD_SCDMA | CDMA | EVDO | GSM | WCDMA, MDM_NR | MDM_LTE | MDM_TDSCDMA | MDM_CDMA | MDM_EVDO | MDM_WCDMA | MDM_GSM},  // 33 - NR 5G, LTE, TD-SCDMA, CDMA, EVDO, GSM and WCDMA
190,191c300,301
< static int getCardStatus(RIL_CardStatus_v6 **pp_card_status);
< static void freeCardStatus(RIL_CardStatus_v6 *p_card_status);
---
> static int getCardStatus(RIL_CardStatus_v1_5 **pp_card_status);
> static void freeCardStatus(RIL_CardStatus_v1_5 *p_card_status);
192a303
> bool areUiccApplicationsEnabled = true;
194a306,307
> extern uint8_t hexCharToInt(uint8_t c);
> extern uint8_t * convertHexStringToBytes(void *response, size_t responseLen);
214a328
> static bool isNrDualConnectivityEnabled = true;
221a336
> static uint32_t s_modem_simulator_port = -1;
258a374
> static int s_mncLength = 2;
261a378,418
> // STK
> static bool s_stkServiceRunning = false;
> static char *s_stkUnsolResponse = NULL;
> 
> typedef enum {
>     STK_UNSOL_EVENT_UNKNOWN,
>     STK_UNSOL_EVENT_NOTIFY,
>     STK_UNSOL_PROACTIVE_CMD,
> } StkUnsolEvent;
> 
> typedef enum {
>     STK_RUN_AT        = 0x34,
>     STK_SEND_DTMF     = 0x14,
>     STK_SEND_SMS      = 0x13,
>     STK_SEND_SS       = 0x11,
>     STK_SEND_USSD     = 0x12,
>     STK_PLAY_TONE     = 0x20,
>     STK_OPEN_CHANNEL  = 0x40,
>     STK_CLOSE_CHANNEL = 0x41,
>     STK_RECEIVE_DATA  = 0x42,
>     STK_SEND_DATA     = 0x43,
>     STK_GET_CHANNEL_STATUS = 0x44,
>     STK_REFRESH       = 0x01,
> } StkCmdType;
> 
> enum PDPState {
>     PDP_IDLE,
>     PDP_BUSY,
> };
> 
> struct PDPInfo {
>     int cid;
>     enum PDPState state;
> };
> 
> struct PDPInfo s_PDP[] = {
>      {1, PDP_IDLE},
>      {2, PDP_IDLE},
>      {3, PDP_IDLE},
> };
> 
267a425
> static void getIccId(char *iccid, int size);
270d427
< 
282a440,464
> void convertBytesToHexString(char *bin_ptr, int length, unsigned char *hex_ptr) {
>     int i;
>     unsigned char tmp;
> 
>     if (bin_ptr == NULL || hex_ptr == NULL) {
>         return;
>     }
>     for (i = 0; i < length; i++) {
>         tmp = (unsigned char)((bin_ptr[i] & 0xf0) >> 4);
>         if (tmp <= 9) {
>             *hex_ptr = (unsigned char)(tmp + '0');
>         } else {
>             *hex_ptr = (unsigned char)(tmp + 'A' - 10);
>         }
>         hex_ptr++;
>         tmp = (unsigned char)(bin_ptr[i] & 0x0f);
>         if (tmp <= 9) {
>             *hex_ptr = (unsigned char)(tmp + '0');
>         } else {
>             *hex_ptr = (unsigned char)(tmp + 'A' - 10);
>         }
>         hex_ptr++;
>     }
> }
> 
362a545,580
> #ifdef CUTTLEFISH_ENABLE
> static void set_Ip_Addr(const char *addr, const char* radioInterfaceName) {
>   RLOGD("%s %d setting ip addr %s on interface %s", __func__, __LINE__, addr,
>         radioInterfaceName);
>   struct ifreq request;
>   int status = 0;
>   int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
>   if (sock == -1) {
>     RLOGE("Failed to open interface socket: %s (%d)", strerror(errno), errno);
>     return;
>   }
> 
>   memset(&request, 0, sizeof(request));
>   strncpy(request.ifr_name, radioInterfaceName, sizeof(request.ifr_name));
>   request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
> 
>   char *myaddr = strdup(addr);
>   char *pch = NULL;
>   pch = strchr(myaddr, '/');
>   if (pch) {
>     *pch = '\0';
>   }
> 
>   struct sockaddr_in *sin = (struct sockaddr_in *)&request.ifr_addr;
>   sin->sin_family = AF_INET;
>   sin->sin_addr.s_addr = inet_addr(myaddr);
>   if (ioctl(sock, SIOCSIFADDR, &request) < 0) {
>     RLOGE("%s: failed.", __func__);
>   }
> 
>   close(sock);
>   free(myaddr);
>   RLOGD("%s %d done.", __func__, __LINE__);
> }
> #endif
> 
500c718
< static void requestOrSendDataCallList(RIL_Token *t);
---
> static void requestOrSendDataCallList(int cid, RIL_Token *t);
504c722
<     requestOrSendDataCallList(NULL);
---
>     requestOrSendDataCallList(-1, NULL);
509c727
<     requestOrSendDataCallList(&t);
---
>     requestOrSendDataCallList(-1, &t);
566c784
< static bool hasWifiCapability()
---
> static const char* getRadioInterfaceName()
568,575c786,789
<     char propValue[PROP_VALUE_MAX];
<     return property_get("ro.boot.qemu.wifi", propValue, "") > 0 &&
<            strcmp("1", propValue) == 0;
< }
< 
< static const char* getRadioInterfaceName(bool hasWifi)
< {
<     return hasWifi ? PPP_TTY_PATH_RADIO0 : PPP_TTY_PATH_ETH0;
---
>     if (isInEmulator()) {
>         return EMULATOR_RADIO_INTERFACE;
>     }
>     return PPP_TTY_PATH_ETH0;
578c792
< static void requestOrSendDataCallList(RIL_Token *t)
---
> static void requestOrSendDataCallList(int cid, RIL_Token *t)
580,582c794,796
<     ATResponse *p_response;
<     ATLine *p_cur;
<     int err;
---
>     ATResponse *p_response = NULL;
>     ATLine *p_cur = NULL;
>     int err = -1;
584,587c798,800
<     char *out;
<     char propValue[PROP_VALUE_MAX];
<     bool hasWifi = hasWifiCapability();
<     const char* radioInterfaceName = getRadioInterfaceName(hasWifi);
---
>     char *out = NULL;
>     char propValue[PROP_VALUE_MAX] = {0};
>     const char* radioInterfaceName = getRadioInterfaceName();
656c869
<         int cid;
---
>         int ncid;
662c875
<         err = at_tok_nextint(&line, &cid);
---
>         err = at_tok_nextint(&line, &ncid);
666,672c879
<         for (i = 0; i < n; i++) {
<             if (responses[i].cid == cid)
<                 break;
<         }
< 
<         if (i >= n) {
<             /* details for a context we didn't hear about in the last request */
---
>         if (cid != ncid)
674d880
<         }
675a882
>         i = ncid - 1;
703a911,913
> #ifdef CUTTLEFISH_ENABLE
>         set_Ip_Addr(responses[i].addresses, radioInterfaceName);
> #endif
705,709c915,961
<         /* I don't know where we are, so use the public Google DNS
<             * servers by default and no gateway.
<             */
<         responses[i].dnses = "8.8.8.8 8.8.4.4";
<         responses[i].gateways = "";
---
>         if (isInEmulator()) {
>             /* We are in the emulator - the dns servers are listed
>                 * by the following system properties, setup in
>                 * /system/etc/init.goldfish.sh:
>                 *  - vendor.net.eth0.dns1
>                 *  - vendor.net.eth0.dns2
>                 *  - vendor.net.eth0.dns3
>                 *  - vendor.net.eth0.dns4
>                 */
>             const int   dnslist_sz = 128;
>             char*       dnslist = alloca(dnslist_sz);
>             const char* separator = "";
>             int         nn;
> 
>             dnslist[0] = 0;
>             for (nn = 1; nn <= 4; nn++) {
>                 /* Probe vendor.net.eth0.dns<n> */
>                 char  propName[PROP_NAME_MAX];
>                 char  propValue[PROP_VALUE_MAX];
> 
>                 snprintf(propName, sizeof propName, "vendor.net.eth0.dns%d", nn);
> 
>                 /* Ignore if undefined */
>                 if (property_get(propName, propValue, "") <= 0) {
>                     continue;
>                 }
> 
>                 /* Append the DNS IP address */
>                 strlcat(dnslist, separator, dnslist_sz);
>                 strlcat(dnslist, propValue, dnslist_sz);
>                 separator = " ";
>             }
>             responses[i].dnses = dnslist;
> 
>             if (property_get("vendor.net.eth0.gw", propValue, "") > 0) {
>                 responses[i].gateways = propValue;
>             } else {
>                 responses[i].gateways = "";
>             }
>             responses[i].mtu = DEFAULT_MTU;
>         } else {
>             /* I don't know where we are, so use the public Google DNS
>                 * servers by default and no gateway.
>                 */
>             responses[i].dnses = "8.8.8.8 8.8.4.4";
>             responses[i].gateways = "";
>         }
712a965,1002
>     p_response = NULL;
> 
>     char cmd[64] = {0};
>     snprintf(cmd, sizeof(cmd), "AT+CGCONTRDP=%d", cid);
>     err = at_send_command_singleline(cmd, "+CGCONTRDP:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     int skip = 0;
>     char *sskip = NULL;
>     char *input = p_response->p_intermediates->line;
> 
>     int ncid = -1;
>     err = at_tok_start(&input);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&input, &ncid);  // cid
>     if (err < 0) goto error;
> 
>     if (cid != ncid) goto error;
> 
>     i = ncid - 1;
> 
>     err = at_tok_nextint(&input, &skip);  // bearer_id
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&input, &sskip);  // apn
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&input, &sskip);  // local_addr_and_subnet_mask
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&input, &responses[i].gateways);  // gw_addr
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&input, &responses[i].dnses);  // dns_prim_addr
>     if (err < 0) goto error;
715,716c1005,1006
<         RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses,
<                               n * sizeof(RIL_Data_Call_Response_v11));
---
>         RIL_onRequestComplete(*t, RIL_E_SUCCESS, &responses[i],
>                                sizeof(RIL_Data_Call_Response_v11));
721a1012
>     at_response_free(p_response);
730d1020
< 
993c1283
<     // Accept a response that is at least v6, and up to v10
---
>     // Accept a response that is at least v6, and up to v12
995c1285
<     int maxNumOfElements=sizeof(RIL_SignalStrength_v10)/sizeof(int);
---
>     int maxNumOfElements=sizeof(RIL_SignalStrength_v12)/sizeof(int);
1033a1324,1328
>     const int asize = sizeof(net2modem) / sizeof(net2modem[0]);
>     if (nm >= asize || nm < 0) {
>         RLOGW("%s %d: invalid net2modem index: %d", __func__, __LINE__, nm);
>         return 0;
>     }
1039,1040c1334,1367
< static void requestSetPreferredNetworkType( int request __unused, void *data,
<                                             size_t datalen __unused, RIL_Token t )
---
> 
> int getPreferredFromBitmap(int value, int *index) {
>     for (unsigned int i = 0; i < sizeof(s_networkMask) / sizeof(NetworkTypeBitmap); i++) {
>         if (s_networkMask[i].bitmap == value) {
>             if (index) *index = i;
>             return s_networkMask[i].type;
>         }
>     }
>     // set default value here, since there is no match found
>     // ref.
>     //{LTE | GSM | WCDMA,               MDM_LTE | MDM_GSM | MDM_WCDMA},             // 9 - LTE, GSM/WCDMA
>     //
>     const int DEFAULT_PREFERRED_INDEX = 9;
>     const int DEFAULT_PREFERRED_BITMAP = MDM_LTE | MDM_GSM | MDM_WCDMA;
>     assert(s_networkMask[DEFAULT_PREFERRED_INDEX] == DEFAULT_PREFERRED_BITMAP);
>     if (index) {
>         *index = DEFAULT_PREFERRED_INDEX;
>     }
>     RLOGD("getPreferredFromBitmap %d not match", value);
>     return  DEFAULT_PREFERRED_BITMAP;
> }
> 
> unsigned getBitmapFromPreferred(int value) {
>     for (unsigned int i = 0; i < sizeof(s_networkMask) / sizeof(NetworkTypeBitmap); i++) {
>         if (s_networkMask[i].type == value) {
>             return s_networkMask[i].bitmap;
>         }
>     }
>     RLOGD("getBitmapFromPreferred %d not match", value);
>     return  LTE | GSM | WCDMA;
> }
> 
> static void requestSetPreferredNetworkType(int request, void *data,
>                                            size_t datalen __unused, RIL_Token t )
1044a1372
>     int index = value;
1047c1375
<     int32_t preferred = net2pmask[value];
---
>     int32_t preferred;
1048a1377,1381
>     if (request == RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE) {
>         preferred = net2pmask[value];
>     } else {
>         preferred = getPreferredFromBitmap(value, &index);
>     }
1050c1383,1384
<     if (!networkModePossible(sMdmInfo, value)) {
---
> 
>     if (!networkModePossible(sMdmInfo, index)) {
1053a1388
> 
1100,1101c1435
<                     RIL_onRequestComplete(t, RIL_E_SUCCESS, &i, sizeof(int));
<                     return;
---
>                     goto done;
1106c1440
<             break;
---
>             return;
1108c1442,1447
< 
---
> done:
>     if (request == RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP ||
>             request == RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP) {
>         i = getBitmapFromPreferred(preferred);
>     }
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &i, sizeof(i));
1418c1757
<             err = at_tok_nexthexint(&line, &resp[3]);
---
>             err = at_tok_nextint(&line, &resp[3]);
1439,1440c1778,1822
< #define REG_STATE_LEN 15
< #define REG_DATA_STATE_LEN 6
---
> static int mapNetworkRegistrationResponse(int in_response) {
>     int out_response = 0;
> 
>     switch (in_response) {
>         case 0:
>             out_response = RADIO_TECH_GPRS;    /* GPRS */
>             break;
>         case 3:
>             out_response = RADIO_TECH_EDGE;    /* EDGE */
>             break;
>         case 2:
>             out_response = RADIO_TECH_UMTS;    /* TD */
>             break;
>         case 4:
>             out_response = RADIO_TECH_HSDPA;   /* HSDPA */
>             break;
>         case 5:
>             out_response = RADIO_TECH_HSUPA;   /* HSUPA */
>             break;
>         case 6:
>             out_response = RADIO_TECH_HSPA;    /* HSPA */
>             break;
>         case 15:
>             out_response = RADIO_TECH_HSPAP;   /* HSPA+ */
>             break;
>         case 7:
>             out_response = RADIO_TECH_LTE;     /* LTE */
>             break;
>         case 16:
>             out_response = RADIO_TECH_LTE_CA;  /* LTE_CA */
>             break;
>         case 11:  // NR connected to a 5GCN
>         case 12:  // NG-RAN
>         case 13:  // E-UTRA-NR dual connectivity
>             out_response = RADIO_TECH_NR;      /* NR */
>             break;
>         default:
>             out_response = RADIO_TECH_UNKNOWN; /* UNKNOWN */
>             break;
>     }
>     return out_response;
> }
> 
> #define REG_STATE_LEN 18
> #define REG_DATA_STATE_LEN 14
1463a1846,1849
>         if (TECH_BIT(sMdmInfo) == MDM_LTE) {
>             cmd = "AT+CEREG?";
>             prefix = "+CEREG:";
>         }
1471c1857
<     if (err != 0) goto error;
---
>     if (err < 0 || !p_response->success) goto error;
1510,1511c1896,1898
<         if (count > 3)
<             asprintf(&responseStr[3], "%d", registration[3]);
---
>         if (count > 3) {
>             asprintf(&responseStr[3], "%d", mapNetworkRegistrationResponse(registration[3]));
>         }
1520c1907
<     if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
---
>     if (request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
1522a1910,1924
>         asprintf(&responseStr[11], "%d", s_mcc);
>         asprintf(&responseStr[12], "%d", s_mnc);
>         if (s_mncLength == 2) {
>           asprintf(&responseStr[13], "%03d%02d", s_mcc, s_mnc);
>         } else {
>           asprintf(&responseStr[13], "%03d%03d", s_mcc, s_mnc);
>         }
>     } else {  // Voice
>         asprintf(&responseStr[15], "%d", s_mcc);
>         asprintf(&responseStr[16], "%d", s_mnc);
>         if (s_mncLength == 2) {
>           asprintf(&responseStr[17], "%03d%02d", s_mcc, s_mnc);
>         } else {
>           asprintf(&responseStr[17], "%03d%03d", s_mcc, s_mnc);
>         }
1524a1927
> 
1530d1932
< 
1610c2012,2014
<         if (strlen(response[i]) == 6) {
---
>         int length = strlen(response[i]);
>         if (length == 6) {
>             s_mncLength = 3;
1613a2018,2022
>         } else if (length == 5) {
>             s_mncLength = 2;
>             if (sscanf(response[i], "%3d%2d", &s_mcc, &s_mnc) != 2) {
>                 RLOGE("requestOperator expected mccmnc to be 5 decimal digits");
>             }
1627a2037,2039
>     s_mncLength = 0;
>     s_mcc = 0;
>     s_mnc = 0;
1637a2050,2051
>     memset(&response, 0, sizeof(response));
> 
1660d2073
<     memset(&response, 0, sizeof(response));
1712,1713c2125,2135
<     /* FIXME fill in messageRef and ackPDU */
<     response.messageRef = 1;
---
>     int messageRef = 1;
>     char *line = p_response->p_intermediates->line;
> 
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &messageRef);
>     if (err < 0) goto error;
> 
>     /* FIXME fill in ackPDU */
>     response.messageRef = messageRef;
1775a2198,2256
> /**
>  * Add for CTS test
>  * If open logical channel with AID NULL, this means open logical channel to MF.
>  * If there is P2 value, this P2 value is used for SELECT command.
>  * In addition, if SELECT command returns 61xx, GET RESPONSE command needs to send to get data.
>  */
> static int sendCmdAgainForOpenChannelWithP2( char *data,
>                                         int p2, int *response, int *rspLen) {
>     int len = 0;
>     int err = -1;
>     char *line = NULL;
>     char cmd[64] = {0};
>     RIL_Errno errType = RIL_E_GENERIC_FAILURE;
>     ATResponse *p_response = NULL;
>     RIL_SIM_IO_Response sr;
> 
>     memset(&sr, 0, sizeof(sr));
>     sscanf(data, "%2x", &(response[0]));  // response[0] is channel number
> 
>     // Send SELECT command to MF
>     snprintf(cmd, sizeof(cmd), "AT+CGLA=%d,14,00A400%02X023F00", response[0],
>              p2);
> 
>     err = at_send_command_singleline(cmd, "+CGLA:", &p_response);
>     if (err < 0) goto done;
>     if (p_response->success == 0) {
>         if (!strcmp(p_response->finalResponse, "+CME ERROR: 21") ||
>             !strcmp(p_response->finalResponse, "+CME ERROR: 50")) {
>             errType = RIL_E_GENERIC_FAILURE;
>         }
>         goto done;
>     }
> 
>     line = p_response->p_intermediates->line;
> 
>     if (at_tok_start(&line) < 0 || at_tok_nextint(&line, &len) < 0 ||
>         at_tok_nextstr(&line, &(sr.simResponse)) < 0) {
>         goto done;
>     }
> 
>     sscanf(&(sr.simResponse[len - 4]), "%02x%02x", &(sr.sw1), &(sr.sw2));
> 
>     if (sr.sw1 == 0x90 && sr.sw2 == 0x00) {  // 9000 is successful
>         int length = len / 2;
>         for (*rspLen = 1; *rspLen <= length; (*rspLen)++) {
>             sscanf(sr.simResponse, "%02x", &(response[*rspLen]));
>             sr.simResponse += 2;
>         }
>         errType = RIL_E_SUCCESS;
>     } else {  // close channel
>         snprintf(cmd, sizeof(cmd), "AT+CCHC=%d", response[0]);
>         at_send_command( cmd, NULL);
>     }
> 
> done:
>     at_response_free(p_response);
>     return errType;
> }
> 
1777a2259,2260
>     RIL_UNUSED_PARM(datalen);
> 
1778a2262,2263
>     int response[260] = {0};
>     int responseLen = 1;
1781,1783c2266,2273
<     char cmd[32];
<     char dummy;
<     char *line;
---
>     char cmd[64] = {0};
>     char complex;
>     char *line = NULL;
>     int skip = 0;
>     char *statusWord = NULL;
>     int err_no = RIL_E_GENERIC_FAILURE;
> 
>     RIL_OpenChannelParams *params = (RIL_OpenChannelParams *)data;
1786,1789c2276,2280
<     if (data == NULL || datalen == 0 || datalen > 16) {
<         ALOGE("Invalid data passed to requestSimOpenChannel");
<         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
<         return;
---
>     if (params->aidPtr == NULL) {
>           err = at_send_command_singleline("AT+CSIM=10,\"0070000001\"", "+CSIM:", &p_response);
>     } else {
>         snprintf(cmd, sizeof(cmd), "AT+CCHO=%s", params->aidPtr);
>         err = at_send_command_numeric(cmd, &p_response);
1792,1794d2282
<     snprintf(cmd, sizeof(cmd), "AT+CCHO=%s", (char*) data);
< 
<     err = at_send_command_numeric(cmd, &p_response);
1798,1800c2286
<         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
<         at_response_free(p_response);
<         return;
---
>         goto error;
1805,1807c2291,2318
<     if (sscanf(line, "%" SCNd32 "%c", &session_id, &dummy) != 1) {
<         ALOGE("Invalid AT response, expected integer, was '%s'", line);
<         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
---
>     if (params->aidPtr == NULL) {
> 
>         err = at_tok_start(&line);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextint(&line, &skip);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextstr(&line, &statusWord);
>         if (err < 0) goto error;
> 
>         if (params->p2 < 0) {
>             int length = strlen(statusWord) / 2;
>             for (responseLen = 0; responseLen < length; responseLen++) {
>                 sscanf(statusWord, "%02x", &(response[responseLen]));
>                 statusWord += 2;
>             }
>             err_no = RIL_E_SUCCESS;
>         } else {
>             response[0] = 1;
>             err_no = sendCmdAgainForOpenChannelWithP2(statusWord,
>                                         params->p2, response, &responseLen);
>             if (err_no != RIL_E_SUCCESS) {
>                 goto error;
>             }
>         }
>         RIL_onRequestComplete(t, err_no, response, responseLen * sizeof(int));
>         at_response_free(p_response);
1808a2320,2324
>     } else {
>         if (sscanf(line, "%" SCNd32 "%c", &session_id, &complex) != 1) {
>            ALOGE("Invalid AT response, expected integer, was '%s'", line);
>            goto error;
>         }
1811c2327,2332
<     RIL_onRequestComplete(t, RIL_E_SUCCESS, &session_id, sizeof(&session_id));
---
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &session_id, sizeof(session_id));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, err_no, NULL, 0);
1812a2334
>     return;
1827a2350,2354
>     if (session_id == 0) {
>         RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>         return;
>     }
> 
1849a2377
>     int len = 0;
1851c2379
<     char *line;
---
>     char *line = NULL;
1853c2381
<     RIL_SIM_IO_Response sim_response;
---
>     RIL_SIM_IO_Response sr = {0};
1866c2394
<     err = at_send_command_singleline(cmd, "+CGLA", &p_response);
---
>     err = at_send_command_singleline(cmd, "+CGLA:", &p_response);
1871,1873c2399
<         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
<         at_response_free(p_response);
<         return;
---
>         goto error;
1877c2403,2416
<     err = parseSimResponseLine(line, &sim_response);
---
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &len);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&line, &(sr.simResponse));
>     if (err < 0) goto error;
> 
>     len = strlen(sr.simResponse);
>     if (len < 4) goto error;
> 
>     sscanf(&(sr.simResponse[len - 4]), "%02x%02x", &(sr.sw1), &(sr.sw2));
>     sr.simResponse[len - 4] = '\0';
1879,1881c2418,2489
<     if (err == 0) {
<         RIL_onRequestComplete(t, RIL_E_SUCCESS,
<                               &sim_response, sizeof(sim_response));
---
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestSimAuthentication(int authContext, char* authData, RIL_Token t) {
>     int err = -1, ret = 0;
>     int status = 0;
>     int binSimResponseLen = 0;
>     char *cmd = NULL;
>     char *line = NULL;
>     // Input data
>     int randLen = 0, autnLen = 0;
>     char *rand = NULL, *autn = NULL;
>     // EAP-SIM response data
>     int kcLen = 0, sresLen = 0;
>     char *kc = NULL, *sres = NULL;
>     // EAP-AKA response data
>     int ckLen = 0, ikLen = 0, resAutsLen = 0;
>     char *ck = NULL, *ik = NULL, *resAuts = NULL;
>     unsigned char *binSimResponse = NULL;
>     unsigned char *binAuthData = NULL;
>     unsigned char *hexAuthData = NULL;
>     ATResponse *p_response = NULL;
>     RIL_SIM_IO_Response response;
> 
>     memset(&response, 0, sizeof(response));
>     response.sw1 = 0x90;
>     response.sw2 = 0;
> 
>     binAuthData  =
>             (unsigned char *)malloc(sizeof(*binAuthData) * strlen(authData));
>     if (binAuthData == NULL) {
>         goto error;
>     }
>     if(base64_decode(authData, binAuthData) <= 0) {
>         RLOGE("base64_decode failed %s %d", __func__, __LINE__);
>         goto error;
>     }
>     hexAuthData =
>             (unsigned char *)malloc(strlen(authData) * 2 + sizeof(char));
>     if (hexAuthData == NULL) {
>         goto error;
>     }
>     memset(hexAuthData, 0, strlen(authData) * 2 + sizeof(char));
>     convertBytesToHexString((char *)binAuthData, strlen(authData), hexAuthData);
> 
>     randLen = binAuthData[0];
>     rand = (char *)malloc(sizeof(char) * (randLen * 2 + sizeof(char)));
>     if (rand == NULL) {
>         goto error;
>     }
>     memcpy(rand, hexAuthData + 2, randLen * 2);
>     memcpy(rand + randLen * 2, "\0", 1);
> 
>     if (authContext == AUTH_CONTEXT_EAP_AKA) {
>         // There's the autn value to parse as well.
>         autnLen = binAuthData[1 + randLen];
>         autn = (char*)malloc(sizeof(char) * (autnLen * 2 + sizeof(char)));
>         if (autn == NULL) {
>             goto error;
>         }
>         memcpy(autn, hexAuthData + 2 + randLen * 2 + 2, autnLen * 2);
>         memcpy(autn + autnLen * 2, "\0", 1);
>     }
> 
>     if (authContext == AUTH_CONTEXT_EAP_SIM) {
>         ret = asprintf(&cmd, "AT^MBAU=\"%s\"", rand);
1883,1884c2491,2645
<         ALOGE("Error %d parsing SIM response line: %s", err, line);
<         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
---
>         ret = asprintf(&cmd, "AT^MBAU=\"%s,%s\"", rand, autn);
>     }
>     if (ret < 0) {
>         RLOGE("Failed to asprintf");
>         goto error;
>     }
>     err = at_send_command_singleline( cmd, "^MBAU:", &p_response);
>     free(cmd);
> 
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &status);
>     if (err < 0) goto error;
>     if (status != SIM_AUTH_RESPONSE_SUCCESS) {
>         goto error;
>     }
> 
>     if (authContext == AUTH_CONTEXT_EAP_SIM) {
>         err = at_tok_nextstr(&line, &kc);
>         if (err < 0) goto error;
>         kcLen = strlen(kc);
> 
>         err = at_tok_nextstr(&line, &sres);
>         if (err < 0) goto error;
>         sresLen = strlen(sres);
> 
>         // sresLen + sres + kcLen + kc + '\0'
>         binSimResponseLen = (kcLen + sresLen) / 2 + 3 * sizeof(char);
>         binSimResponse = (unsigned char*)malloc(binSimResponseLen + sizeof(char));
>         if (binSimResponse == NULL) goto error;
>         memset(binSimResponse, 0, binSimResponseLen);
>         // set sresLen and sres
>         binSimResponse[0] = (sresLen / 2) & 0xFF;
>         uint8_t* tmpBinSimResponse = convertHexStringToBytes(sres, sresLen);
>         snprintf((char*)(binSimResponse + 1), sresLen / 2, "%s", tmpBinSimResponse);
>         free(tmpBinSimResponse);
>         tmpBinSimResponse = NULL;
>         // set kcLen and kc
>         binSimResponse[1 + sresLen / 2] = (kcLen / 2) & 0xFF;
>         tmpBinSimResponse = convertHexStringToBytes(kc, kcLen);
>         snprintf((char*)(binSimResponse + 1 + sresLen / 2 + 1), kcLen / 2, "%s", tmpBinSimResponse);
>         free(tmpBinSimResponse);
>         tmpBinSimResponse = NULL;
>     } else {  // AUTH_CONTEXT_EAP_AKA
>         err = at_tok_nextstr(&line, &ck);
>         if (err < 0) goto error;
>         ckLen = strlen(ck);
> 
>         err = at_tok_nextstr(&line, &ik);
>         if (err < 0) goto error;
>         ikLen = strlen(ik);
> 
>         err = at_tok_nextstr(&line, &resAuts);
>         if (err < 0) goto error;
>         resAutsLen = strlen(resAuts);
> 
>         // 0xDB + ckLen + ck + ikLen + ik + resAutsLen + resAuts + '\0'
>         binSimResponseLen = (ckLen + ikLen + resAutsLen) / 2 + 5 * sizeof(char);
>         binSimResponse = (unsigned char*)malloc(binSimResponseLen + sizeof(char));
>         if (binSimResponse == NULL) goto error;
>         memset(binSimResponse, 0, binSimResponseLen);
>         // The DB prefix indicates successful auth. Not produced by the SIM.
>         binSimResponse[0] = 0xDB;
>         // Set ckLen and ck
>         binSimResponse[1] = (ckLen / 2) & 0xFF;
>         uint8_t* tmpBinSimResponse = convertHexStringToBytes(ck, ckLen);
>         snprintf((char*)(binSimResponse + 2), ckLen / 2 + 1, "%s", tmpBinSimResponse);
>         free(tmpBinSimResponse);
>         tmpBinSimResponse = NULL;
>         // Set ikLen and ik
>         binSimResponse[2 + ckLen / 2] = (ikLen / 2) & 0xFF;
>         tmpBinSimResponse = convertHexStringToBytes(ik, ikLen);
>         snprintf((char*)(binSimResponse + 2 + ckLen / 2 + 1), ikLen / 2 + 1, "%s",
>                  tmpBinSimResponse);
>         free(tmpBinSimResponse);
>         tmpBinSimResponse = NULL;
>         // Set resAutsLen and resAuts
>         binSimResponse[2 + ckLen / 2 + 1 + ikLen / 2] = (resAutsLen / 2) & 0xFF;
>         tmpBinSimResponse = convertHexStringToBytes(resAuts, resAutsLen);
>         snprintf((char*)(binSimResponse + 2 + ckLen / 2 + 1 + ikLen / 2 + 1), resAutsLen / 2 + 1,
>                  "%s", tmpBinSimResponse);
>         free(tmpBinSimResponse);
>         tmpBinSimResponse = NULL;
>     }
> 
>     response.simResponse = (char*)malloc(2 * binSimResponseLen + sizeof(char));
>     if (response.simResponse == NULL) goto error;
>     if (NULL == base64_encode(binSimResponse, response.simResponse, binSimResponseLen - 1)) {
>         RLOGE("Failed to call base64_encode %s %d", __func__, __LINE__);
>         goto error;
>     }
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(response));
>     at_response_free(p_response);
> 
>     free(binAuthData);
>     free(hexAuthData);
>     free(rand);
>     free(autn);
>     free(response.simResponse);
>     free(binSimResponse);
>     return;
> 
> error:
>     free(binAuthData);
>     free(hexAuthData);
>     free(rand);
>     free(autn);
>     free(response.simResponse);
>     free(binSimResponse);
> 
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestTransmitApduBasic( void *data, size_t datalen,
>                                       RIL_Token t) {
>     RIL_UNUSED_PARM(datalen);
> 
>     int err, len;
>     int instruction = 0;
>     char *cmd = NULL;
>     char *line = NULL;
>     RIL_SIM_APDU *p_args = NULL;
>     ATResponse *p_response = NULL;
>     RIL_SIM_IO_Response sr;
> 
>     memset(&sr, 0, sizeof(sr));
> 
>     p_args = (RIL_SIM_APDU *)data;
> 
>     if ((p_args->data == NULL) || (strlen(p_args->data) == 0)) {
>         if (p_args->p3 < 0) {
>             asprintf(&cmd, "AT+CSIM=%d,\"%02x%02x%02x%02x\"", 8, p_args->cla,
>                     p_args->instruction, p_args->p1, p_args->p2);
>         } else {
>             asprintf(&cmd, "AT+CSIM=%d,\"%02x%02x%02x%02x%02x\"", 10,
>                     p_args->cla, p_args->instruction, p_args->p1, p_args->p2,
>                     p_args->p3);
>         }
>     } else {
>         asprintf(&cmd, "AT+CSIM=%d,\"%02x%02x%02x%02x%02x%s\"",
>                 10 + (int)strlen(p_args->data), p_args->cla,
>                 p_args->instruction, p_args->p1, p_args->p2, p_args->p3,
>                 p_args->data);
>     }
>     err = at_send_command_singleline(cmd, "+CSIM:", &p_response);
>     free(cmd);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
1885a2647,2667
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &len);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&line, &(sr.simResponse));
>     if (err < 0) goto error;
> 
>     sscanf(&(sr.simResponse[len - 4]), "%02x%02x", &(sr.sw1), &(sr.sw2));
>     sr.simResponse[len - 4] = '\0';
> 
>     instruction = p_args->instruction;
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
1888a2671,2691
> static int getPDP() {
>     int ret = -1;
> 
>     for (int i = 0; i < MAX_PDP; i++) {
>         if (s_PDP[i].state == PDP_IDLE) {
>             s_PDP[i].state = PDP_BUSY;
>             ret = s_PDP[i].cid;
>             break;
>         }
>     }
>     return ret;
> }
> 
> static void putPDP(int cid) {
>     if (cid < 1 || cid > MAX_PDP ) {
>         return;
>     }
> 
>     s_PDP[cid - 1].state = PDP_IDLE;
> }
> 
1891,1893c2694,2697
<     const char *apn;
<     char *cmd;
<     int err;
---
>     const char *apn = NULL;
>     char *cmd = NULL;
>     int err = -1;
>     int cid = -1;
1969,1970c2773
<         bool hasWifi = hasWifiCapability();
<         const char* radioInterfaceName = getRadioInterfaceName(hasWifi);
---
>         const char* radioInterfaceName = getRadioInterfaceName();
1981c2784,2787
<         asprintf(&cmd, "AT+CGDCONT=1,\"%s\",\"%s\",,0,0", pdp_type, apn);
---
>         cid = getPDP();
>         if (cid < 1 ) goto error;
> 
>         asprintf(&cmd, "AT+CGDCONT=%d,\"%s\",\"%s\",,0,0", cid, pdp_type, apn);
2006c2812
<     requestOrSendDataCallList(&t);
---
>     requestOrSendDataCallList(cid, &t);
2014d2819
< 
2017c2822
< static void requestDeactivateDataCall(RIL_Token t)
---
> static void requestDeactivateDataCall(void *data, RIL_Token t)
2019,2021c2824,2833
<     bool hasWifi = hasWifiCapability();
<     const char* radioInterfaceName = getRadioInterfaceName(hasWifi);
<     RIL_Errno rilErrno = setInterfaceState(radioInterfaceName, kInterfaceDown);
---
>     const char *p_cid = ((const char **)data)[0];
>     int cid = p_cid ? atoi(p_cid) : -1;
>     RIL_Errno rilErrno = RIL_E_GENERIC_FAILURE;
>     if (cid < 1  || cid > MAX_PDP) {
>         RIL_onRequestComplete(t, rilErrno, NULL, 0);
>         return;
>     }
> 
>     const char* radioInterfaceName = getRadioInterfaceName();
>     rilErrno = setInterfaceState(radioInterfaceName, kInterfaceDown);
2022a2835
>     putPDP(cid);
2048a2862,2866
> }
> 
> void convertBytesToHex(uint8_t *bytes, int length, uint8_t *hex_str) {
>     int i;
>     unsigned char tmp;
2049a2868,2961
>     if (bytes == NULL || hex_str == NULL) {
>         return;
>     }
>     for (i = 0; i < length; i++) {
>         tmp = (unsigned char)((bytes[i] & 0xf0) >> 4);
>         if (tmp <= 9) {
>             *hex_str = (unsigned char)(tmp + '0');
>         } else {
>             *hex_str = (unsigned char)(tmp + 'A' - 10);
>         }
>         hex_str++;
>         tmp = (unsigned char)(bytes[i] & 0x0f);
>         if (tmp <= 9) {
>             *hex_str = (unsigned char)(tmp + '0');
>         } else {
>             *hex_str = (unsigned char)(tmp + 'A' - 10);
>         }
>         hex_str++;
>     }
> }
> 
> #define TYPE_EF                                 4
> #define RESPONSE_EF_SIZE                        15
> #define TYPE_FILE_DES_LEN                       5
> #define RESPONSE_DATA_FILE_DES_FLAG             2
> #define RESPONSE_DATA_FILE_DES_LEN_FLAG         3
> #define RESPONSE_DATA_FILE_TYPE                 6
> #define RESPONSE_DATA_FILE_SIZE_1               2
> #define RESPONSE_DATA_FILE_SIZE_2               3
> #define RESPONSE_DATA_STRUCTURE                 13
> #define RESPONSE_DATA_RECORD_LENGTH             14
> #define RESPONSE_DATA_FILE_RECORD_LEN_1         6
> #define RESPONSE_DATA_FILE_RECORD_LEN_2         7
> #define EF_TYPE_TRANSPARENT                     0x01
> #define EF_TYPE_LINEAR_FIXED                    0x02
> #define EF_TYPE_CYCLIC                          0x06
> #define USIM_DATA_OFFSET_2                      2
> #define USIM_DATA_OFFSET_3                      3
> #define USIM_FILE_DES_TAG                       0x82
> #define USIM_FILE_SIZE_TAG                      0x80
> 
> bool convertUsimToSim(uint8_t *byteUSIM, int len, uint8_t *hexSIM) {
>     int desIndex = 0;
>     int sizeIndex = 0;
>     int i = 0;
>     uint8_t byteSIM[RESPONSE_EF_SIZE] = {0};
>     for (i = 0; i < len; i++) {
>         if (byteUSIM[i] == USIM_FILE_DES_TAG) {
>             desIndex = i;
>             break;
>         }
>     }
>     for (i = desIndex; i < len;) {
>         if (byteUSIM[i] == USIM_FILE_SIZE_TAG) {
>             sizeIndex = i;
>             break;
>         } else {
>             i += (byteUSIM[i + 1] + 2);
>         }
>     }
>     byteSIM[RESPONSE_DATA_FILE_SIZE_1] =
>             byteUSIM[sizeIndex + USIM_DATA_OFFSET_2];
>     byteSIM[RESPONSE_DATA_FILE_SIZE_2] =
>             byteUSIM[sizeIndex + USIM_DATA_OFFSET_3];
>     byteSIM[RESPONSE_DATA_FILE_TYPE] = TYPE_EF;
>     if ((byteUSIM[desIndex + RESPONSE_DATA_FILE_DES_FLAG] & 0x07) ==
>         EF_TYPE_TRANSPARENT) {
>         byteSIM[RESPONSE_DATA_STRUCTURE] = 0;
>     } else if ((byteUSIM[desIndex + RESPONSE_DATA_FILE_DES_FLAG] & 0x07) ==
>                 EF_TYPE_LINEAR_FIXED) {
>         if (USIM_FILE_DES_TAG != byteUSIM[RESPONSE_DATA_FILE_DES_FLAG]) {
>             RLOGE("USIM_FILE_DES_TAG != ...");
>             goto error;
>         }
>         if (TYPE_FILE_DES_LEN != byteUSIM[RESPONSE_DATA_FILE_DES_LEN_FLAG]) {
>             goto error;
>         }
>         byteSIM[RESPONSE_DATA_STRUCTURE] = 1;
>         byteSIM[RESPONSE_DATA_RECORD_LENGTH] =
>                 ((byteUSIM[RESPONSE_DATA_FILE_RECORD_LEN_1] & 0xff) << 8) +
>                 (byteUSIM[RESPONSE_DATA_FILE_RECORD_LEN_2] & 0xff);
>     } else if ((byteUSIM[desIndex + RESPONSE_DATA_FILE_DES_FLAG] & 0x07) ==
>                 EF_TYPE_CYCLIC) {
>         byteSIM[RESPONSE_DATA_STRUCTURE] = 3;
>         byteSIM[RESPONSE_DATA_RECORD_LENGTH] =
>                 ((byteUSIM[RESPONSE_DATA_FILE_RECORD_LEN_1] & 0xff) << 8) +
>                 (byteUSIM[RESPONSE_DATA_FILE_RECORD_LEN_2] & 0xff);
>     }
> 
>     convertBytesToHex(byteSIM, RESPONSE_EF_SIZE, hexSIM);
>     return true;
> 
> error:
>     return false;
2060a2973,2975
>     /* For Convert USIM to SIM */
>     uint8_t hexSIM[RESPONSE_EF_SIZE * 2 + sizeof(char)] = {0};
> 
2088a3004,3020
>     if (sr.simResponse != NULL &&  // Default to be USIM card
>         p_args->command == 192) {  // Get response
>         uint8_t *bytes = convertHexStringToBytes(sr.simResponse, strlen(sr.simResponse));
>         if (bytes == NULL) {
>             RLOGE("Failed to convert sim response to bytes");
>             goto error;
>         }
>         if (bytes[0] != 0x62) {
>             RLOGE("Wrong FCP flag, unable to convert to sim ");
>             free(bytes);
>             goto error;
>         }
>         if (convertUsimToSim(bytes, strlen(sr.simResponse) / 2, hexSIM)) {
>           sr.simResponse = (char *)hexSIM;
>         }
>         free(bytes);
>     }
2093d3024
< 
2094a3026
> 
2098a3031,3049
> }
> 
> static int getSimlockRemainTimes(const char* type) {
>     int err = -1;
>     int remain_times = -1;
>     char cmd[32] = {0};
>     char *line = NULL;
>     char *lock_type = NULL;
>     ATResponse *p_response = NULL;
> 
>     snprintf(cmd, sizeof(cmd), "AT+CPINR=\"%s\"", type);
>     err = at_send_command_multiline(cmd, "+CPINR:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
2099a3051,3059
>     err = at_tok_nextstr(&line, &lock_type);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &remain_times);
>     if (err < 0) goto error;
> 
> error:
>     at_response_free(p_response);
>     return remain_times;
2102c3062
< static void  requestEnterSimPin(void*  data, size_t  datalen, RIL_Token  t)
---
> static void  requestEnterSimPin(int request, void*  data, size_t  datalen, RIL_Token  t)
2105a3066
>     int           remaintimes = -1;
2109c3070
<     if ( datalen == sizeof(char*) ) {
---
>     if (datalen == sizeof(char*) || datalen == 2 * sizeof(char*)) {
2111c3072,3101
<     } else if ( datalen == 2*sizeof(char*) ) {
---
>     } else
>         goto error;
> 
>     err = at_send_command_singleline(cmd, "+CPIN:", &p_response);
>     free(cmd);
> 
>     if (err < 0 || p_response->success == 0) {
> error:
>         if (request == RIL_REQUEST_ENTER_SIM_PIN) {
>             remaintimes = getSimlockRemainTimes("SIM PIN");
>         } else if (request == RIL_REQUEST_ENTER_SIM_PIN2) {
>             remaintimes = getSimlockRemainTimes("SIM PIN2");
>         }
>         RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &remaintimes,
>             sizeof(remaintimes));
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void  requestChangeSimPin(int request, void*  data, size_t  datalen, RIL_Token  t)
> {
>     ATResponse   *p_response = NULL;
>     int           err;
>     int           remaintimes = -1;
>     char*         cmd = NULL;
>     const char**  strings = (const char**)data;;
> 
>     if (datalen == 2 * sizeof(char*) || datalen == 3 * sizeof(char*)) {
2121c3111,3119
<         RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, NULL, 0);
---
>         if (request == RIL_REQUEST_CHANGE_SIM_PIN) {
>             remaintimes = getSimlockRemainTimes("SIM PIN");
>         } else if (request == RIL_REQUEST_ENTER_SIM_PUK) {
>             remaintimes = getSimlockRemainTimes("SIM PUK");
>         } else if (request == RIL_REQUEST_ENTER_SIM_PUK2) {
>           remaintimes = getSimlockRemainTimes("SIM PUK2");
>         }
>         RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &remaintimes,
>             sizeof(remaintimes));
2127a3126,3131
> static void requestChangeSimPin2(void *data, size_t datalen, RIL_Token t) {
>     int err, ret;
>     int remaintime = -1;
>     char cmd[64] = {0};
>     const char **strings = (const char **)data;
>     ATResponse *p_response = NULL;
2129,2131c3133,3143
< static void  requestSendUSSD(void *data, size_t datalen __unused, RIL_Token t)
< {
<     const char *ussdRequest;
---
>     if (datalen != 3 * sizeof(char *)) {
>         goto error;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CPWD=\"P2\",\"%s\",\"%s\"", strings[0],
>              strings[1]);
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         remaintime = getSimlockRemainTimes("SIM PIN2");
>         goto error;
>     }
2133c3145,3147
<     ussdRequest = (char *)(data);
---
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     at_response_free(p_response);
>     return;
2134a3149,3153
> error:
>     RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &remaintime,
>                           sizeof(remaintime));
>     at_response_free(p_response);
> }
2136c3155,3157
<     RIL_onRequestComplete(t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
---
> static void  requestSendUSSD(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(datalen);
2138c3159,3162
< // @@@ TODO
---
>     int err = -1;
>     char cmd[128] = {0};
>     const char *ussdRequest = (char *)(data);
>     ATResponse *p_response = NULL;
2139a3164,3171
>     snprintf(cmd, sizeof(cmd), "AT+CUSD=1,\"%s\"", ussdRequest);
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
2156a3189,3205
> static uint64_t s_last_activity_info_query = 0;
> 
> static void requestGetActivityInfo(void *data __unused, size_t datalen __unused, RIL_Token t)
> {
>     uint64_t curTime = ril_nano_time();
>     RIL_ActivityStatsInfo stats =
>     {
>         0, // sleep_mode_time_ms
>         ((curTime - s_last_activity_info_query) / 1000000) - 1, // idle_mode_time_ms
>         {0, 0, 0, 0, 0}, // tx_mode_time_ms
>         0 // rx_mode_time_ms
>     };
>     s_last_activity_info_query = curTime;
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &stats, sizeof(stats));
> }
> 
2161c3210
<     switch (1 << mdmtype) {
---
>     switch (mdmtype) {
2175a3225,3226
>         case MDM_NR:
>             ret = RADIO_TECH_NR;
2199c3250
<                         0xFF, // bsic unknown
---
>                         0x1, // Base Station Identity Code set to arbitrarily 1
2262,2263c3313,3314
<    radioCapability.rat     = 0;
<    radioCapability.logicalModemUuid[0] = '\0';
---
>    radioCapability.rat     = NR | LTE | WCDMA | GSM;
>    strncpy(radioCapability.logicalModemUuid, "com.android.modem.simulator", MAX_UUID_LENGTH);
2268a3320,3331
> static void requestSetRadioCapability(void *data, size_t datalen, RIL_Token t)
> {
>   RIL_RadioCapability* rc = (RIL_RadioCapability*)data;
>   RLOGV(
>       "RadioCapability version %d session %d phase %d rat %d "
>       "logicalModemUuid %s status %d",
>       rc->version, rc->session, rc->phase, rc->rat, rc->logicalModemUuid,
>       rc->status);
>   // TODO(ender): do something about these numbers.
>   RIL_onRequestComplete(t, RIL_E_SUCCESS, rc, datalen);
> }
> 
2271c3334,3335
<    int  muteResponse;
---
>     RIL_UNUSED_PARM(data);
>     RIL_UNUSED_PARM(datalen);
2273,2274c3337,4076
<    RIL_UNUSED_PARM(data);
<    RIL_UNUSED_PARM(datalen);
---
>     int err = -1;
>     int muteResponse = 0;  // Mute disabled
>     char *line = NULL;
>     ATResponse *p_response = NULL;
> 
>     err = at_send_command_singleline("AT+CMUT?", "+CMUT:", &p_response);
>     if (err < 0 || p_response->success) {
>         goto done;
>     }
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto done;
> 
>     at_tok_nextint(&line, &muteResponse);
> 
> done:
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &muteResponse, sizeof(muteResponse));
>     at_response_free(p_response);
> }
> 
> static void requestSetMute(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(datalen);
> 
>     int err = -1;
>     char cmd[64] = {0};
>     ATResponse *p_response = NULL;
> 
>     snprintf(cmd, sizeof(cmd), "AT+CMUT=%d", ((int *)data)[0]);
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success) {
>       RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>       RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestScreenState(void *data, RIL_Token t)
> {
>     int status = *((int *)data);
> 
>     if (!status) {
>         /* Suspend */
>         at_send_command("AT+CEREG=1", NULL);
>         at_send_command("AT+CREG=1", NULL);
>         at_send_command("AT+CGREG=1", NULL);
>     } else {
>        /* Resume */
>         at_send_command("AT+CEREG=2", NULL);
>         at_send_command("AT+CREG=2", NULL);
>         at_send_command("AT+CGREG=2", NULL);
>     }
> 
>    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
> }
> 
> static void requestQueryClip(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(datalen);
>     RIL_UNUSED_PARM(data);
> 
>     int err = -1;
>     int skip = 0;
>     int response = 0;
>     char *line = NULL;
>     ATResponse *p_response = NULL;
> 
>     if (getSIMStatus() == SIM_ABSENT) {
>         RIL_onRequestComplete(t, RIL_E_MODEM_ERR, NULL, 0);
>         return;
>     }
> 
>     err = at_send_command_singleline("AT+CLIP?", "+CLIP:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &skip);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &response);
>     if (err < 0) goto error;
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(response));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestQueryClir(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(datalen);
>     RIL_UNUSED_PARM(data);
> 
>     int err = -1;
>     int response[2] = {1, 1};
>     char *line = NULL;
>     ATResponse *p_response = NULL;
> 
>     if (getSIMStatus() == SIM_ABSENT) {
>         RIL_onRequestComplete(t, RIL_E_MODEM_ERR, NULL, 0);
>         return;
>     }
> 
>     err = at_send_command_singleline("AT+CLIR?", "+CLIR:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &response[0]);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &response[1]);
>     if (err < 0) goto error;
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestSetClir(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(datalen);
> 
>     int err = -1;
>     int n = ((int *)data)[0];
>     char cmd[64] = {0};
>     ATResponse *p_response = NULL;
> 
>     snprintf(cmd, sizeof(cmd), "AT+CLIR=%d", n);
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static int forwardFromCCFCULine(char *line, RIL_CallForwardInfo *p_forward) {
>     int err = -1;
>     int i = 0;
> 
>     if (line == NULL || p_forward == NULL) {
>       goto error;
>     }
> 
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &(p_forward->status));
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &(p_forward->serviceClass));
>     if (err < 0) goto error;
> 
>     if (at_tok_hasmore(&line)) {
>         int numberType = 0;
>         err = at_tok_nextint(&line, &numberType);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextint(&line, &p_forward->toa);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextstr(&line, &(p_forward->number));
> 
>         /* tolerate null here */
>         if (err < 0) return 0;
> 
>         if (at_tok_hasmore(&line)) {
>             for (i = 0; i < 2; i++) {
>                 skipNextComma(&line);
>             }
> 
>             if (at_tok_hasmore(&line)) {
>                 err = at_tok_nextint(&line, &p_forward->timeSeconds);
>                 if (err < 0) {
>                     p_forward->timeSeconds = 0;
>                 }
>             }
>         }
>     }
> 
>     return 0;
> 
> error:
>     return -1;
> }
> 
> static void requestSetCallForward(RIL_CallForwardInfo *data,
>                                   size_t datalen, RIL_Token t) {
>     int err = -1;
>     char cmd[128] = {0};
>     size_t offset = 0;
>     ATResponse *p_response = NULL;
> 
>     if (datalen != sizeof(*data) ||
>             (data->status == 3 && data->number == NULL)) {
>         goto error;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CCFCU=%d,%d,%d,%d,\"%s\",%d",
>                             data->reason,
>                             data->status,
>                             2,
>                             data->toa,
>                             data->number ? data->number : "",
>                             data->serviceClass);
>     offset += strlen(cmd);
> 
>     if (data->serviceClass == 0) {
>         if (data->timeSeconds != 0 && data->status == 3) {
>             snprintf(cmd + offset, sizeof(cmd) - offset, ",\"\",\"\",,%d",
>                 data->timeSeconds);
>         }
>     } else {
>         if (data->timeSeconds != 0 && data->status == 3) {
>             snprintf(cmd + offset, sizeof(cmd) - offset, ",\"\",\"\",,%d",
>                 data->timeSeconds);
>         } else {
>             strlcat(cmd, ",\"\"", sizeof(cmd) - offset);
>         }
>     }
> 
>     err = at_send_command_multiline(cmd, "+CCFCU:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestQueryCallForward(RIL_CallForwardInfo *data,
>                                     size_t datalen, RIL_Token t) {
>     int err = -1;
>     char cmd[128] = {0};
>     ATResponse *p_response = NULL;
>     ATLine *p_cur = NULL;
> 
>     if (datalen != sizeof(*data)) {
>         goto error;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CCFCU=%d,2,%d,%d,\"%s\",%d", data->reason, 2,
>             data->toa, data->number ? data->number : "", data->serviceClass);
> 
>     err = at_send_command_multiline(cmd, "+CCFCU:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     RIL_CallForwardInfo **forwardList = NULL, *forwardPool = NULL;
>     int forwardCount = 0;
>     int validCount = 0;
>     int i = 0;
> 
>     for (p_cur = p_response->p_intermediates; p_cur != NULL;
>          p_cur = p_cur->p_next, forwardCount++) {
>     }
> 
>     forwardList = (RIL_CallForwardInfo **)
>         alloca(forwardCount * sizeof(RIL_CallForwardInfo *));
> 
>     forwardPool = (RIL_CallForwardInfo *)
>         alloca(forwardCount * sizeof(RIL_CallForwardInfo));
> 
>     memset(forwardPool, 0, forwardCount * sizeof(RIL_CallForwardInfo));
> 
>     /* init the pointer array */
>     for (i = 0; i < forwardCount; i++) {
>         forwardList[i] = &(forwardPool[i]);
>     }
> 
>     for (p_cur = p_response->p_intermediates; p_cur != NULL;
>          p_cur = p_cur->p_next) {
>         err = forwardFromCCFCULine(p_cur->line, forwardList[validCount]);
>         forwardList[validCount]->reason = data->reason;
>         if (err == 0) validCount++;
>     }
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, validCount ? forwardList : NULL,
>                           validCount * sizeof (RIL_CallForwardInfo *));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestQueryCallWaiting(void *data, size_t datalen, RIL_Token t) {
>     RIL_UNUSED_PARM(datalen);
> 
>     int err = -1, mode = 0;
>     int serviceClass = ((int *)data)[0];
>     int response[2] = {0, 0};
>     char cmd[32] = {0};
>     char *line;
>     ATLine *p_cur;
>     ATResponse *p_response = NULL;
> 
>     if (serviceClass == 0) {
>         snprintf(cmd, sizeof(cmd), "AT+CCWA=1,2");
>     } else {
>         snprintf(cmd, sizeof(cmd), "AT+CCWA=1,2,%d", serviceClass);
>     }
>     err = at_send_command_multiline(cmd, "+CCWA:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     for (p_cur = p_response->p_intermediates; p_cur != NULL;
>          p_cur = p_cur->p_next) {
>         line = p_cur->line;
>         err = at_tok_start(&line);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextint(&line, &mode);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextint(&line, &serviceClass);
>         if (err < 0) goto error;
> 
>         response[0] = mode;
>         response[1] |= serviceClass;
>     }
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestSetCallWaiting(void *data, size_t datalen, RIL_Token t) {
>     RIL_UNUSED_PARM(datalen);
> 
>     ATResponse *p_response = NULL;
>     int err = -1;
>     char cmd[32] = {0};
>     int enable = ((int *)data)[0];
>     int serviceClass = ((int *)data)[1];
> 
>     if (serviceClass == 0) {
>         snprintf(cmd, sizeof(cmd), "AT+CCWA=1,%d", enable);
>     } else {
>         snprintf(cmd, sizeof(cmd), "AT+CCWA=1,%d,%d", enable, serviceClass);
>     }
> 
>     err = at_send_command(cmd,  &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestSetSuppServiceNotifications(void *data, size_t datalen,
>                                                RIL_Token t) {
>     RIL_UNUSED_PARM(datalen);
> 
>     int err = 0;
>     ATResponse *p_response = NULL;
>     int mode = ((int *)data)[0];
>     char cmd[32] = {0};
> 
>     snprintf(cmd, sizeof(cmd), "AT+CSSN=%d,%d", mode, mode);
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestChangeBarringPassword(char **data, size_t datalen, RIL_Token t) {
>     int err = -1;
>     int result;
>     char cmd[64] = {0};
>     ATResponse *p_response = NULL;
> 
>     if (datalen != 3 * sizeof(char *) || data[0] == NULL || data[1] == NULL ||
>         data[2] == NULL || strlen(data[0]) == 0 ||  strlen(data[1]) == 0 ||
>         strlen(data[2]) == 0) {
>         RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>         return;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CPWD=\"%s\",\"%s\",\"%s\"", data[0], data[1],
>              data[2]);
> 
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void requestFacilityLock(int request, char **data,
>                                 size_t datalen, RIL_Token t) {
>     int err = -1;
>     int status = 0;
>     int serviceClass = 0;
>     int remainTimes = 10;
>     char cmd[128] = {0};
>     char *line = NULL;
>     ATLine *p_cur = NULL;
>     ATResponse *p_response = NULL;
>     RIL_Errno errnoType = RIL_E_GENERIC_FAILURE;
> 
>     char *type = data[0];
> 
>     if (datalen != 5 * sizeof(char *)) {
>         goto error;
>     }
>     if (data[0] == NULL || data[1] == NULL ||
>        (data[2] == NULL && request == RIL_REQUEST_SET_FACILITY_LOCK) ||
>         strlen(data[0]) == 0 || strlen(data[1]) == 0 ||
>        (request == RIL_REQUEST_SET_FACILITY_LOCK && strlen(data[2]) == 0 )) {
>         errnoType = RIL_E_INVALID_ARGUMENTS;
>         RLOGE("FacilityLock invalid arguments");
>         goto error;
>     }
> 
>     serviceClass = atoi(data[3]);
>     if (serviceClass == 0) {
>         snprintf(cmd, sizeof(cmd), "AT+CLCK=\"%s\",%c,\"%s\"", data[0], *data[1],
>                  data[2]);
>     } else {
>         snprintf(cmd, sizeof(cmd), "AT+CLCK=\"%s\",%c,\"%s\",%s", data[0],
>                  *data[1], data[2], data[3]);
>     }
> 
>     if (*data[1] == '2') {  // query status
>         err = at_send_command_multiline(cmd, "+CLCK: ", &p_response);
>         if (err < 0 || p_response->success == 0) {
>             goto error;
>         }
>         line = p_response->p_intermediates->line;
> 
>         err = at_tok_start(&line);
>         if (err < 0) goto error;
> 
>         err = at_tok_nextint(&line, &status);
>         if (err < 0) goto error;
> 
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, &status, sizeof(int));
>         at_response_free(p_response);
>         return;
>     } else {  // unlock/lock this facility
>         err = at_send_command(cmd, &p_response);
>         if (err < 0 || p_response->success == 0) {
>             errnoType = RIL_E_PASSWORD_INCORRECT;
>             goto error;
>         }
>         errnoType = RIL_E_SUCCESS;
>     }
> 
> error:
>     if (!strcmp(data[0], "SC")) {
>         remainTimes = getSimlockRemainTimes("SIM PIN");
>     } else if (!strcmp(data[0], "FD")) {
>         remainTimes = getSimlockRemainTimes("SIM PIN2");
>     } else {
>         remainTimes = 1;
>     }
> 
>     RIL_onRequestComplete(t, errnoType, &remainTimes, sizeof(remainTimes));
>     at_response_free(p_response);
> }
> 
> static void requestSetSmscAddress(void *data, size_t datalen, RIL_Token t)
> {
>     ATResponse   *p_response = NULL;
>     char          cmd[64] = {0};
>     int           err = -1;
> 
>     if (getSIMStatus() != SIM_READY) {
>          RIL_onRequestComplete(t, RIL_E_SIM_ABSENT, NULL, 0);
>          return;
>     }
> 
>     if (data == NULL || strlen(data) == 0) {
>         RLOGE("SET_SMSC_ADDRESS invalid address: %s", (char *)data);
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>         return;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CSCA=%s,%d", (char *)data, (int)datalen);
> 
>     err = at_send_command_singleline(cmd, "+CSCA:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestGetSmscAddress(void *data, size_t datalen, RIL_Token t)
> {
>     RIL_UNUSED_PARM(data);
>     RIL_UNUSED_PARM(datalen);
> 
>     ATResponse   *p_response = NULL;
>     int           err = -1;
>     char         *decidata = NULL;
> 
>     err = at_send_command_singleline( "AT+CSCA?", "+CSCA:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>        goto error;
>     }
> 
>     char *line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&line, &decidata);
>     if (err < 0) goto error;
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, decidata, strlen(decidata) + 1);
>     at_response_free(p_response);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     at_response_free(p_response);
> }
> 
> static void setGsmBroadcastConfigData(int from, int to, int id, int outStrSize, char *outStr) {
>     if (from < 0 || from > 0xffff || to < 0 || to > 0xffff) {
>         RLOGE("setGsmBroadcastConfig data is invalid, [%d, %d]", from, to);
>         return;
>     }
> 
>     if (id != 0) {
>         strlcat(outStr, ",", outStrSize);
>     }
> 
>     int len = strlen(outStr);
>     if (from == to) {
>         snprintf(outStr + len, outStrSize - len, "%d", from);
>     } else {
>         snprintf(outStr + len, outStrSize - len, "%d-%d", from, to);
>     }
> }
> 
> static void requestSetSmsBroadcastConfig(void *data, size_t datalen,
>                                          RIL_Token t) {
>     int i = 0;
>     int count = datalen / sizeof(RIL_GSM_BroadcastSmsConfigInfo *);
>     int size = count * 16;
>     char cmd[256] = {0};
>     char *channel = (char *)alloca(size);
>     char *languageId = (char *)alloca(size);
>     ATResponse *p_response = NULL;
>     RIL_GSM_BroadcastSmsConfigInfo **pGsmBci =
>             (RIL_GSM_BroadcastSmsConfigInfo **)data;
>     RIL_GSM_BroadcastSmsConfigInfo gsmBci = {0};
> 
>     memset(channel, 0, size);
>     memset(languageId, 0, size);
>     RLOGD("requestSetGsmBroadcastConfig %zu, count %d", datalen, count);
> 
>     for (i = 0; i < count; i++) {
>         gsmBci = *(pGsmBci[i]);
>         setGsmBroadcastConfigData(gsmBci.fromServiceId, gsmBci.toServiceId, i,
>                                   size, channel);
>         setGsmBroadcastConfigData(gsmBci.fromCodeScheme, gsmBci.toCodeScheme, i,
>                                   size, languageId);
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CSCB=%d,\"%s\",\"%s\"",
>             (*pGsmBci[0]).selected ? 0 : 1, channel, languageId);
>     int err = at_send_command_singleline( cmd, "+CSCB:", &p_response);
> 
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestGetSmsBroadcastConfig(void *data, size_t datalen,
>                                          RIL_Token t) {
>     RIL_UNUSED_PARM(data);
>     RIL_UNUSED_PARM(datalen);
> 
>     ATResponse *p_response = NULL;
>     int err = -1, mode, commas = 0, i = 0;
>     char *line = NULL;
>     char *serviceIds = NULL, *codeSchemes = NULL, *p = NULL;
>     char *serviceId = NULL, *codeScheme = NULL;
> 
>     err = at_send_command_singleline("AT+CSCB?", "+CSCB:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     line = p_response->p_intermediates->line;
>     err = at_tok_start(&line);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextint(&line, &mode);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&line, &serviceIds);
>     if (err < 0) goto error;
> 
>     err = at_tok_nextstr(&line, &codeSchemes);
>     if (err < 0) goto error;
> 
>     for (p = serviceIds; *p != '\0'; p++) {
>         if (*p == ',') {
>             commas++;
>         }
>     }
>     RIL_GSM_BroadcastSmsConfigInfo **pGsmBci =
>         (RIL_GSM_BroadcastSmsConfigInfo **)alloca((commas + 1) *
>             sizeof(RIL_GSM_BroadcastSmsConfigInfo *));
>     memset(pGsmBci, 0, (commas + 1) * sizeof(RIL_GSM_BroadcastSmsConfigInfo *));
> 
>     for (i = 0; i < commas + 1; i++) {
>         pGsmBci[i] = (RIL_GSM_BroadcastSmsConfigInfo *)alloca(
>                 sizeof(RIL_GSM_BroadcastSmsConfigInfo));
>         memset(pGsmBci[i], 0, sizeof(RIL_GSM_BroadcastSmsConfigInfo));
> 
>         err = at_tok_nextstr(&serviceIds, &serviceId);
>         if (err < 0) goto error;
>         pGsmBci[i]->toServiceId = pGsmBci[i]->fromServiceId = 0;
>         if (strstr(serviceId, "-")) {
>             sscanf(serviceId,"%d-%d", &pGsmBci[i]->fromServiceId,
>                    &pGsmBci[i]->toServiceId);
>         }
> 
>         err = at_tok_nextstr(&codeSchemes, &codeScheme);
>         if (err < 0) goto error;
>         pGsmBci[i]->toCodeScheme = pGsmBci[i]->fromCodeScheme = 0;
>         if (strstr(codeScheme, "-")) {
>             sscanf(codeScheme, "%d-%d", &pGsmBci[i]->fromCodeScheme,
>                    &pGsmBci[i]->toCodeScheme);
>         }
> 
>         pGsmBci[i]->selected = (mode == 0 ? false : true);
>     }
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, pGsmBci,
>         (commas + 1) * sizeof(RIL_GSM_BroadcastSmsConfigInfo *));
>     at_response_free(p_response);
>     return;
> 
> error:
>     at_response_free(p_response);
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
> }
> 
> /**
>  * <AcT>: integer type; access technology selected
>  * 0 GSM
>  * 1 GSM Compact
>  * 2 UTRAN
>  * 3 GSM w/EGPRS (see NOTE 1)
>  * 4 UTRAN w/HSDPA (see NOTE 2)
>  * 5 UTRAN w/HSUPA (see NOTE 2)
>  * 6 UTRAN w/HSDPA and HSUPA (see NOTE 2)
>  * 7 E-UTRAN
>  * 8 EC-GSM-IoT (A/Gb mode) (see NOTE 3)
>  * 9 E-UTRAN (NB-S1 mode) (see NOTE 4)
>  * 10  E-UTRA connected to a 5GCN (see NOTE 5)
>  * 11  NR connected to a 5GCN (see NOTE 5)
>  * 12  NG-RAN
>  * 13  E-UTRA-NR dual connectivity (see NOTE 6)
>  */
> int mapRadioAccessNetworkToTech(RIL_RadioAccessNetworks network) {
>     switch (network) {
>         case GERAN:  // GSM EDGE
>             return 3;
>         case UTRAN:
>             return 6;
>         case EUTRAN:
>             return 7;
>         case NGRAN:
>             return 11;
>         default:
>             return 7;  // LTE
>     }
> }
> 
> static void requestSetNetworlSelectionManual(void *data, RIL_Token t) {
>     int err = -1;
>     char cmd[64] = {0};
>     ATResponse *p_response = NULL;
>     RIL_NetworkOperator *operator = (RIL_NetworkOperator *)data;
> 
>     if (operator->act != UNKNOWN) {
>         snprintf(cmd, sizeof(cmd), "AT+COPS=1,2,\"%s\"", operator->operatorNumeric);
>     } else {
>         snprintf(cmd, sizeof(cmd), "AT+COPS=1,2,\"%s\",%d",
>             operator->operatorNumeric, operator->act);
>     }
>     err = at_send_command(cmd, &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     at_response_free(p_response);
>     return;
2276c4078,4086
<    muteResponse = 0; // Mute disabled
---
> error:
>     if (p_response != NULL &&
>         !strcmp(p_response->finalResponse, "+CME ERROR: 30")) {
>           RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     }
>     at_response_free(p_response);
> }
2278c4088,4256
<    RIL_onRequestComplete(t, RIL_E_SUCCESS, &muteResponse, sizeof(muteResponse));
---
> static void requestStkServiceIsRunning(RIL_Token t)
> {
>     int err = -1;
>     ATResponse *p_response = NULL;
> 
>     s_stkServiceRunning = true;
>     if (NULL != s_stkUnsolResponse) {
>        RIL_onUnsolicitedResponse(RIL_UNSOL_STK_PROACTIVE_COMMAND,
>                             s_stkUnsolResponse, strlen(s_stkUnsolResponse) + 1);
>        free(s_stkUnsolResponse);
>        s_stkUnsolResponse = NULL;
>        RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>        return;
>     }
> 
>     err = at_send_command_singleline("AT+CUSATD?", "+CUSATD:", &p_response);
> 
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestStkSendEnvelope(void *data, RIL_Token t)
> {
>     int ret = -1, err = -1;
>     char cmd[128] = {0};
>     ATResponse *p_response = NULL;
> 
>     if (data == NULL || strlen((char *)data) == 0) {
>         RLOGE("STK sendEnvelope data is invalid");
>         RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>         return;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CUSATE=\"%s\"", (char *)data);
>     err = at_send_command_singleline(cmd, "+CUSATE:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
> 
>         // type of alpha data is 85, such as 850C546F6F6C6B6974204D656E75
>         char *p = strstr(p_response->p_intermediates->line, "85");
>         if (p != NULL) {
>             char alphaStrHexLen[3] = {0};
>             char alphaStr[1024] = {0};
>             uint8_t *alphaBytes = NULL;
>             int len = 0;
> 
>             p = p + strlen("85");
>             strncpy(alphaStrHexLen, p, 2);
>             len = strtoul(alphaStrHexLen, NULL, 16);
>             strncpy(alphaStr, p + 2, len * 2);
>             alphaBytes = convertHexStringToBytes(alphaStr, strlen(alphaStr));
>             RIL_onUnsolicitedResponse(RIL_UNSOL_STK_CC_ALPHA_NOTIFY, alphaBytes,
>                                       strlen((char *)alphaBytes));
>             free(alphaBytes);
>         }
>     }
>     at_response_free(p_response);
> }
> 
> static void requestStksendTerminalResponse(void *data, RIL_Token t)
> {
>     int ret = -1, err = -1;
>     char cmd[128] = {0};
>     ATResponse *p_response = NULL;
> 
>     if (data == NULL || strlen((char *)data) == 0) {
>         RLOGE("STK sendTerminalResponse data is invalid");
>         RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>         return;
>     }
> 
>     snprintf(cmd, sizeof(cmd), "AT+CUSATT=\"%s\"", (char *)data);
>     err = at_send_command_singleline( cmd, "+CUSATT:", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     }
>     at_response_free(p_response);
> }
> 
> static void requestEccDial(void *data, RIL_Token t) {
>     char cmd[64] = {0};
>     const char *clir = NULL;
>     int err = -1;
>     RIL_EmergencyDial *p_eccDial = (RIL_EmergencyDial *)data;
> 
>     switch (p_eccDial->dialInfo.clir) {
>         case 0:  /* subscription default */
>             clir = "";
>             break;
>         case 1:  /* invocation */
>             clir = "I";
>             break;
>         case 2:  /* suppression */
>             clir = "i";
>             break;
>         default:
>             break;
>     }
> 
>     if (p_eccDial->routing == ROUTING_MERGENCY ||
>         p_eccDial->routing ==  ROUTING_UNKNOWN) {
>       if (p_eccDial->categories == CATEGORY_UNSPECIFIED) {
>           snprintf(cmd, sizeof(cmd), "ATD%s@,#%s;", p_eccDial->dialInfo.address, clir);
>       } else {
>           snprintf(cmd, sizeof(cmd), "ATD%s@%d,#%s;", p_eccDial->dialInfo.address,
>               p_eccDial->categories, clir);
>       }
>     } else {  // ROUTING_NORMAL
>         snprintf(cmd, sizeof(cmd), "ATD%s%s;", p_eccDial->dialInfo.address, clir);
>     }
> 
>     err = at_send_command(cmd, NULL);
>     if (err != 0) goto error;
> 
>     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>     return;
> 
> error:
>     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
> }
> 
> void getConfigSlotStatus(RIL_SimSlotStatus_V1_2 *pSimSlotStatus) {
>     if (pSimSlotStatus == NULL) {
>         return;
>     }
>     if (getSIMStatus() == SIM_ABSENT) {
>         pSimSlotStatus->base.cardState = RIL_CARDSTATE_ABSENT;
>     } else {
>         pSimSlotStatus->base.cardState = RIL_CARDSTATE_PRESENT;
>     }
>     // TODO: slot state is always active now
>     pSimSlotStatus->base.slotState = SLOT_STATE_ACTIVE;
> 
>     if (pSimSlotStatus->base.cardState != RIL_CARDSTATE_ABSENT) {
>         pSimSlotStatus->base.atr = "";
>         pSimSlotStatus->base.iccid = (char *)calloc(64, sizeof(char));
>         getIccId(pSimSlotStatus->base.iccid, 64);
>     }
> 
>     pSimSlotStatus->base.logicalSlotId = 0;
>     pSimSlotStatus->eid = "";
> }
> 
> void onIccSlotStatus(RIL_Token t) {
>     RIL_SimSlotStatus_V1_2 *pSimSlotStatusList =
>         (RIL_SimSlotStatus_V1_2 *)calloc(SIM_COUNT, sizeof(RIL_SimSlotStatus_V1_2));
> 
>     getConfigSlotStatus(pSimSlotStatusList);
> 
>     if (t == NULL) {
>         RIL_onUnsolicitedResponse(RIL_UNSOL_CONFIG_ICC_SLOT_STATUS, pSimSlotStatusList,
>                  SIM_COUNT * sizeof(RIL_SimSlotStatus_V1_2));
>     } else {
>         RIL_onRequestComplete(t, RIL_E_SUCCESS, pSimSlotStatusList,
>                 SIM_COUNT * sizeof(RIL_SimSlotStatus_V1_2));
>     }
> 
>     if (pSimSlotStatusList != NULL) {
>         free(pSimSlotStatusList->base.iccid);
>         free(pSimSlotStatusList);
>     }
2301c4279
<     RLOGD("onRequest: %s", requestToString(request));
---
>     RLOGD("onRequest: %s, sState: %d", requestToString(request), sState);
2331a4310
>             case RIL_REQUEST_SET_MUTE:
2348a4328
>             case RIL_REQUEST_SCREEN_STATE:
2361c4341
<             RIL_CardStatus_v6 *p_card_status;
---
>             RIL_CardStatus_v1_5 *p_card_status;
2471a4452,4465
>         case RIL_REQUEST_SIM_AUTHENTICATION: {
>             RIL_SimAuthentication *sim_auth = (RIL_SimAuthentication *)data;
>             if ((sim_auth->authContext == AUTH_CONTEXT_EAP_SIM ||
>                  sim_auth->authContext == AUTH_CONTEXT_EAP_AKA) &&
>                 sim_auth->authData != NULL) {
>                 requestSimAuthentication(sim_auth->authContext, sim_auth->authData, t);
>             } else {
>                 RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>             }
>             break;
>         }
>         case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
>             requestTransmitApduBasic(data, datalen, t);
>             break;
2476c4470
<             requestDeactivateDataCall(t);
---
>             requestDeactivateDataCall(data, t);
2507a4502
> 
2519c4514
<                 return;
---
>                 break;
2535a4531,4536
>                 break;
>             }
>             p_response = NULL;
>             err = at_send_command("AT+COPS=0", &p_response);
>             if (err < 0 || p_response->success == 0) {
>                 RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
2537c4538
<                 at_send_command("AT+COPS=0", NULL);
---
>                 RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
2538a4540,4544
>             at_response_free(p_response);
>             break;
> 
>         case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
>             requestSetNetworlSelectionManual(data, t);
2592d4597
<         case RIL_REQUEST_ENTER_SIM_PUK:
2593a4599,4602
>             requestEnterSimPin(request, data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_ENTER_SIM_PUK:
2595a4605,4607
>             requestChangeSimPin(request, data, datalen, t);
>             break;
> 
2597c4609
<             requestEnterSimPin(data, datalen, t);
---
>             requestChangeSimPin2(data, datalen, t);
2661a4674,4677
>         case RIL_REQUEST_SET_RADIO_CAPABILITY:
>             requestSetRadioCapability(data, datalen, t);
>             break;
> 
2665a4682,4695
>         case RIL_REQUEST_SET_MUTE:
>             requestSetMute(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: {
>           int size = 5;
>           int response[20] = {0};
>           for (int i = 1; i <= size; i++) {
>             response[i] = i - 1;
>           }
>           RIL_onRequestComplete(t, RIL_E_SUCCESS, response, (size + 1) * sizeof(int));
>           break;
>         }
> 
2669,2670d4698
<         case RIL_REQUEST_SET_CLIR:
<         case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
2672d4699
<         case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
2740a4768,4979
>         case RIL_REQUEST_GET_ACTIVITY_INFO:
>             requestGetActivityInfo(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SCREEN_STATE:
>             requestScreenState(data, t);
>             break;
> 
>         case RIL_REQUEST_SET_DATA_PROFILE:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
> 
>         case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
>             requestQueryCallForward(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SET_CALL_FORWARD:
>             requestSetCallForward(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_QUERY_CLIP:
>             requestQueryClip(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_GET_CLIR:
>             requestQueryClir(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SET_CLIR:
>             requestSetClir(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_QUERY_CALL_WAITING:
>             requestQueryCallWaiting(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SET_CALL_WAITING:
>             requestSetCallWaiting(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
>             requestSetSuppServiceNotifications(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
>             requestChangeBarringPassword(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_QUERY_FACILITY_LOCK: {
>             char *lockData[4];
>             lockData[0] = ((char **)data)[0];
>             lockData[1] = "2";
>             lockData[2] = ((char **)data)[1];
>             lockData[3] = ((char **)data)[2];
>             requestFacilityLock(request, lockData, datalen + sizeof(char *), t);
>             break;
>         }
> 
>         case RIL_REQUEST_SET_FACILITY_LOCK:
>             requestFacilityLock(request, data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_GET_SMSC_ADDRESS:
>             requestGetSmscAddress(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_SET_SMSC_ADDRESS:
>             requestSetSmscAddress(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG:
>             requestSetSmsBroadcastConfig(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG:
>             requestGetSmsBroadcastConfig(data, datalen, t);
>             break;
> 
>         case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
>             requestStkServiceIsRunning(t);
>             break;
> 
>         case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
>             requestStkSendEnvelope(data, t);
>             break;
> 
>         case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
>             requestStksendTerminalResponse(data, t);
>             break;
> 
>         // New requests after P.
>         case RIL_REQUEST_START_NETWORK_SCAN:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_GET_MODEM_STACK_STATUS:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_ENABLE_MODEM:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_EMERGENCY_DIAL:
>             requestEccDial(data, t);
>             break;
>         case RIL_REQUEST_SET_SIM_CARD_POWER:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP:
>             requestSetPreferredNetworkType(request, data, datalen, t);
>             break;
>         case RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP:
>             requestSetPreferredNetworkType(request, data, datalen, t);
>             break;
>         case RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP:
>             requestGetPreferredNetworkType(request, data, datalen, t);
>         case RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY:
>             if (data == NULL || datalen != sizeof(int)) {
>                 RIL_onRequestComplete(t, RIL_E_INTERNAL_ERR, NULL, 0);
>                 break;
>             }
>             int nrDualConnectivityState = *(int *)(data);
>             isNrDualConnectivityEnabled = (nrDualConnectivityState == 1) ? true : false;
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, &isNrDualConnectivityEnabled,
>                     sizeof(isNrDualConnectivityEnabled));
>             break;
>         case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP:
>             requestGetPreferredNetworkType(request, data, datalen, t);
>             break;
>         case RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_GET_SLICING_CONFIG:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
> 
>         // Radio config requests
>         case RIL_REQUEST_CONFIG_GET_SLOT_STATUS:
>             RIL_requestTimedCallback(onIccSlotStatus, (void *)t, NULL);
>             break;
>         case RIL_REQUEST_CONFIG_SET_SLOT_MAPPING:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_CONFIG_GET_PHONE_CAPABILITY: {
>             RIL_PhoneCapability *phoneCapability =
>                     (RIL_PhoneCapability *)alloca(sizeof(RIL_PhoneCapability));
>             phoneCapability->maxActiveData = 1;
>             // DSDS is 1, and DSDA is 2, now only support DSDS
>             phoneCapability->maxActiveInternetData = 1;
>             // DSDA can support internet lingering
>             phoneCapability->isInternetLingeringSupported = false;
>             for (int num = 0; num < SIM_COUNT; num++) {
>                 phoneCapability->logicalModemList[num].modemId = num;
>             }
>             RIL_onRequestComplete(t, RIL_E_SUCCESS,
>                             phoneCapability, sizeof(RIL_PhoneCapability));
>             break;
>         }
>         case RIL_REQUEST_CONFIG_SET_MODEM_CONFIG: {
>             RIL_ModemConfig *mdConfig = (RIL_ModemConfig*)(data);
>             if (mdConfig == NULL || mdConfig->numOfLiveModems != 1) {
>                 RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>             } else {
>                 RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             }
>             break;
>         }
>         case RIL_REQUEST_CONFIG_GET_MODEM_CONFIG: {
>             RIL_ModemConfig mdConfig;
>             mdConfig.numOfLiveModems = 1;
> 
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, &mdConfig, sizeof(RIL_ModemConfig));
>             break;
>         }
>         case RIL_REQUEST_CONFIG_SET_PREFER_DATA_MODEM: {
>             int *modemId = (int*)(data);
>             if (modemId == NULL || *modemId != 0) {
>                 RIL_onRequestComplete(t, RIL_E_INVALID_ARGUMENTS, NULL, 0);
>             } else {
>                 RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             }
>             break;
>         }
>         case RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_ENABLE_UICC_APPLICATIONS: {
>             if (data == NULL || datalen != sizeof(int)) {
>                 RIL_onRequestComplete(t, RIL_E_INTERNAL_ERR, NULL, 0);
>                 break;
>             }
>             areUiccApplicationsEnabled = *(int *)(data);
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         }
>         case RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, &areUiccApplicationsEnabled,
>                     sizeof(areUiccApplicationsEnabled));
>             break;
>         case RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_GET_BARRING_INFO:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
>         case RIL_REQUEST_SET_DATA_THROTTLING:
>             RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
>             break;
2999a5239,5256
> static void getIccId(char *iccid, int size) {
>     int err = 0;
>     ATResponse *p_response = NULL;
> 
>     if (iccid == NULL) {
>         RLOGE("iccid buffer is null");
>         return;
>     }
>     err = at_send_command_numeric("AT+CICCID", &p_response);
>     if (err < 0 || p_response->success == 0) {
>         goto error;
>     }
> 
>     snprintf(iccid, size, "%s", p_response->p_intermediates->line);
> 
> error:
>     at_response_free(p_response);
> }
3007c5264
< static int getCardStatus(RIL_CardStatus_v6 **pp_card_status) {
---
> static int getCardStatus(RIL_CardStatus_v1_5 **pp_card_status) {
3078,3084c5335,5349
<     RIL_CardStatus_v6 *p_card_status = malloc(sizeof(RIL_CardStatus_v6));
<     p_card_status->card_state = card_state;
<     p_card_status->universal_pin_state = RIL_PINSTATE_UNKNOWN;
<     p_card_status->gsm_umts_subscription_app_index = -1;
<     p_card_status->cdma_subscription_app_index = -1;
<     p_card_status->ims_subscription_app_index = -1;
<     p_card_status->num_applications = num_apps;
---
>     RIL_CardStatus_v1_5 *p_card_status = calloc(1, sizeof(RIL_CardStatus_v1_5));
>     p_card_status->base.base.base.card_state = card_state;
>     p_card_status->base.base.base.universal_pin_state = RIL_PINSTATE_UNKNOWN;
>     p_card_status->base.base.base.gsm_umts_subscription_app_index = -1;
>     p_card_status->base.base.base.cdma_subscription_app_index = -1;
>     p_card_status->base.base.base.ims_subscription_app_index = -1;
>     p_card_status->base.base.base.num_applications = num_apps;
>     p_card_status->base.base.physicalSlotId = 0;
>     p_card_status->base.base.atr = NULL;
>     p_card_status->base.base.iccid = NULL;
>     p_card_status->base.eid = "";
>     if (sim_status != SIM_ABSENT) {
>         p_card_status->base.base.iccid = (char *)calloc(64, sizeof(char));
>         getIccId(p_card_status->base.base.iccid, 64);
>     }
3089c5354
<         p_card_status->applications[i] = app_status_array[SIM_ABSENT];
---
>         p_card_status->base.base.base.applications[i] = app_status_array[SIM_ABSENT];
3091c5356
< 
---
>     RLOGD("enter getCardStatus module, num_apps= %d",num_apps);
3095,3098c5360,5363
<         p_card_status->num_applications = 3;
<         p_card_status->gsm_umts_subscription_app_index = 0;
<         p_card_status->cdma_subscription_app_index = 1;
<         p_card_status->ims_subscription_app_index = 2;
---
>         p_card_status->base.base.base.num_applications = 3;
>         p_card_status->base.base.base.gsm_umts_subscription_app_index = 0;
>         p_card_status->base.base.base.cdma_subscription_app_index = 1;
>         p_card_status->base.base.base.ims_subscription_app_index = 2;
3101,3103c5366,5368
<         p_card_status->applications[0] = app_status_array[sim_status];
<         p_card_status->applications[1] = app_status_array[sim_status + RUIM_ABSENT];
<         p_card_status->applications[2] = app_status_array[sim_status + ISIM_ABSENT];
---
>         p_card_status->base.base.base.applications[0] = app_status_array[sim_status];
>         p_card_status->base.base.base.applications[1] = app_status_array[sim_status + RUIM_ABSENT];
>         p_card_status->base.base.base.applications[2] = app_status_array[sim_status + ISIM_ABSENT];
3113c5378,5382
< static void freeCardStatus(RIL_CardStatus_v6 *p_card_status) {
---
> static void freeCardStatus(RIL_CardStatus_v1_5 *p_card_status) {
>     if (p_card_status == NULL) {
>         return;
>     }
>     free(p_card_status->base.base.iccid);
3265,3266c5534,5535
<  * is ignored, but the return value will still reflect if retreiving and parsing of the
<  * values suceeded.
---
>  * is ignored, but the return value will still reflect if retrieving and parsing of the
>  * values succeeded.
3455a5725,5788
> static int parseProactiveCmdInd(char *response) {
>     int typePos = 0;
>     int cmdType = 0;
>     char tempStr[3] = {0};
>     char *end = NULL;
>     StkUnsolEvent ret = STK_UNSOL_EVENT_UNKNOWN;
> 
>     if (response == NULL || strlen(response) < 3) {
>       return ret;
>     }
> 
>     if (response[2] <= '7') {
>        typePos = 10;
>     } else {
>        typePos = 12;
>     }
> 
>     if ((int)strlen(response) < typePos + 1) {
>       return ret;
>     }
> 
>     memcpy(tempStr, &(response[typePos]), 2);
>     cmdType = strtoul(tempStr, &end, 16);
>     cmdType = 0xFF & cmdType;
>     RLOGD("cmdType: %d",cmdType);
> 
>     switch (cmdType) {
>        case STK_RUN_AT:
>        case STK_SEND_DTMF:
>        case STK_SEND_SMS:
>        case STK_SEND_SS:
>        case STK_SEND_USSD:
>        case STK_PLAY_TONE:
>        case STK_CLOSE_CHANNEL:
>            ret = STK_UNSOL_EVENT_NOTIFY;
>            break;
>        case STK_REFRESH:
>            if (strncasecmp(&(response[typePos + 2]), "04", 2) == 0) {  // SIM_RESET
>                RLOGD("Type of Refresh is SIM_RESET");
>                s_stkServiceRunning = false;
>                ret = STK_UNSOL_PROACTIVE_CMD;
>            } else {
>                ret = STK_UNSOL_EVENT_NOTIFY;
>            }
>            break;
>        default:
>            ret = STK_UNSOL_PROACTIVE_CMD;
>            break;
>     }
> 
>     if (getSIMStatus() == SIM_ABSENT && s_stkServiceRunning) {
>         s_stkServiceRunning = false;
>     }
> 
>     if (false == s_stkServiceRunning) {
>         ret = STK_UNSOL_EVENT_UNKNOWN;
>         s_stkUnsolResponse = (char *)calloc((strlen(response) + 1), sizeof(char));
>         snprintf(s_stkUnsolResponse, strlen(response) + 1, "%s", response);
>         RLOGD("STK service is not running [%s]", s_stkUnsolResponse);
>     }
> 
>     return ret;
> }
> 
3473c5806,5833
<     if (strStartsWith(s, "%CTZV:")) {
---
> #define  CGFPCCFG "%CGFPCCFG:"
>     if (strStartsWith(s, CGFPCCFG)) {
>         /* cuttlefish/goldfish specific
>         */
>         char *response;
>         line = p = strdup(s);
>         RLOGD("got CGFPCCFG line %s and %s\n", s, p);
>         err = at_tok_start(&line);
>         if(err) {
>             RLOGE("invalid CGFPCCFG line %s and %s\n", s, p);
>         }
> #define kSize 5
>         int configs[kSize];
>         for (int i=0; i < kSize && !err; ++i) {
>             err = at_tok_nextint(&line, &(configs[i]));
>             RLOGD("got i %d, val = %d", i, configs[i]);
>         }
>         if(err) {
>             RLOGE("invalid CGFPCCFG line %s and %s\n", s, p);
>         } else {
>             int modem_tech = configs[2];
>             configs[2] = techFromModemType(modem_tech);
>             RIL_onUnsolicitedResponse (
>                 RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS,
>                 configs, kSize);
>         }
>         free(p);
>     } else if (strStartsWith(s, "%CTZV:")) {
3565a5926
>         free(line);
3610a5972,6023
>     } else if (strStartsWith(s, "+CSQ: ")) {
>         // Accept a response that is at least v6, and up to v12
>         int minNumOfElements=sizeof(RIL_SignalStrength_v6)/sizeof(int);
>         int maxNumOfElements=sizeof(RIL_SignalStrength_v12)/sizeof(int);
>         int response[maxNumOfElements];
>         memset(response, 0, sizeof(response));
> 
>         line = p = strdup(s);
>         at_tok_start(&p);
> 
>         for (int count = 0; count < maxNumOfElements; count++) {
>             err = at_tok_nextint(&p, &(response[count]));
>             if (err < 0 && count < minNumOfElements) {
>               free(line);
>               return;
>             }
>         }
> 
>         RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH,
>             response, sizeof(response));
>         free(line);
>     } else if (strStartsWith(s, "+CUSATEND")) {  // session end
>       RIL_onUnsolicitedResponse(RIL_UNSOL_STK_SESSION_END, NULL, 0);
>     } else if (strStartsWith(s, "+CUSATP:")) {
>         line = p = strdup(s);
>         if (!line) {
>             RLOGE("+CUSATP: Unable to allocate memory");
>             return;
>         }
>         if (at_tok_start(&p) < 0) {
>             RLOGE("invalid +CUSATP response: %s", s);
>             free(line);
>             return;
>         }
> 
>         char *response = NULL;
>         if (at_tok_nextstr(&p, &response) < 0) {
>             RLOGE("%s fail", s);
>             free(line);
>             return;
>         }
> 
>         StkUnsolEvent ret = parseProactiveCmdInd(response);
>         if (ret == STK_UNSOL_EVENT_NOTIFY) {
>             RIL_onUnsolicitedResponse(RIL_UNSOL_STK_EVENT_NOTIFY, response,
>                                       strlen(response) + 1);
>         } else if (ret == STK_UNSOL_PROACTIVE_CMD) {
>             RIL_onUnsolicitedResponse(RIL_UNSOL_STK_PROACTIVE_COMMAND, response,
>                                       strlen(response) + 1);
>         }
> 
>         free(line);
3668c6081,6084
<             if (s_port > 0) {
---
>             if (isInEmulator()) {
>                 fd = qemu_open_modem_port();
>                 RLOGD("opening qemu_modem_port %d!", fd);
>             } else if (s_port > 0) {
3669a6086,6104
>             } else if (s_modem_simulator_port >= 0) {
>               fd = socket(AF_VSOCK, SOCK_STREAM, 0);
>               if (fd < 0) {
>                  RLOGD("Can't create AF_VSOCK socket!");
>                  continue;
>               }
>               struct sockaddr_vm sa;
>               memset(&sa, 0, sizeof(struct sockaddr_vm));
>               sa.svm_family = AF_VSOCK;
>               sa.svm_cid = VMADDR_CID_HOST;
>               sa.svm_port = s_modem_simulator_port;
> 
>               if (connect(fd, (struct sockaddr *)(&sa), sizeof(sa)) < 0) {
>                   RLOGD("Can't connect to port:%ud, errno: %s",
>                       s_modem_simulator_port, strerror(errno));
>                   close(fd);
>                   fd = -1;
>                   continue;
>               }
3724c6159,6160
<     while ( -1 != (opt = getopt(argc, argv, "p:d:s:c:"))) {
---
>     RLOGD("RIL_Init");
>     while ( -1 != (opt = getopt(argc, argv, "p:d:s:c:m:"))) {
3749a6186,6190
>             case 'm':
>               s_modem_simulator_port = strtoul(optarg, NULL, 10);
>               RLOGI("Opening modem simulator port %ud\n", s_modem_simulator_port);
>             break;
> 
3756c6197,6198
<     if (s_port < 0 && s_device_path == NULL) {
---
>     if (s_port < 0 && s_device_path == NULL && !isInEmulator() &&
>         s_modem_simulator_port < 0) {
3805c6247
<     if (s_port < 0 && s_device_path == NULL) {
---
>     if (s_port < 0 && s_device_path == NULL && !isInEmulator()) {
3816a6259
> 
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/reference-ril/ril.h /home/yajat/Desktop/H618-Android12-Src/hardware/ril/reference-ril/ril.h
21a22
> #include <stdbool.h>
55,58c56,59
<  * just document RIL version associated with that change below. When OEM updates its
<  * RIL with those changes, they would return that new RIL version during RIL_REGISTER.
<  * We should make use of the returned version by vendor to identify appropriate scheme
<  * or data structure version to use.
---
>  * just document RIL version associated with that change below. When OEM updates
>  * its RIL with those changes, they would return that new RIL version during
>  * RIL_REGISTER. We should make use of the returned version by vendor to
>  * identify appropriate scheme or data structure version to use.
61,62c62,63
<  * RIL_VERSION = 12 : This version corresponds to updated data structures namely
<  *                    RIL_Data_Call_Response_v11, RIL_SIM_IO_v6, RIL_CardStatus_v6,
---
>  * RIL_VERSION = 12 : Updated data structures: RIL_Data_Call_Response_v11,
>  *                    RIL_SIM_IO_v6, RIL_CardStatus_v6,
64,74c65,81
<  *                    RIL_LTE_SignalStrength_v8, RIL_SignalStrength_v10, RIL_CellIdentityGsm_v12
<  *                    RIL_CellIdentityWcdma_v12, RIL_CellIdentityLte_v12,RIL_CellInfoGsm_v12,
<  *                    RIL_CellInfoWcdma_v12, RIL_CellInfoLte_v12, RIL_CellInfo_v12.
<  *
<  * RIL_VERSION = 13 : This version includes new wakelock semantics and as the first
<  *                    strongly versioned version it enforces structure use.
<  *
<  * RIL_VERSION = 14 : New data structures are added, namely RIL_CarrierMatchType,
<  *                    RIL_Carrier, RIL_CarrierRestrictions and RIL_PCO_Data.
<  *                    New commands added: RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
<  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS and RIL_UNSOL_PCO_DATA.
---
>  *                    RIL_LTE_SignalStrength_v8, RIL_SignalStrength_v10,
>  *                    RIL_CellIdentityGsm_v12, RIL_CellIdentityWcdma_v12,
>  *                    RIL_CellIdentityLte_v12, RIL_CellInfoGsm_v12,
>  *                    RIL_CellInfoWcdma_v12, RIL_CellInfoLte_v12,
>  *                    RIL_CellInfo_v12
>  *
>  * RIL_VERSION = 13 : This version includes new wakelock semantics and as the
>  *                    first strongly versioned version it enforces structure
>  *                    use.
>  *
>  * RIL_VERSION = 14 : New commands added:
>  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
>  *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
>  *                    RIL_UNSOL_PCO_DATA
>  *                    New data structures are added: RIL_CarrierMatchType,
>  *                    RIL_Carrier, RIL_CarrierRestrictions, RIL_PCO_Data
>  *
83,89d89
<  *                    The new parameters for RIL_REQUEST_SETUP_DATA_CALL,
<  *                    Updated data structures: RIL_DataProfileInfo_v15, RIL_InitialAttachApn_v15
<  *                    New data structure RIL_DataRegistrationStateResponse,
<  *                    RIL_VoiceRegistrationStateResponse same is
<  *                    used in RIL_REQUEST_DATA_REGISTRATION_STATE and
<  *                    RIL_REQUEST_VOICE_REGISTRATION_STATE respectively.
<  *                    New data structure RIL_OpenChannelParams.
92a93,125
>  *                    RIL_REQUEST_GET_MODEM_STACK_STATUS
>  *                    RIL_REQUEST_ENABLE_MODEM
>  *                    RIL_REQUEST_EMERGENCY_DIAL
>  *                    RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS
>  *                    RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA
>  *                    RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA
>  *                    RIL_REQUEST_ENABLE_UICC_APPLICATIONS
>  *                    RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED
>  *                    RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION
>  *                    RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE
>  *                    New parameters for RIL_REQUEST_SETUP_DATA_CALL
>  *                    Updated data structures: RIL_DataProfileInfo_v15,
>  *                    RIL_InitialAttachApn_v15, RIL_Data_Call_Response_v12
>  *                    New data structures: RIL_DataRegistrationStateResponse,
>  *                    RIL_OpenChannelParams,
>  *                    RIL_VoiceRegistrationStateResponse same is used in
>  *                    RIL_REQUEST_DATA_REGISTRATION_STATE and
>  *                    RIL_REQUEST_VOICE_REGISTRATION_STATE respectively.
>  * RIL_VERSION = 16 : New commands added:
>  *                    RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY
>  *                    RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED
>  *                    RIL_REQUEST_ALLOCATE_PDU_SESSION_ID
>  *                    RIL_REQUEST_RELEASE_PDU_SESSION_ID
>  *                    RIL_REQUEST_START_HANDOVER
>  *                    RIL_REQUEST_CANCEL_HANDOVER
>  *                    RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP
>  *                    RIL_REQUEST_SET_DATA_THROTTLING
>  *                    RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS
>  *                    RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP
>  *                    RIL_REQUEST_GET_SLICING_CONFIG
>  *                    New parameters for RIL_REQUEST_SETUP_DATA_CALL
>  *                    Updated data structures: RIL_CarrierInfoForImsiEncryption_v16
>  *                    New data structure: RIL_PublicKeyType
94c127
< #define RIL_VERSION 12
---
> #define RIL_VERSION 16
111a145
> #define RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE 8
265c299,300
<     RADIO_TECH_LTE_CA = 19
---
>     RADIO_TECH_LTE_CA = 19,
>     RADIO_TECH_NR = 20
287c322,323
<     RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA)
---
>     RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA),
>     RAF_NR = (1 << RADIO_TECH_NR)
552a589,628
> typedef struct {
>     int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
>     int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
>                                            back-off timer value RIL wants to override the one
>                                            pre-configured in FW.
>                                            The unit is milliseconds.
>                                            The value < 0 means no value is suggested.
>                                            The value 0 means retry should be done ASAP.
>                                            The value of INT_MAX(0x7fffffff) means no retry. */
>     int             cid;        /* Context ID, uniquely identifies this call */
>     int             active;     /* 0=inactive, 1=active/physical link down,
>                                    2=active/physical link up */
>     char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
>                                    For example, "IP", "IPV6", "IPV4V6", or "PPP". If status is
>                                    PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED this is the type supported
>                                    such as "IP" or "IPV6" */
>     char *          ifname;     /* The network interface name */
>     char *          addresses;  /* A space-delimited list of addresses with optional "/" prefix
>                                    length, e.g., "192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
>                                    May not be empty, typically 1 IPv4 or 1 IPv6 or
>                                    one of each. If the prefix length is absent the addresses
>                                    are assumed to be point to point with IPv4 having a prefix
>                                    length of 32 and IPv6 128. */
>     char *          dnses;      /* A space-delimited list of DNS server addresses,
>                                    e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
>                                    May be empty. */
>     char *          gateways;   /* A space-delimited list of default gateway addresses,
>                                    e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
>                                    May be empty in which case the addresses represent point
>                                    to point connections. */
>     char *          pcscf;      /* the Proxy Call State Control Function address
>                                    via PCO(Protocol Configuration Option) for IMS client. */
>     int             mtuV4;      /* MTU received from network for IPv4.
>                                    Value <= 0 means network has either not sent a value or
>                                    sent an invalid value. */
>     int             mtuV6;      /* MTU received from network for IPv6.
>                                    Value <= 0 means network has either not sent a value or
>                                    sent an invalid value. */
> } RIL_Data_Call_Response_v12;
> 
746,747c822,823
<   RIL_Carrier * allowed_carriers;       /* list of allowed carriers */
<   RIL_Carrier * excluded_carriers;      /* list of explicitly excluded carriers
---
>   RIL_Carrier * allowed_carriers;       /* allowed carriers */
>   RIL_Carrier * excluded_carriers;      /* excluded carriers
754a831,851
> typedef enum {
>     NO_MULTISIM_POLICY = 0,             /* configuration applies to each slot independently. */
>     ONE_VALID_SIM_MUST_BE_PRESENT = 1,  /* Any SIM card can be used as far as one valid card is
>                                          * present in the device.
>                                          */
> } RIL_SimLockMultiSimPolicy;
> 
> typedef struct {
>   int32_t len_allowed_carriers;         /* length of array allowed_carriers */
>   int32_t len_excluded_carriers;        /* length of array excluded_carriers */
>   RIL_Carrier * allowed_carriers;       /* allowed carriers */
>   RIL_Carrier * excluded_carriers;      /* explicitly excluded carriers
>                                          * which match allowed_carriers. Eg. allowed_carriers match
>                                          * mcc/mnc, excluded_carriers has same mcc/mnc and gid1
>                                          * is ABCD. It means except the carrier whose gid1 is ABCD,
>                                          * all carriers with the same mcc/mnc are allowed.
>                                          */
>   int allowedCarriersPrioritized;       /* allowed list prioritized */
>   RIL_SimLockMultiSimPolicy multiSimPolicy; /* multisim policy */
> } RIL_CarrierRestrictionsWithPriority;
> 
769a867,890
> /**
>  * Public key type from carrier certificate.
>  */
> typedef enum {
>     EPDG = 1, /* Key type to be used for ePDG */
>     WLAN = 2, /* Key type to be used for WLAN */
> } RIL_PublicKeyType;
> 
> typedef struct {
>     char* mcc;                 /* MCC of the Carrier. */
>     char* mnc;                 /* MNC of the Carrier. */
>     uint8_t* carrierKey;       /* Public Key from the Carrier used to encrypt the
>                                 * IMSI/IMPI.
>                                 */
>     int32_t carrierKeyLength;  /* Length of the Public Key. */
>     char* keyIdentifier;       /* The keyIdentifier Attribute value pair that helps
>                                 * a server locate the private key to decrypt the
>                                 * permanent identity.
>                                 */
>     int64_t expirationTime;    /* Date-Time (in UTC) when the key will expire. */
>     RIL_PublicKeyType keyType; /* Public key type */
> 
> } RIL_CarrierInfoForImsiEncryption_v16;
> 
892c1013
<     PDP_FAIL_OPERATOR_BARRED = 0x08,               /* no retry */
---
>     PDP_FAIL_OPERATOR_BARRED = 0x08, /* no retry */
896,899c1017,1020
<     PDP_FAIL_MISSING_UKNOWN_APN = 0x1B,            /* no retry */
<     PDP_FAIL_UNKNOWN_PDP_ADDRESS_TYPE = 0x1C,      /* no retry */
<     PDP_FAIL_USER_AUTHENTICATION = 0x1D,           /* no retry */
<     PDP_FAIL_ACTIVATION_REJECT_GGSN = 0x1E,        /* no retry */
---
>     PDP_FAIL_MISSING_UNKNOWN_APN = 0x1B,      /* no retry */
>     PDP_FAIL_UNKNOWN_PDP_ADDRESS_TYPE = 0x1C, /* no retry */
>     PDP_FAIL_USER_AUTHENTICATION = 0x1D,      /* no retry */
>     PDP_FAIL_ACTIVATION_REJECT_GGSN = 0x1E,   /* no retry */
904,906c1025,1027
<     PDP_FAIL_NSAPI_IN_USE = 0x23,                  /* no retry */
<     PDP_FAIL_REGULAR_DEACTIVATION = 0x24,          /* possibly restart radio,
<                                                       based on framework config */
---
>     PDP_FAIL_NSAPI_IN_USE = 0x23,         /* no retry */
>     PDP_FAIL_REGULAR_DEACTIVATION = 0x24, /* possibly restart radio,
>                                              based on framework config */
917,918c1038,1039
<     PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32,             /* no retry */
<     PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33,             /* no retry */
---
>     PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32, /* no retry */
>     PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33, /* no retry */
933c1054
<     PDP_FAIL_PROTOCOL_ERRORS = 0x6F,             /* no retry */
---
>     PDP_FAIL_PROTOCOL_ERRORS = 0x6F, /* no retry */
944a1066,1069
>     // TODO: add new fail causes from IRadio 1.4 types.hal
>     PDP_FAIL_SLICE_REJECTED = 0x8CC,
>     PDP_FAIL_MATCH_ALL_RULE_NOT_ALLOWED = 0x8CD,
>     ALL_MATCHING_RULES_FAILED = 0x8CE,
968c1093
<    /* reasons for data call drop - network/modem disconnect */
---
>     /* reasons for data call drop - network/modem disconnect */
970,976c1095,1101
<     PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4,/* preferred technology has changed, should retry
<                                              with parameters appropriate for new technology */
<     PDP_FAIL_RADIO_POWER_OFF = -5,        /* data call was disconnected because radio was resetting,
<                                              powered off - no retry */
<     PDP_FAIL_TETHERED_CALL_ACTIVE = -6,   /* data call was disconnected by modem because tethered
<                                              mode was up on same APN/data profile - no retry until
<                                              tethered call is off */
---
>     PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4, /* preferred technology has changed, should retry
>                                               with parameters appropriate for new technology */
>     PDP_FAIL_RADIO_POWER_OFF = -5,      /* data call was disconnected because radio was resetting,
>                                            powered off - no retry */
>     PDP_FAIL_TETHERED_CALL_ACTIVE = -6, /* data call was disconnected by modem because tethered
>                                            mode was up on same APN/data profile - no retry until
>                                            tethered call is off */
978,979c1103,1104
<     PDP_FAIL_ERROR_UNSPECIFIED = 0xffff,  /* retry silently. Will be deprecated soon as
<                                              new error codes are added making this unnecessary */
---
>     PDP_FAIL_ERROR_UNSPECIFIED = 0xffff, /* retry silently. Will be deprecated soon as
>                                             new error codes are added making this unnecessary */
1139a1265,1370
> typedef struct {
>     RIL_CardStatus_v6 base;
> 
>     uint32_t physicalSlotId;
>     /**
>      * An Answer To Reset (ATR) is a message output by a Smart Card conforming to ISO/IEC 7816
>      * standards, following electrical reset of the card's chip. The ATR conveys information about
>      * the communication parameters proposed by the card, and the card's nature and state.
>      *
>      * This data is applicable only when cardState is CardState:PRESENT.
>      */
>     char *atr;
>     /**
>      * Integrated Circuit Card IDentifier (ICCID) is Unique Identifier of the SIM CARD. File is
>      * located in the SIM card at EFiccid (0x2FE2) as per ETSI 102.221. The ICCID is defined by
>      * the ITU-T recommendation E.118 ISO/IEC 7816.
>      *
>      * This data is applicable only when cardState is CardState:PRESENT.
>      */
>     char *iccid;
> } RIL_CardStatus_v1_2;
> 
> typedef struct {
>     RIL_CardStatus_v1_2 base;
>     char *              eid;    /* The EID is the eUICC identifier. The EID shall be stored within the ECASD and can be
>                                  * retrieved by the Device at any time using the standard GlobalPlatform GET DATA command.
>                                  *
>                                  * This data is mandatory and applicable only when cardState is CardState:PRESENT and SIM card
>                                  * supports eUICC. */
> } RIL_CardStatus_v1_4;
> 
> typedef enum {
>     RIL_PERSOSUBSTATE_UNKNOWN_1_5                   = 0, /* initial state */
>     RIL_PERSOSUBSTATE_IN_PROGRESS_1_5               = 1, /* in between each lock transition */
>     RIL_PERSOSUBSTATE_READY_1_5                     = 2, /* when either SIM or RUIM Perso is finished
>                                                         since each app can only have 1 active perso
>                                                         involved */
>     RIL_PERSOSUBSTATE_SIM_NETWORK_1_5               = 3,
>     RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET_1_5        = 4,
>     RIL_PERSOSUBSTATE_SIM_CORPORATE_1_5             = 5,
>     RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER_1_5      = 6,
>     RIL_PERSOSUBSTATE_SIM_SIM_1_5                   = 7,
>     RIL_PERSOSUBSTATE_SIM_NETWORK_PUK_1_5           = 8, /* The corresponding perso lock is blocked */
>     RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET_PUK_1_5    = 9,
>     RIL_PERSOSUBSTATE_SIM_CORPORATE_PUK_1_5         = 10,
>     RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER_PUK_1_5  = 11,
>     RIL_PERSOSUBSTATE_SIM_SIM_PUK_1_5               = 12,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK1_1_5             = 13,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK2_1_5             = 14,
>     RIL_PERSOSUBSTATE_RUIM_HRPD_1_5                 = 15,
>     RIL_PERSOSUBSTATE_RUIM_CORPORATE_1_5            = 16,
>     RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_1_5     = 17,
>     RIL_PERSOSUBSTATE_RUIM_RUIM_1_5                 = 18,
>     RIL_PERSOSUBSTATE_RUIM_NETWORK1_PUK_1_5         = 19, /* The corresponding perso lock is blocked */
>     RIL_PERSOSUBSTATE_RUIM_NETWORK2_PUK_1_5         = 20,
>     RIL_PERSOSUBSTATE_RUIM_HRPD_PUK_1_5             = 21,
>     RIL_PERSOSUBSTATE_RUIM_CORPORATE_PUK_1_5        = 22,
>     RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_PUK_1_5 = 23,
>     RIL_PERSOSUBSTATE_RUIM_RUIM_PUK_1_5             = 24,
>     /**
>      * The device is personalized using the content of the Service Provider Name (SPN) in the SIM
>      * card.
>      */
>     RIL_PERSOSUBSTATE_SIM_SPN,
>     RIL_PERSOSUBSTATE_SIM_SPN_PUK,
>     /**
>      * Service Provider and Equivalent Home PLMN
>      * The device is personalized using both the content of the GID1 (equivalent to service provider
>      * personalization) and the content of the Equivalent Home PLMN (EHPLMN) in the SIM card.
>      * If the GID1 in the SIM is absent, then just the content of the Equivalent Home PLMN
>      * is matched.
>      */
>     RIL_PERSOSUBSTATE_SIM_SP_EHPLMN,
>     RIL_PERSOSUBSTATE_SIM_SP_EHPLMN_PUK,
>     /**
>      * Device is personalized using the first digits of the ICCID of the SIM card.
>      */
>     RIL_PERSOSUBSTATE_SIM_ICCID,
>     RIL_PERSOSUBSTATE_SIM_ICCID_PUK,
>     /**
>      * Device is personalized using the content of the IMPI in the ISIM.
>      */
>     RIL_PERSOSUBSTATE_SIM_IMPI,
>     RIL_PERSOSUBSTATE_SIM_IMPI_PUK,
>     /**
>       * Network Subset and Service Provider
>      * Device is personalized using both the content of GID1 (equivalent to service provider
>      * personalization) and the first digits of the IMSI (equivalent to network subset
>      * personalization).
>      */
>     RIL_PERSOSUBSTATE_SIM_NS_SP,
>     RIL_PERSOSUBSTATE_SIM_NS_SP_PUK,
> } RIL_PersoSubstateV1_5;
> 
> typedef struct {
>     RIL_AppStatus base;
>     RIL_PersoSubstateV1_5 persoSubstate;
> } RIL_AppStatusV1_5;
> 
> typedef struct {
>     RIL_CardStatus_v1_4 base;
> 
>     /** size <= RadioConst::CARD_MAX_APPS */
>     RIL_AppStatusV1_5 applications[RIL_CARD_MAX_APPS];
> } RIL_CardStatus_v1_5;  // 1.5
> 
1267d1497
< 
1332a1563,1583
> typedef struct {
>   int32_t ssRsrp;   /* SS reference signal received power, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [44, 140], INT_MAX means invalid/unreported. */
>   int32_t ssRsrq;   /* SS reference signal received quality, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [3, 20], INT_MAX means invalid/unreported. */
>   int32_t ssSinr;   /* SS signal-to-noise and interference ratio.
>                      * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>                      * Range [-23, 40], INT_MAX means invalid/unreported. */
>   int32_t csiRsrp;  /* CSI reference signal received power, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [44, 140], INT_MAX means invalid/unreported. */
>   int32_t csiRsrq;  /* CSI reference signal received quality, multiplied by -1.
>                      * Reference: 3GPP TS 38.215.
>                      * Range [3, 20], INT_MAX means invalid/unreported. */
>   int32_t csiSinr;  /* CSI signal-to-noise and interference ratio.
>                      * Reference: 3GPP TS 138.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>                      * Range [-23, 40], INT_MAX means invalid/unreported. */
> } RIL_NR_SignalStrength;
> 
1362a1614,1719
>     RIL_GW_SignalStrength       GW_SignalStrength;
>     RIL_CDMA_SignalStrength     CDMA_SignalStrength;
>     RIL_EVDO_SignalStrength     EVDO_SignalStrength;
>     RIL_LTE_SignalStrength_v8   LTE_SignalStrength;
>     RIL_TD_SCDMA_SignalStrength TD_SCDMA_SignalStrength;
>     RIL_SignalStrengthWcdma     WCDMA_SignalStrength;
>     RIL_NR_SignalStrength       NR_SignalStrength;
> } RIL_SignalStrength_v12;
> 
> /**
>  * Defining signal strength type.
>  */
> typedef enum {
>     /**
>      * Received Signal Strength Indication.
>      * Range: -113 dBm and -51 dBm
>      * Used RAN: GERAN, CDMA2000
>      * Reference: 3GPP TS 27.007 section 8.5.
>      */
>     RSSI = 1,
>     /**
>      * Received Signal Code Power.
>      * Range: -120 dBm to -25 dBm;
>      * Used RAN: UTRAN
>      * Reference: 3GPP TS 25.123, section 9.1.1.1
>      */
>     RSCP = 2,
>     /**
>      * Reference Signal Received Power.
>      * Range: -140 dBm to -44 dBm;
>      * Used RAN: EUTRAN
>      * Reference: 3GPP TS 36.133 9.1.4
>      */
>     RSRP = 3,
>     /**
>      * Reference Signal Received Quality
>      * Range: -34 dB to 3 dB;
>      * Used RAN: EUTRAN
>      * Reference: 3GPP TS 36.133 v12.6.0 section 9.1.7
>      */
>     RSRQ = 4,
>     /**
>      * Reference Signal Signal to Noise Ratio
>      * Range: -20 dB to 30 dB;
>      * Used RAN: EUTRAN
>      * Note: this field is optional; how to support it can be decided by the
>      * corresponding vendor. Though the response code is not enforced,
>      * vendor's implementation must ensure this interface not crashing.
>      */
>     RSSNR = 5,
>     /**
>      * 5G SS reference signal received power.
>      * Range: -140 dBm to -44 dBm.
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215.
>      */
>     SSRSRP = 6,
>     /**
>      * 5G SS reference signal received quality.
>      * Range: -20 dB to -3 dB.
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215.
>      */
>     SSRSRQ = 7,
>     /**
>      * 5G SS signal-to-noise and interference ratio.
>      * Range: -23 dB to 40 dB
>      * Used RAN: NGRAN
>      * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
>      */
>     SSSINR = 8,
> } SignalMeasurementType;
> 
> typedef enum {
>     RADIO_ACCESS_UNKNOWN = 0, /* Unknown access network */
>     RADIO_ACCESS_NET_GERAN = 1, /* GSM EDGE Radio Access Network */
>     RADIO_ACCESS_NET_UTRAN = 2, /* Universal Terrestrial Radio Access Network */
>     RADIO_ACCESS_NET_EUTRAN = 3, /* Evolved Universal Terrestrial Radio Access Network */
>     RADIO_ACCESS_NET_CDMA2000 = 4, /* CDMA 2000 network */
>     RADIO_ACCESS_NET_IWLAN = 5, /* Interworking Wireless LAN */
>     RADIO_ACCESS_NET_NGRAN = 6, /* Next-Generation Radio Access Network */
> /* the following definitions are extended in radio/1.4 */
> } RIL_RadioAccessNetworks_v1_5;
> 
> typedef struct {
>     int32_t hysteresisMs;
>     int32_t hysteresisDb;
>     int32_t thresholdsDbmNumber;
>     int32_t *thresholdsDbm;
>     bool isEnabled;
>     SignalMeasurementType signalMeasurement;
>     RIL_RadioAccessNetworks_v1_5 accessNetwork;
> } RIL_SignalStrengthReportingCriteria_v1_5;
> 
> typedef struct {
>     int32_t hysteresisMs;
>     int32_t hysteresisDlKbps;
>     int32_t hysteresisUlKbps;
>     int32_t thresholdsDownlinkKbpsLength;
>     int32_t *thresholdsDownlinkKbps;
>     int32_t thresholdsUplinkKbpsLength;
>     int32_t *thresholdsUplinkKbps;
>     RIL_RadioAccessNetworks_v1_5 accessNetwork;
> } RIL_LinkCapacityReportingCriteria;
> 
> typedef struct {
1448a1806,1827
> typedef struct  {
>     char alphaLong[32];   /* Long alpha Operator Name String or Enhanced Operator Name String.*/
>     char alphaShort[32];  /* Short alpha Operator Name String or Enhanced Operator Name String */
> } RIL_CellIdentityOperatorNames;
> 
> typedef struct {
>     int mcc;           /* 3-digit Mobile Country Code, in range[0, 999]; This value must
>                         * be valid for registered or camped cells; INT_MAX means invalid/unreported. */
>     int mnc;           /* 2 or 3-digit Mobile Network Code, in range [0, 999], This value must be valid for
>                         * registered or camped cells; INT_MAX means invalid/unreported. */
>     uint64_t nci;      /* NR Cell Identity in range [0, 68719476735] (36 bits) described in 3GPP TS 38.331, which
>                         * unambiguously identifies a cell within a PLMN. This value must be valid for registered or
>                         * camped cells; LONG_MAX (2^63-1) means invalid/unreported.*/
>     uint32_t pci;      /* Physical cell id in range [0, 1007] described in 3GPP TS 38.331. This value must be valid. */
>     int32_t tac;       /* 16-bit tracking area code, INT_MAX means invalid/unreported. */
>     int32_t nrarfcn;   /* NR Absolute Radio Frequency Channel Number, in range [0, 3279165].
>                         * Reference: 3GPP TS 38.101-1 and 3GPP TS 38.101-2 section 5.4.2.1.
>                         * This value must be valid. */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityNr;
> 
1486c1865
<   RIL_CellIdentityTdscdma cellIdentityTdscdma;
---
>   RIL_CellIdentityTdscdma     cellIdentityTdscdma;
1489a1869,1873
> typedef struct {
>   RIL_CellIdentityNr          cellidentity;
>   RIL_NR_SignalStrength       signalStrength;
> } RIL_CellInfoNr;
> 
1497c1881,1882
<   RIL_CELL_INFO_TYPE_TD_SCDMA  = 5
---
>   RIL_CELL_INFO_TYPE_TD_SCDMA  = 5,
>   RIL_CELL_INFO_TYPE_NR        = 6
1508a1894,1900
> typedef enum {
>     CELL_CONNECTION_NONE = 0,           // Cell is not a serving cell.
>     CELL_CONNECTION_PRIMARY_SERVING,    // UE has connection to cell for signalling and
>                                         // possibly data (3GPP 36.331, 25.331).
>     CELL_CONNECTION_SECONDARY_SERVING,  // UE has connection to cell for data (3GPP 36.331, 25.331).
> } RIL_CellConnectionStatus;
> 
1537a1930,1943
>   RIL_CellInfoType          cellInfoType;   /* cell type for selecting from union CellInfo */
>   int                       registered;     /* !0 if this cell is registered 0 if not registered */
>   RIL_CellConnectionStatus  connectionStatus;  /* Connection status for the cell. */
>   union {
>     RIL_CellInfoGsm_v12     gsm;
>     RIL_CellInfoCdma        cdma;
>     RIL_CellInfoLte_v12     lte;
>     RIL_CellInfoWcdma_v12   wcdma;
>     RIL_CellInfoTdscdma     tdscdma;
>     RIL_CellInfoNr          nr;
>   } CellInfo;
> } RIL_CellInfo_v16;
> 
> typedef struct {
1548a1955,2049
>   RIL_CellInfoType  cellInfoType;   /* cell type for selecting from union CellInfo */
>   union {
>     RIL_CellIdentityGsm_v12 cellIdentityGsm;
>     RIL_CellIdentityWcdma_v12 cellIdentityWcdma;
>     RIL_CellIdentityLte_v12 cellIdentityLte;
>     RIL_CellIdentityTdscdma cellIdentityTdscdma;
>     RIL_CellIdentityCdma cellIdentityCdma;
>     RIL_CellIdentityNr cellIdentityNr;
>   };
> } RIL_CellIdentity_v20;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 16-bit GSM Cell Identity described in TS 27.007, 0..65535, INT_MAX if unknown  */
>     int arfcn;  /* 16-bit GSM Absolute RF channel number, INT_MAX if unknown */
>     uint8_t bsic;/* 6-bit Base Station Identity Code, 0xFF if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityGsm_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
>     int psc;    /* 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511, INT_MAX if unknown */
>     int uarfcn; /* 16-bit UMTS Absolute RF Channel Number, INT_MAX if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityWcdma_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int ci;     /* 28-bit Cell Identity described in TS ???, INT_MAX if unknown */
>     int pci;    /* physical cell id 0..503; this value must be reported */
>     int tac;    /* 16-bit tracking area code, INT_MAX if unknown  */
>     int earfcn; /* 18-bit LTE Absolute RF Channel Number; this value must be reported */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
>     int32_t bandwidth;  /* Cell bandwidth, in kHz. */
> } RIL_CellIdentityLte_v1_2;
> 
> typedef struct {
>     int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
>     int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
>     int mnc_digit;/*2 or 3-digit*/
>     int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
>     int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
>     int cpid;    /* 8-bit Cell Parameters ID described in TS 25.331, 0..127, INT_MAX if unknown */
> 
>     int32_t uarfcn;  /* 16-bit UMTS Absolute RF Channel Number defined in TS 25.102 5.4.4; this value must be valid. */
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityTdscdma_v1_2;
> 
> typedef struct {
>     int networkId;      /* Network Id 0..65535, INT_MAX if unknown */
>     int systemId;       /* CDMA System Id 0..32767, INT_MAX if unknown  */
>     int basestationId;  /* Base Station Id 0..65535, INT_MAX if unknown  */
>     int longitude;      /* Longitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
>                          * It is represented in units of 0.25 seconds and ranges from -2592000
>                          * to 2592000, both values inclusive (corresponding to a range of -180
>                          * to +180 degrees). INT_MAX if unknown */
> 
>     int latitude;       /* Latitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
>                          * It is represented in units of 0.25 seconds and ranges from -1296000
>                          * to 1296000, both values inclusive (corresponding to a range of -90
>                          * to +90 degrees). INT_MAX if unknown */
> 
>     RIL_CellIdentityOperatorNames operatorNames;
> } RIL_CellIdentityCdma_v1_2;
> 
> typedef struct {
>     /**
>      * Cell type for selecting from union CellInfo.
>      * Only one of the below vectors must be of size 1 based on a
>      * valid CellInfoType and others must be of size 0.
>      * If cell info type is NONE, then all the vectors must be of size 0.
>      */
>     RIL_CellInfoType cellInfoType;
>     union {
>       RIL_CellIdentityGsm_v1_2 cellIdentityGsm;
>       RIL_CellIdentityWcdma_v1_2 cellIdentityWcdma;
>       RIL_CellIdentityLte_v1_2 cellIdentityLte;
>       RIL_CellIdentityTdscdma_v1_2 cellIdentityTdscdma;
>       RIL_CellIdentityCdma_v1_2 cellIdentityCdma;
>     };
> } RIL_CellIdentity_v1_2;
> 
> typedef struct {
1608d2108
< 
2016a2517,2518
>     RIL_APN_TYPE_MCX          = 0x400,        // APN type for Mission Critical Service
>     RIL_APN_TYPE_XCAP         = 0x800,        // APN type for XCAP
2074,2076c2576,2581
<     GERAN = 0x01,   // GSM EDGE Radio Access Network
<     UTRAN = 0x02,   // Universal Terrestrial Radio Access Network
<     EUTRAN = 0x03,  // Evolved Universal Terrestrial Radio Access Network
---
>     UNKNOWN = 0x00,     // Unknown Radio Access Network
>     GERAN = 0x01,       // GSM EDGE Radio Access Network
>     UTRAN = 0x02,       // Universal Terrestrial Radio Access Network
>     EUTRAN = 0x03,      // Evolved Universal Terrestrial Radio Access Network
>     NGRAN = 0x04,       // Next-Generation Radio Access Network
>     CDMA2000 = 0x05,    // CDMA 2000 Radio AccessNetwork
2078a2584,2588
> typedef struct {
>   char *operatorNumeric;
>   RIL_RadioAccessNetworks act;
> } RIL_NetworkOperator;
> 
2169a2680,2718
> typedef enum {
>     NGRAN_BAND_1 = 1,
>     NGRAN_BAND_2 = 2,
>     NGRAN_BAND_3 = 3,
>     NGRAN_BAND_5 = 5,
>     NGRAN_BAND_7 = 7,
>     NGRAN_BAND_8 = 8,
>     NGRAN_BAND_12 = 12,
>     NGRAN_BAND_20 = 20,
>     NGRAN_BAND_25 = 25,
>     NGRAN_BAND_28 = 28,
>     NGRAN_BAND_34 = 34,
>     NGRAN_BAND_38 = 38,
>     NGRAN_BAND_39 = 39,
>     NGRAN_BAND_40 = 40,
>     NGRAN_BAND_41 = 41,
>     NGRAN_BAND_50 = 50,
>     NGRAN_BAND_51 = 51,
>     NGRAN_BAND_66 = 66,
>     NGRAN_BAND_70 = 70,
>     NGRAN_BAND_71 = 71,
>     NGRAN_BAND_74 = 74,
>     NGRAN_BAND_75 = 75,
>     NGRAN_BAND_76 = 76,
>     NGRAN_BAND_77 = 77,
>     NGRAN_BAND_78 = 78,
>     NGRAN_BAND_79 = 79,
>     NGRAN_BAND_80 = 80,
>     NGRAN_BAND_81 = 81,
>     NGRAN_BAND_82 = 82,
>     NGRAN_BAND_83 = 83,
>     NGRAN_BAND_84 = 84,
>     NGRAN_BAND_86 = 86,
>     NGRAN_BAND_257 = 257,
>     NGRAN_BAND_258 = 258,
>     NGRAN_BAND_260 = 260,
>     NGRAN_BAND_261 = 261,
> } RIL_NgranBands;
> 
2176a2726
>         RIL_NgranBands ngran_bands[MAX_BANDS];
2191a2742,2780
> typedef struct {
>     RIL_RadioAccessNetworks_v1_5 radio_access_network; // The type of network to scan.
>     uint32_t bands_length; // Length of bands
>     union {
>         RIL_GeranBands geran_bands[MAX_BANDS];
>         RIL_UtranBands utran_bands[MAX_BANDS];
>         RIL_EutranBands eutran_bands[MAX_BANDS];
>         RIL_NgranBands ngran_bands[MAX_BANDS];
>     } bands;
>     uint32_t channels_length; // Length of channels
>     uint32_t channels[MAX_CHANNELS]; // Frequency channels to scan
> } RIL_RadioAccessSpecifier_v1_5;
> 
> typedef struct {
>     RIL_ScanType type;
> 
>     int32_t interval;
> 
>     uint32_t specifiers_length;  // Length of specifiers
> 
>     RIL_RadioAccessSpecifier_v1_5 specifiers[RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE];
> 
>     int32_t maxSearchTime;
> 
>     int32_t incrementalResults;
> 
>     int32_t incrementalResultsPeriodicity;
> 
>     uint32_t mccMncsNumbers;
> 
>     char **mccMncs;
> } RIL_NetworkScanRequest_v1_5;
> 
> typedef struct {
>     int                              specifyChannels;
>     uint32_t                         specifiers_length;  // Length of specifiers
>     RIL_RadioAccessSpecifier_v1_5    specifiers[RIL_RADIO_ACCESS_SPECIFIER_MAX_SIZE];  // Radio access networks with bands/channels.
> } RIL_SystemSelectionChannels_v1_5;
> 
2203a2793,2968
> 
> 
> /*********************Structs and Enums Extended in 1.4************************/
> /**
>  * Defining Emergency Service Category as follows:
>  * - General emergency call, all categories;
>  * - Police;
>  * - Ambulance;
>  * - Fire Brigade;
>  * - Marine Guard;
>  * - Mountain Rescue;
>  * - Manually Initiated eCall (MIeC);
>  * - Automatically Initiated eCall (AIeC);
>  *
>  * Category UNSPECIFIED (General emergency call, all categories) indicates that no specific
>  * services are associated with this emergency number.
>  *
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls
>  */
> typedef enum {
>     CATEGORY_UNSPECIFIED     = 0,        /* General emergency call, all categories */
>     CATEGORY_POLICE          = 1 << 0,
>     CATEGORY_AMBULANCE       = 1 << 1,
>     CATEGORY_FIRE_BRIGADE    = 1 << 2,
>     CATEGORY_MARINE_GUARD    = 1 << 3,
>     CATEGORY_MOUNTAIN_RESCUE = 1 << 4,
>     CATEGORY_MIEC            = 1 << 5,  /* Manually Initiated eCall (MIeC) */
>     CATEGORY_AIEC            = 1 << 6,  /* Automatically Initiated eCall (AIeC) */
> } RIL_EmergencyServiceCategory;
> 
> /**
>  * The source to tell where the corresponding @1.4::EmergencyNumber comes from.
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls
>  */
> typedef enum {
>     SOURCE_NETWORK_SIGNALING   = 1 << 0,   /* Indicates the number is from the network signal. */
>     SOURCE_SIM                 = 1 << 1,   /* Indicates the number is from the sim card. */
>     SOURCE_MODEM_CONFIG        = 1 << 2,   /* Indicates the number is from the modem config. */
>     SOURCE_DEFAULT             = 1 << 3,   /* Indicates the number is available as default.
>                                             * Per the reference, 112, 911 must always be available;
>                                             * additionally, 000, 08, 110, 999, 118 and 119 must be available
>                                             * when sim is not present. */
> } RIL_EmergencyNumberSource;
> 
> /**
>  * Indicates how the implementation should handle the emergency call if it is required by Android.
>  */
> typedef enum {
>     ROUTING_UNKNOWN    = 0,  /* Indicates Android does not require how to handle
>                                    * the corresponding emergency call; it is decided by implementation. */
>     ROUTING_MERGENCY   = 1,  /* Indicates the implementation must handle the call through emergency routing. */
>     ROUTING_NORMAL     = 2,  /* Indicates the implementation must handle the call through normal call routing. */
> } RIL_EmergencyCallRouting;
> 
> /**
>  * Emergency number contains information of number, one or more service category(s), zero or more
>  * emergency uniform resource names, mobile country code (mcc), mobile network country (mnc) and
>  * source(s) that indicate where it comes from.
>  *
>  * If the emergency number is associated with country, field ‘mcc’ must be provided, otherwise
>  * field ‘mcc’ must be an empty string. If the emergency number is associated with network
>  * operator, field ‘mcc’ and 'mnc' must be provided, otherwise field ‘mnc’ must be an empty
>  * string. If the emergency number is specified with emergency service category(s), field
>  * 'categories' must be provided, otherwise field 'categories' must be
>  * @1.4::EmergencyServiceCategories::UNSPECIFIED. If the emergency number is specified with
>  * emergency uniform resource names (URN), field 'urns' must be provided, otherwise field 'urns'
>  * must be an empty list.
>  *
>  * A unique EmergencyNumber has a unique combination of ‘number’, ‘mcc’, 'mnc', 'categories' and
>  * 'urns' fields. Multiple @1.4::EmergencyNumberSource should be merged into one 'sources' field
>  * via bitwise-OR combination for the same EmergencyNumber.
>  *
>  * Reference: 3gpp 22.101, Section 10 - Emergency Calls;
>  *            3gpp 23.167, Section 6 - Functional description;
>  *            3gpp 24.503, Section 5.1.6.8.1 - General;
>  *            RFC 5031
>  */
> typedef struct {
>     RIL_Dial                     dialInfo;
>     RIL_EmergencyServiceCategory categories; /* The bitfield of @1.4::EmergencyServiceCategory(s).
>                                               * See RIL_EmergencyServiceCategory for the value of each bit. */
>     uint32_t                     urnsNumber;
>     char **                      urns;       /* The list of emergency Uniform Resource Names (URN). */
>     RIL_EmergencyNumberSource    sources;    /* The bitfield of @1.4::EmergencyNumberSource(s).
>                                               * See RIL_EmergencyNumberSource for the value of each bit. */
>     RIL_EmergencyCallRouting     routing;
>     bool                         fromEmergencyDialer;
> } RIL_EmergencyDial;
> 
> /******************************************************************************/
> /* Radio Config structure @{ */
> typedef enum {
>     /* Physical slot is inactive*/
>     SLOT_STATE_INACTIVE  = 0x00,
>     /* Physical slot is active */
>     SLOT_STATE_ACTIVE    = 0x01,
> } RIL_SlotState;
> 
> typedef struct {
>     /* Card state in the physical slot*/
>     RIL_CardState cardState;
>     /* Slot state Active/Inactive */
>     RIL_SlotState slotState;
>     /**
>       * An Answer To Reset (ATR) is a message output by a Smart Card conforming to ISO/IEC 7816
>       * standards, following electrical reset of the card's chip. The ATR conveys information about
>       * the communication parameters proposed by the card, and the card's nature and state.
>       * This data is applicable only when cardState is CardState:PRESENT.
>       */
>     char* atr;
>     int logicalSlotId;
>     /**
>       * Integrated Circuit Card IDentifier (ICCID) is Unique Identifier of the SIM CARD. File is
>       * located in the SIM card at EFiccid (0x2FE2) as per ETSI 102.221. The ICCID is defined by
>       * the ITU-T recommendation E.118 ISO/IEC 7816.
>       * This data is applicable only when cardState is CardState:PRESENT.
>       */
>     char* iccid;
> } RIL_SimSlotStatus;
> 
> typedef struct {
>     RIL_SimSlotStatus base;
>     /**
>       * The EID is the eUICC identifier. The EID shall be stored within the ECASD and can be
>       * retrieved by the Device at any time using the standard GlobalPlatform GET DATA command.
>       *
>       * This data is mandatory and applicable only when cardState is CardState:PRESENT and SIM card
>       * supports eUICC.
>       */
>     char* eid;
> } RIL_SimSlotStatus_V1_2;
> 
> #define MAX_LOGICAL_MODEM_NUM 4
> 
> typedef struct {
>     /* Logical modem ID. */
>     int modemId;
> } RIL_ModemInfo;
> 
> typedef struct {
>     /**
>      * maxActiveData defines how many logical modems can have
>      * PS attached simultaneously. For example, for L+L modem it
>      * should be 2.
>      */
>     int maxActiveData;
>     /**
>      * maxActiveData defines how many logical modems can have
>      * internet PDN connections simultaneously. For example, for L+L
>      * DSDS modem it’s 1, and for DSDA modem it’s 2.
>      */
>     int maxActiveInternetData;
>     /**
>      * Whether modem supports both internet PDN up so
>      * that we can do ping test before tearing down the
>      * other one.
>      */
>     int isInternetLingeringSupported;
>     /**
>      * List of logical modem information.
>      */
>     RIL_ModemInfo logicalModemList[MAX_LOGICAL_MODEM_NUM];
> } RIL_PhoneCapability;
> 
> typedef struct {
>     int numOfLiveModems;
> } RIL_ModemConfig;
> /* }@ */
> 
> typedef enum {
>     DATA_REQ_REASOPN_NORMAL    = 0x01,  // The reason of the data request is normal
>     DATA_REQ_REASOPN_SHUTDOWN  = 0x02,  // The reason of the data request is device shutdown
>     DATA_REQ_REASOPN_HANDOVER  = 0x03,  // The reason of the data request is IWLAN data handover
>                                         // to another transport (e.g. from cellular to wifi or vise versa)
> } RIL_DataRequestReason;
> 
6341a7107,7657
> /**
>  * RIL_REQUEST_GET_MODEM_STACK_STATUS
>  *
>  * Request status of a logical modem
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  MODEM_ERR
>  *
>  */
> #define RIL_REQUEST_GET_MODEM_STACK_STATUS 146
> 
> /**
>  * @param info Response info struct containing response type, serial no. and error
>  * @param networkTypeBitmap a 32-bit bitmap of RadioAccessFamily.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:INTERNAL_ERR
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:MODEM_ERR
>  *   RadioError:REQUEST_NOT_SUPPORTED
>  *   RadioError:NO_RESOURCES
>  */
> #define RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE_BITMAP 147
> 
> /**
>  * Callback of IRadio.setPreferredNetworkTypeBitmap(int, bitfield<RadioAccessFamily>)
>  *
>  * @param info Response info struct containing response type, serial no. and error
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:OPERATION_NOT_ALLOWED
>  *   RadioError:MODE_NOT_SUPPORTED
>  *   RadioError:INTERNAL_ERR
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:MODEM_ERR
>  *   RadioError:REQUEST_NOT_SUPPORTED
>  *   RadioError:NO_RESOURCES
>  */
> #define RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE_BITMAP 148
> 
> /**
>  * RIL_REQUEST_EMERGENCY_DIAL
>  *
>  * Initiate emergency voice call, with zero or more emergency service category(s), zero or
>  * more emergency Uniform Resource Names (URN), and routing information for handling the call.
>  * Android uses this request to make its emergency call instead of using @1.0::IRadio.dial
>  * if the 'address' in the 'dialInfo' field is identified as an emergency number by Android.
>  *
>  * In multi-sim scenario, if the emergency number is from a specific subscription, this radio
>  * request is sent through the IRadio service that serves the subscription, no matter of the
>  * PUK/PIN state of the subscription and the service state of the radio.
>  *
>  * Some countries or carriers require some emergency numbers that must be handled with normal
>  * call routing or emergency routing. If the 'routing' field is specified as
>  * @1.4::EmergencyNumberRouting#NORMAL, the implementation must use normal call routing to
>  * handle the call; if it is specified as @1.4::EmergencyNumberRouting#EMERGENCY, the
>  * implementation must use emergency routing to handle the call; if it is
>  * @1.4::EmergencyNumberRouting#UNKNOWN, Android does not know how to handle the call.
>  *
>  * If the dialed emergency number does not have a specified emergency service category, the
>  * 'categories' field is set to @1.4::EmergencyServiceCategory#UNSPECIFIED; if the dialed
>  * emergency number does not have specified emergency Uniform Resource Names, the 'urns' field
>  * is set to an empty list. If the underlying technology used to request emergency services
>  * does not support the emergency service category or emergency uniform resource names, the
>  * field 'categories' or 'urns' may be ignored.
>  *
>  * 'fromEmergencyDialer' indicates if this request originated from emergency dialer/shortcut,
>  * which means an explicit intent from the user to dial an emergency number. The modem must
>  * treat this as an actual emergency dial and not try to disambiguate.
>  *
>  * If 'isTesting' is true, this request is for testing purpose, and must not be sent to a real
>  * emergency service; otherwise it's for a real emergency call request.
>  * Valid errors:
>  *  NONE
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  DIAL_MODIFIED_TO_USSD
>  *  DIAL_MODIFIED_TO_SS
>  *  DIAL_MODIFIED_TO_DIAL
>  *  INVALID_ARGUMENTS
>  *  NO_RESOURCES
>  *  INTERNAL_ERR
>  *  FDN_CHECK_FAILURE
>  *  MODEM_ERR
>  *  NO_SUBSCRIPTION
>  *  NO_NETWORK_FOUND
>  *  INVALID_CALL_ID
>  *  DEVICE_IN_USE
>  *  ABORTED
>  *  INVALID_MODEM_STATE
>  */
> #define RIL_REQUEST_EMERGENCY_DIAL 149
> 
> /**
>  * Specify which bands modem's background scan must act on.
>  * If specifyChannels is true, it only scans bands specified in specifiers.
>  * If specifyChannels is false, it scans all bands.
>  *
>  * For example, CBRS is only on LTE band 48. By specifying this band,
>  * modem saves more power.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  INTERNAL_ERR
>  *
>  */
> #define RIL_REQUEST_SET_SYSTEM_SELECTION_CHANNELS 150
> 
> /**
>  * RIL_REQUEST_ENABLE_MODEM
>  *
>  * Enable a logical modem
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  MODEM_ERR
>  *
>  */
> #define RIL_REQUEST_ENABLE_MODEM 151
> 
> /**
>  * RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA
>  *
>  * Sets the signal strength reporting criteria.
>  *
>  * The resulting reporting rules are the AND of all the supplied criteria. For each RAN
>  * The hysteresisDb apply to only the following measured quantities:
>  * -GERAN    - RSSI
>  * -CDMA2000 - RSSI
>  * -UTRAN    - RSCP
>  * -EUTRAN   - RSRP/RSRQ/RSSNR
>  *
>  * The thresholds apply to only the following measured quantities:
>  * -GERAN    - RSSI
>  * -CDMA2000 - RSSI
>  * -UTRAN    - RSCP
>  * -EUTRAN   - RSRP/RSRQ/RSSNR
>  * -NGRAN    - SSRSRP/SSRSRQ/SSSINR
>  *
>  * Note: Reporting criteria must be individually set for each RAN. For any unset reporting
>  * criteria, the value is implementation-defined.
>  *
>  * Note: @1.5::SignalThresholdInfo includes fields 'hysteresisDb', 'hysteresisMs',
>  * and 'thresholds'. As this mechanism generally only constrains reports based on one
>  * measured quantity per RAN, if multiple measured quantities must be used to trigger a report
>  * for a given RAN, the only valid field may be hysteresisMs: hysteresisDb and thresholds must
>  * be set to zero and length zero respectively. If either hysteresisDb or thresholds is set,
>  * then reports shall only be triggered by the respective measured quantity, subject to the
>  * applied constraints.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:RADIO_NOT_AVAILABLE
>  */
> #define RIL_REQUEST_SET_SIGNAL_STRENGTH_REPORTING_CRITERIA 152
> 
> /**
>  * RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA
>  *
>  * Sets the link capacity reporting criteria. The resulting reporting criteria are the AND of
>  * all the supplied criteria.
>  *
>  * Note: Reporting criteria ust be individually set for each RAN. If unset, reporting criteria
>  * for that RAN are implementation-defined.
>  *
>  * Valid errors returned:
>  *   RadioError:NONE
>  *   RadioError:INVALID_ARGUMENTS
>  *   RadioError:RADIO_NOT_AVAILABLE
>  *   RadioError:INTERNAL_ERR
>  */
> #define RIL_REQUEST_SET_LINK_CAPACITY_REPORTING_CRITERIA 153
> 
> /**
>  * RIL_REQUEST_ENABLE_UICC_APPLICATIONS
>  *
>  * Enable or disable uicc applications.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  *  REQUEST_NOT_SUPPORTED
>  */
> #define RIL_REQUEST_ENABLE_UICC_APPLICATIONS 154
> 
> /**
>  * RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED
>  *
>  * Whether uicc applications are enabled.
>  *
>  * Response: a boolean of enable or not.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  *  REQUEST_NOT_SUPPORTED
>  */
> #define RIL_REQUEST_ARE_UICC_APPLICATIONS_ENABLED 155
> 
> /**
>  * RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION
>  *
>  * Requests that sim personlization be deactivated
>  *
>  * "data" is const char **
>  * ((const char **)(data))[0]] is  sim depersonlization code
>  *
>  * "response" is int *
>  * ((int *)response)[0] is the number of retries remaining,
>  * or -1 if number of retries are infinite.
>  *
>  * Valid errors:
>  *
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  PASSWORD_INCORRECT
>  *  SIM_ABSENT (code is invalid)
>  *  INTERNAL_ERR
>  *  NO_MEMORY
>  *  NO_RESOURCES
>  *  CANCELLED
>  *  REQUEST_NOT_SUPPORTED
>  */
> 
> #define RIL_REQUEST_ENTER_SIM_DEPERSONALIZATION 156
> 
> /**
>  * RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE
>  *
>  * Send a CDMA SMS message
>  *
>  * "data" is const RIL_CDMA_SMS_Message *
>  *
>  * "response" is a const RIL_SMS_Response *
>  *
>  * Based on the return error, caller decides to resend if sending sms
>  * fails. The CDMA error class is derived as follows,
>  * SUCCESS is error class 0 (no error)
>  * SMS_SEND_FAIL_RETRY is error class 2 (temporary failure)
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SMS_SEND_FAIL_RETRY
>  *  NETWORK_REJECT
>  *  INVALID_STATE
>  *  INVALID_ARGUMENTS
>  *  NO_MEMORY
>  *  REQUEST_RATE_LIMITED
>  *  INVALID_SMS_FORMAT
>  *  SYSTEM_ERR
>  *  FDN_CHECK_FAILURE
>  *  MODEM_ERR
>  *  NETWORK_ERR
>  *  ENCODING_ERR
>  *  INVALID_SMSC_ADDRESS
>  *  OPERATION_NOT_ALLOWED
>  *  NO_RESOURCES
>  *  CANCELLED
>  *  REQUEST_NOT_SUPPORTED
>  *  MODE_NOT_SUPPORTED
>  *  SIM_ABSENT
>  */
> #define RIL_REQUEST_CDMA_SEND_SMS_EXPECT_MORE 157
> 
> /**
>  * Get all the barring info for the current camped cell applicable to the current user.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getBarringInfoResponse()
>  */
> #define RIL_REQUEST_GET_BARRING_INFO 158
> 
> /**
>  * RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY
>  *
>  * Enable or disable E-UTRA-NR dual connectivity.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  */
> #define RIL_REQUEST_ENABLE_NR_DUAL_CONNECTIVITY 159
> 
> /**
>  * RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED
>  *
>  * Whether E-UTRA-NR dual connectivity is enabled.
>  *
>  * Response: a boolean of enable or not.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  SIM_ABSENT
>  *  INTERNAL_ERR
>  */
> #define RIL_REQUEST_IS_NR_DUAL_CONNECTIVITY_ENABLED 160
> 
> /**
>  * Allocates a pdu session id
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.allocatePduSessionIdResponse()
>  */
> #define RIL_REQUEST_ALLOCATE_PDU_SESSION_ID 161
> 
> /**
>  * Releases a pdu session id
>  *
>  * @param serial Serial number of request.
>  * @param id Pdu session id to release
>  *
>  * Response callback is IRadioResponse.releasePduSessionIdResponse()
>  */
> #define RIL_REQUEST_RELEASE_PDU_SESSION_ID 162
> 
> /**
>  * Indicates that handover has begun
>  *
>  * @param serial Serial number of request.
>  * @param callId The unique identifier of the corresponding data call
>  *
>  * Response callback is IRadioResponse.startHandoverResponse()
>  */
> #define RIL_REQUEST_START_HANDOVER 163
> 
> /**
>  * Indicates that a handover has been cancelled
>  *
>  * @param serial Serial number of request.
>  * @param callId The unique identifier of the corresponding data call
>  *
>  * Response callback is IRadioResponse.cancelHandoverResponse()
>  */
> #define RIL_REQUEST_CANCEL_HANDOVER 164
> 
> /**
>  * RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP
>  *
>  * Instruct the radio to *only* accept the types of network provided. This
>  * is stronger than setPreferredNetworkType which is a suggestion.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  OPERATION_NOT_ALLOWED
>  *  MODE_NOT_SUPPORTED
>  *  NO_MEMORY
>  *  INTERNAL_ERR
>  *  SYSTEM_ERR
>  *  INVALID_ARGUMENTS
>  *  MODEM_ERR
>  *  REQUEST_NOT_SUPPORTED
>  *  NO_RESOURCES
>  *  CANCELLED
>  */
> #define RIL_REQUEST_SET_ALLOWED_NETWORK_TYPES_BITMAP 165
> 
> /**
> * RIL_REQUEST_SET_DATA_THROTTLING
> *
> * Set the data throttling on device.
> *
> * Response: an int enum of type ThermalMitigationResult as defined in
> * android.telephony.Annotation.
> *
> * Valid errors:
> *  SUCCESS
> *  RADIO_NOT_AVAILABLE
> *  MODEM_ERR
> *  INVALID_ARGUMENTS
> */
> #define RIL_REQUEST_SET_DATA_THROTTLING 166
> 
> /**
>  * Get which bands the modem's background scan is acting on.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE
>  *  INTERNAL_ERR
>  *
>  */
> #define RIL_REQUEST_GET_SYSTEM_SELECTION_CHANNELS 167
> 
> /**
>  * RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP
>  *
>  * Request previously set allowed network types from the radio.
>  *
>  * Valid errors:
>  *  SUCCESS
>  *  RADIO_NOT_AVAILABLE (radio resetting)
>  *  OPERATION_NOT_ALLOWED
>  *  MODE_NOT_SUPPORTED
>  *  NO_MEMORY
>  *  INTERNAL_ERR
>  *  SYSTEM_ERR
>  *  INVALID_ARGUMENTS
>  *  MODEM_ERR
>  *  REQUEST_NOT_SUPPORTED
>  *  NO_RESOURCES
>  *  CANCELLED
>  */
> #define RIL_REQUEST_GET_ALLOWED_NETWORK_TYPES_BITMAP 168
> 
> /**
>  * RIL_REQUEST_GET_SLICING_CONFIG
>  *
>  * Request to get the current slicing configuration including URSP rules and
>  * NSSAIs (configured, allowed and rejected).
>  *
>  * Response callback is IRadioResponse.getSlicingConfigResponse()
>  */
> #define RIL_REQUEST_GET_SLICING_CONFIG 169
> 
> #define RIL_REQUEST_GET_SIM_PHONEBOOK_RECORDS 170
> 
> #define RIL_REQUEST_GET_SIM_PHONEBOOK_CAPACITY 171
> 
> #define RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS 172
> 
> 
> #define RIL_REQUEST_LAST RIL_REQUEST_UPDATE_SIM_PHONEBOOK_RECORDS
> 
> /***********************************************************************/
> 
> /* Radio Config @{ */
> #define RIL_REQUEST_RADIO_CONFIG_BASE 600
> 
> /**
>  * Get SIM Slot status.
>  *
>  * Request provides the slot status of all active and inactive SIM slots and whether card is
>  * present in the slots or not.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioConfigResponse.getSimSlotsStatusResponse()
>  */
> #define RIL_REQUEST_CONFIG_GET_SLOT_STATUS 601
> 
> /**
>  * Set SIM Slot mapping.
> 
>  * Maps the logical slots to the physical slots. Logical slot is the slot that is seen by modem.
>  * Physical slot is the actual physical slot. Request maps the physical slot to logical slot.
>  * Logical slots that are already mapped to the requested physical slot are not impacted.
>  *
>  * Example no. of logical slots 1 and physical slots 2:
>  * The only logical slot (index 0) can be mapped to first physical slot (value 0) or second
>  * physical slot(value 1), while the other physical slot remains unmapped and inactive.
>  * slotMap[0] = 1 or slotMap[0] = 0
>  *
>  * Example no. of logical slots 2 and physical slots 2:
>  * First logical slot (index 0) can be mapped to physical slot 1 or 2 and other logical slot
>  * can be mapped to other physical slot. Each logical slot must be mapped to a physical slot.
>  * slotMap[0] = 0 and slotMap[1] = 1 or slotMap[0] = 1 and slotMap[1] = 0
>  *
>  * @param serial Serial number of request
>  * @param slotMap Logical to physical slot mapping, size == no. of radio instances. Index is
>  *        mapping to logical slot and value to physical slot, need to provide all the slots
>  *        mapping when sending request in case of multi slot device.
>  *        EX: uint32_t slotMap[logical slot] = physical slot
>  *        index 0 is the first logical_slot number of logical slots is equal to number of Radio
>  *        instances and number of physical slots is equal to size of slotStatus in
>  *        getSimSlotsStatusResponse
>  *
>  * Response callback is IRadioConfigResponse.setSimSlotsMappingResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_SLOT_MAPPING 602
> 
> /**
>  * Request current phone capability.
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getPhoneCapabilityResponse() which
>  * will return <@1.1::PhoneCapability>.
>  */
> #define RIL_REQUEST_CONFIG_GET_PHONE_CAPABILITY 603
> 
> /**
>  * Set preferred data modem Id.
>  * In a multi-SIM device, notify modem layer which logical modem will be used primarily
>  * for data. It helps modem with resource optimization and decisions of what data connections
>  * should be satisfied.
>  *
>  * @param serial Serial number of request.
>  * @param modem Id the logical modem ID, which should match one of modem IDs returned
>  * from getPhoneCapability().
>  *
>  * Response callback is IRadioConfigResponse.setPreferredDataModemResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_PREFER_DATA_MODEM 604
> 
> /**
>  * Set modems configurations by specifying the number of live modems (i.e modems that are
>  * enabled and actively working as part of a working telephony stack).
>  *
>  * Example: this interface can be used to switch to single/multi sim mode by specifying
>  * the number of live modems as 1, 2, etc
>  *
>  * Note: by setting the number of live modems in this API, that number of modems will
>  * subsequently get enabled/disabled
>  *
>  * @param serial serial number of request.
>  * @param modemsConfig ModemsConfig object including the number of live modems
>  *
>  * Response callback is IRadioResponse.setModemsConfigResponse()
>  */
> #define RIL_REQUEST_CONFIG_SET_MODEM_CONFIG 605
> 
> /**
>  * Get modems configurations. This interface is used to get modem configurations
>  * which includes the number of live modems (i.e modems that are
>  * enabled and actively working as part of a working telephony stack)
>  *
>  * Note: in order to get the overall number of modems available on the phone,
>  * refer to getPhoneCapability API
>  *
>  * @param serial Serial number of request.
>  *
>  * Response callback is IRadioResponse.getModemsConfigResponse() which
>  * will return <@1.1::ModemsConfig>.
>  */
> #define RIL_REQUEST_CONFIG_GET_MODEM_CONFIG 606
> 
> #define RIL_REQUEST_CONFIG_GET_HAL_DEVICE_CAPABILITIES 607
> 
> /* Make sure to update ril_config_commands.h when changing this constant. */
> #define RIL_REQUEST_RADIO_CONFIG_LAST    RIL_REQUEST_CONFIG_GET_HAL_DEVICE_CAPABILITIES
> /* }@ */
> 
7024a8341,8356
> 
> #define RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS 1051
> 
> #define RIL_UNSOL_RESPONSE_LAST RIL_UNSOL_PHYSICAL_CHANNEL_CONFIGS
> 
> /***********************************************************************/
> 
> #define RIL_UNSOL_RESPONSE_RADIO_CONFIG_BASE 1100
> /**
>  * RIL_UNSOL_CONFIG_ICC_SLOT_STATUS
>  *
>  * "data" is the RIL_SimSlotStatus_V1_2 structure
>  */
> #define RIL_UNSOL_CONFIG_ICC_SLOT_STATUS 1052
> 
> #define RIL_UNSOL_RESPONSE_RADIO_CONFIG_LAST RIL_UNSOL_CONFIG_ICC_SLOT_STATUS
diff -r /home/yajat/Desktop/aosp12_r11/hardware/ril/rild/Android.mk /home/yajat/Desktop/H618-Android12-Src/hardware/ril/rild/Android.mk
31a32
> LOCAL_VINTF_FRAGMENTS := radio.xml
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/ril/rild: radio.xml
Only in /home/yajat/Desktop/aosp12_r11/hardware/samsung/nfc: .git
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: sprd
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: ssv
Only in /home/yajat/Desktop/aosp12_r11/hardware/st/nfc: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/st/secure_element: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/st/secure_element2: .git
Only in /home/yajat/Desktop/aosp12_r11/hardware/ti/am57x: .git
Only in /home/yajat/Desktop/H618-Android12-Src/hardware/: xradio
